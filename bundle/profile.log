SCRIPT  /usr/share/vim/vimrc
Sourced 1 time
Total time:   0.018743
 Self time:   0.000156

count  total (s)   self (s)
                            " All system-wide defaults are set in $VIMRUNTIME/debian.vim (usually just
                            " /usr/share/vim/vimcurrent/debian.vim) and sourced by the call to :runtime
                            " you can find below.  If you wish to change any of those settings, you should
                            " do it in this file (/etc/vim/vimrc), since debian.vim will be overwritten
                            " everytime an upgrade of the vim packages is performed.  It is recommended to
                            " make changes after sourcing debian.vim since it alters the value of the
                            " 'compatible' option.
                            
                            " This line should not be removed as it ensures that various options are
                            " properly set to work with the Vim-related packages available in Debian.
    1              0.000045 runtime! debian.vim
                            
                            " Uncomment the next line to make Vim more Vi-compatible
                            " NOTE: debian.vim sets 'nocompatible'.  Setting 'compatible' changes numerous
                            " options, so any other options should be set AFTER setting 'compatible'.
                            "set compatible
                            
                            " Vim5 and later versions support syntax highlighting. Uncommenting the next
                            " line enables syntax highlighting by default.
    1              0.000005 if has("syntax")
    1              0.000031   syntax on
    1              0.000002 endif
                            
                            " If using a dark background within the editing area and syntax highlighting
                            " turn on this option as well
                            "set background=dark
                            
                            " Uncomment the following to have Vim jump to the last position when
                            " reopening a file
                            "if has("autocmd")
                            "  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
                            "endif
                            
                            " Uncomment the following to have Vim load indentation rules and plugins
                            " according to the detected filetype.
                            "if has("autocmd")
                            "  filetype plugin indent on
                            "endif
                            
                            " The following are commented out as they cause vim to behave a lot
                            " differently from regular Vi. They are highly recommended though.
                            "set showcmd		" Show (partial) command in status line.
                            "set showmatch		" Show matching brackets.
                            "set ignorecase		" Do case insensitive matching
                            "set smartcase		" Do smart case matching
                            "set incsearch		" Incremental search
                            "set autowrite		" Automatically save before commands like :next and :make
                            "set hidden             " Hide buffers when they are abandoned
                            "set mouse=a		" Enable mouse usage (all modes)
                            
                            " Source a global configuration file if available
    1              0.000009 if filereadable("/etc/vim/vimrc.local")
                              source /etc/vim/vimrc.local
                            endif
                            

SCRIPT  /usr/share/vim/vim73/debian.vim
Sourced 1 time
Total time:   0.000316
 Self time:   0.000316

count  total (s)   self (s)
                            " Debian system-wide default configuration Vim
                            
    1              0.000012 set runtimepath=~/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim73,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,~/.vim/after
                            
                            " Normally we use vim-extensions. If you want true vi-compatibility
                            " remove change the following statements
    1              0.000050 set nocompatible	" Use Vim defaults instead of 100% vi compatibility
    1              0.000004 set backspace=indent,eol,start	" more powerful backspacing
                            
                            " Now we set some defaults for the editor
    1              0.000003 set history=50		" keep 50 lines of command line history
    1              0.000002 set ruler		" show the cursor position all the time
                            
                            " modelines have historically been a source of security/resource
                            " vulnerabilities -- disable by default, even when 'nocompatible' is set
    1              0.000001 set nomodeline
                            
                            " Suffixes that get lower priority when doing tab completion for filenames.
                            " These are files we are not likely to want to edit or read.
    1              0.000004 set suffixes=.bak,~,.swp,.o,.info,.aux,.log,.dvi,.bbl,.blg,.brf,.cb,.ind,.idx,.ilg,.inx,.out,.toc
                            
                            " We know xterm-debian is a color terminal
    1              0.000022 if &term =~ "xterm-debian" || &term =~ "xterm-xfree86"
                              set t_Co=16
                              set t_Sf=[3%dm
                              set t_Sb=[4%dm
                            endif
                            
                            " Some Debian-specific things
    1              0.000009 if has("autocmd")
                              " set mail filetype for reportbug's temp files
    1              0.000004   augroup debian
    1              0.000008     au BufRead reportbug-*		set ft=mail
    1              0.000002   augroup END
    1              0.000001 endif
                            
                            " Set paper size from /etc/papersize if available (Debian-specific)
    1              0.000009 if filereadable("/etc/papersize")
    1              0.000047   let s:papersize = matchstr(readfile('/etc/papersize', '', 1), '\p*')
    1              0.000004   if strlen(s:papersize)
    1              0.000011     exe "set printoptions+=paper:" . s:papersize
    1              0.000001   endif
    1              0.000001 endif
                            
    1              0.000006 if has('gui_running')
                              " Make shift-insert work like in Xterm
                              map <S-Insert> <MiddleMouse>
                              map! <S-Insert> <MiddleMouse>
                            endif
                            
    1              0.000019 if executable("launchpad-integration")
                              " Launchpad integration
    1              0.000023   an 9999.76 &Help.Get\ Help\ Online\.\.\.             :call <SID>LPI("--info")<CR>
    1              0.000013   an 9999.77 &Help.Translate\ This\ Application\.\.\.  :call <SID>LPI("--translate")<CR>
    1              0.000010   an 9999.78 &Help.Report\ a\ Problem\.\.\.            :call <SID>LPI("--bugs")<CR>
    1              0.000004   an 9999.79 &Help.-lpisep-                            <Nop>
                            
    1              0.000007   fun! s:LPI(opt)
                                call system("launchpad-integration --pid " . getpid() . " " . a:opt)
                              endfun
    1              0.000003 endif

SCRIPT  /usr/share/vim/vim73/syntax/syntax.vim
Sourced 1 time
Total time:   0.018265
 Self time:   0.000190

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2001 Sep 04
                            
                            " This file is used for ":syntax on".
                            " It installs the autocommands and starts highlighting for all buffers.
                            
    1              0.000005 if !has("syntax")
                              finish
                            endif
                            
                            " If Syntax highlighting appears to be on already, turn it off first, so that
                            " any leftovers are cleared.
    1              0.000005 if exists("syntax_on") || exists("syntax_manual")
                              so <sfile>:p:h/nosyntax.vim
                            endif
                            
                            " Load the Syntax autocommands and set the default methods for highlighting.
    1              0.000041 runtime syntax/synload.vim
                            
                            " Load the FileType autocommands if not done yet.
    1              0.000004 if exists("did_load_filetypes")
                              let s:did_ft = 1
                            else
    1              0.000034   filetype on
    1              0.000006   let s:did_ft = 0
    1              0.000001 endif
                            
                            " Set up the connection between FileType and Syntax autocommands.
                            " This makes the syntax automatically set when the file type is detected.
    1              0.000002 augroup syntaxset
    1              0.000006   au! FileType *	exe "set syntax=" . expand("<amatch>")
    1              0.000001 augroup END
                            
                            
                            " Execute the syntax autocommands for the each buffer.
                            " If the filetype wasn't detected yet, do that now.
                            " Always do the syntaxset autocommands, for buffers where the 'filetype'
                            " already was set manually (e.g., help buffers).
    1              0.000003 doautoall syntaxset FileType
    1              0.000002 if !s:did_ft
    1              0.000001   doautoall filetypedetect BufRead
    1              0.000003 endif

SCRIPT  /usr/share/vim/vim73/syntax/synload.vim
Sourced 1 time
Total time:   0.000513
 Self time:   0.000231

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2010 Aug 08
                            
                            " This file sets up for syntax highlighting.
                            " It is loaded from "syntax.vim" and "manual.vim".
                            " 1. Set the default highlight groups.
                            " 2. Install Syntax autocommands for all the available syntax files.
                            
    1              0.000005 if !has("syntax")
                              finish
                            endif
                            
                            " let others know that syntax has been switched on
    1              0.000003 let syntax_on = 1
                            
                            " Set the default highlighting colors.  Use a color scheme if specified.
    1              0.000003 if exists("colors_name")
                              exe "colors " . colors_name
                            else
    1              0.000038   runtime! syntax/syncolor.vim
    1              0.000002 endif
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000042 let s:cpo_save = &cpo
    1              0.000010 set cpo&vim
                            
                            " First remove all old syntax autocommands.
    1              0.000004 au! Syntax
                            
    1              0.000006 au Syntax *		call s:SynSet()
                            
    1              0.000004 fun! s:SynSet()
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
                              syn clear
                              if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
                              let s = expand("<amatch>")
                              if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              endif
                            
                              if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
                                for name in split(s, '\.')
                                  exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
                                endfor
                              endif
                            endfun
                            
                            
                            " Handle adding doxygen to other languages (C, C++, C#, IDL)
    1              0.000019 au Syntax c,cpp,cs,idl
                            	\ if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)
                            	\	|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)
                            	\   | runtime! syntax/doxygen.vim
                            	\ | endif
                            
                            
                            " Source the user-specified syntax highlighting file
    1              0.000007 if exists("mysyntaxfile") && filereadable(expand(mysyntaxfile))
                              execute "source " . mysyntaxfile
                            endif
                            
                            " Restore 'cpoptions'
    1              0.000014 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save

SCRIPT  /usr/share/vim/vim73/syntax/syncolor.vim
Sourced 3 times
Total time:   0.000746
 Self time:   0.000746

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2001 Sep 12
                            
                            " This file sets up the default methods for highlighting.
                            " It is loaded from "synload.vim" and from Vim for ":syntax reset".
                            " Also used from init_highlight().
                            
    3              0.000018 if !exists("syntax_cmd") || syntax_cmd == "on"
                              " ":syntax on" works like in Vim 5.7: set colors but keep links
    2              0.000019   command -nargs=* SynColor hi <args>
    2              0.000014   command -nargs=* SynLink hi link <args>
    2              0.000002 else
    1              0.000003   if syntax_cmd == "enable"
                                " ":syntax enable" keeps any existing colors
                                command -nargs=* SynColor hi def <args>
                                command -nargs=* SynLink hi def link <args>
                              elseif syntax_cmd == "reset"
                                " ":syntax reset" resets all colors to the default
    1              0.000007     command -nargs=* SynColor hi <args>
    1              0.000006     command -nargs=* SynLink hi! link <args>
    1              0.000001   else
                                " User defined syncolor file has already set the colors.
                                finish
                              endif
    1              0.000001 endif
                            
                            " Many terminals can only use six different colors (plus black and white).
                            " Therefore the number of colors used is kept low. It doesn't look nice with
                            " too many colors anyway.
                            " Careful with "cterm=bold", it changes the color to bright for some terminals.
                            " There are two sets of defaults: for a dark and a light background.
    3              0.000010 if &background == "dark"
                              SynColor Comment	term=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
                              SynColor Constant	term=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
                              SynColor Special	term=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
                              SynColor Identifier	term=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
                              SynColor Statement	term=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
                              SynColor PreProc	term=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
                              SynColor Type		term=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
                              SynColor Underlined	term=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
                              SynColor Ignore	term=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
                            else
    3              0.000033   SynColor Comment	term=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
    3              0.000026   SynColor Constant	term=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
    3              0.000024   SynColor Special	term=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
    3              0.000024   SynColor Identifier	term=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
    3              0.000023   SynColor Statement	term=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
    3              0.000022   SynColor PreProc	term=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
    3              0.000030   SynColor Type		term=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
    3              0.000022   SynColor Underlined	term=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
    3              0.000024   SynColor Ignore	term=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
    3              0.000003 endif
    3              0.000024 SynColor Error		term=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
    3              0.000023 SynColor Todo		term=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
                            
                            " Common groups that link to default highlighting.
                            " You can specify other highlighting easily.
    3              0.000012 SynLink String		Constant
    3              0.000011 SynLink Character	Constant
    3              0.000010 SynLink Number		Constant
    3              0.000010 SynLink Boolean		Constant
    3              0.000010 SynLink Float		Number
    3              0.000019 SynLink Function	Identifier
    3              0.000010 SynLink Conditional	Statement
    3              0.000011 SynLink Repeat		Statement
    3              0.000010 SynLink Label		Statement
    3              0.000009 SynLink Operator	Statement
    3              0.000010 SynLink Keyword		Statement
    3              0.000011 SynLink Exception	Statement
    3              0.000010 SynLink Include		PreProc
    3              0.000010 SynLink Define		PreProc
    3              0.000010 SynLink Macro		PreProc
    3              0.000017 SynLink PreCondit	PreProc
    3              0.000012 SynLink StorageClass	Type
    3              0.000010 SynLink Structure	Type
    3              0.000010 SynLink Typedef		Type
    3              0.000010 SynLink Tag		Special
    3              0.000011 SynLink SpecialChar	Special
    3              0.000009 SynLink Delimiter	Special
    3              0.000009 SynLink SpecialComment	Special
    3              0.000009 SynLink Debug		Special
                            
    3              0.000003 delcommand SynColor
    3              0.000006 delcommand SynLink

SCRIPT  /usr/share/vim/vim73/filetype.vim
Sourced 4 times
Total time:   0.050993
 Self time:   0.050993

count  total (s)   self (s)
                            " Vim support file to detect file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2012 Feb 03
                            
                            " Listen very carefully, I will say this only once
    4              0.000021 if exists("did_load_filetypes")
    1              0.000002   finish
                            endif
    3              0.000011 let did_load_filetypes = 1
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    3              0.000031 let s:cpo_save = &cpo
    3              0.000028 set cpo&vim
                            
    3              0.000005 augroup filetypedetect
                            
                            " Ignored extensions
    3              0.000012 if exists("*fnameescape")
    3              0.000145 au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.rpmsave,?\+.rpmnew
                            	\ exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
    3              0.000047 au BufNewFile,BufRead *~
                            	\ let s:name = expand("<afile>") |
                            	\ let s:short = substitute(s:name, '\~$', '', '') |
                            	\ if s:name != s:short && s:short != "" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(s:short) |
                            	\ endif |
                            	\ unlet! s:name s:short
    3              0.000037 au BufNewFile,BufRead ?\+.in
                            	\ if expand("<afile>:t") != "configure.in" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) |
                            	\ endif
    3              0.000006 elseif &verbose > 0
                              echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
                            endif
                            
                            " Pattern used to match file names which should not be inspected.
                            " Currently finds compressed files.
    3              0.000011 if !exists("g:ft_ignore_pat")
    1              0.000003   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
    1              0.000001 endif
                            
                            " Function used for patterns that end in a star: don't set the filetype if the
                            " file name matches ft_ignore_pat.
    3              0.000012 func! s:StarSetf(ft)
                              if expand("<amatch>") !~ g:ft_ignore_pat
                                exe 'setf ' . a:ft
                              endif
                            endfunc
                            
                            " Abaqus or Trasys
    3              0.000021 au BufNewFile,BufRead *.inp			call s:Check_inp()
                            
    3              0.000006 func! s:Check_inp()
                              if getline(1) =~ '^\*'
                                setf abaqus
                              else
                                let n = 1
                                if line("$") > 500
                                  let nmax = 500
                                else
                                  let nmax = line("$")
                                endif
                                while n <= nmax
                                  if getline(n) =~? "^header surface data"
                            	setf trasys
                            	break
                                  endif
                                  let n = n + 1
                                endwhile
                              endif
                            endfunc
                            
                            " A-A-P recipe
    3              0.000019 au BufNewFile,BufRead *.aap			setf aap
                            
                            " A2ps printing utility
    3              0.000073 au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
                            
                            " ABAB/4
    3              0.000017 au BufNewFile,BufRead *.abap			setf abap
                            
                            " ABC music notation
    3              0.000015 au BufNewFile,BufRead *.abc			setf abc
                            
                            " ABEL
    3              0.000017 au BufNewFile,BufRead *.abl			setf abel
                            
                            " AceDB
    3              0.000016 au BufNewFile,BufRead *.wrm			setf acedb
                            
                            " Ada (83, 9X, 95)
    3              0.000037 au BufNewFile,BufRead *.adb,*.ads,*.ada		setf ada
    3              0.000020 if has("vms")
                              au BufNewFile,BufRead *.gpr,*.ada_m,*.adc	setf ada
                            else
    3              0.000019   au BufNewFile,BufRead *.gpr			setf ada
    3              0.000003 endif
                            
                            " AHDL
    3              0.000017 au BufNewFile,BufRead *.tdf			setf ahdl
                            
                            " AMPL
    3              0.000017 au BufNewFile,BufRead *.run			setf ampl
                            
                            " Ant
    3              0.000022 au BufNewFile,BufRead build.xml			setf ant
                            
                            " Apache style config file
    3              0.000024 au BufNewFile,BufRead proftpd.conf*		call s:StarSetf('apachestyle')
                            
                            " Apache config file
    3              0.000045 au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf		setf apache
                            
                            " XA65 MOS6510 cross assembler
    3              0.000019 au BufNewFile,BufRead *.a65			setf a65
                            
                            " Applescript
    3              0.000018 au BufNewFile,BufRead *.scpt			setf applescript
                            
                            " Applix ELF
    3              0.000023 au BufNewFile,BufRead *.am
                            	\ if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
                            
                            " ALSA configuration
    3              0.000065 au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
                            
                            " Arc Macro Language
    3              0.000019 au BufNewFile,BufRead *.aml			setf aml
                            
                            " Arch Inventory file
    3              0.000045 au BufNewFile,BufRead .arch-inventory,=tagging-method	setf arch
                            
                            " ART*Enterprise (formerly ART-IM)
    3              0.000018 au BufNewFile,BufRead *.art			setf art
                            
                            " ASN.1
    3              0.000032 au BufNewFile,BufRead *.asn,*.asn1		setf asn
                            
                            " Active Server Pages (with Visual Basic Script)
    3              0.000034 au BufNewFile,BufRead *.asa
                            	\ if exists("g:filetype_asa") |
                            	\   exe "setf " . g:filetype_asa |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Active Server Pages (with Perl or Visual Basic Script)
    3              0.000043 au BufNewFile,BufRead *.asp
                            	\ if exists("g:filetype_asp") |
                            	\   exe "setf " . g:filetype_asp |
                            	\ elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |
                            	\   setf aspperl |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Grub (must be before catch *.lst)
    3              0.000066 au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
                            
                            " Assembly (all kinds)
                            " *.lst is not pure assembly, it has two extra columns (address, byte codes)
    3              0.000073 au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst	call s:FTasm()
                            
                            " This function checks for the kind of assembly that is wanted by the user, or
                            " can be detected from the first five lines of the file.
    3              0.000008 func! s:FTasm()
                              " make sure b:asmsyntax exists
                              if !exists("b:asmsyntax")
                                let b:asmsyntax = ""
                              endif
                            
                              if b:asmsyntax == ""
                                call s:FTasmsyntax()
                              endif
                            
                              " if b:asmsyntax still isn't set, default to asmsyntax or GNU
                              if b:asmsyntax == ""
                                if exists("g:asmsyntax")
                                  let b:asmsyntax = g:asmsyntax
                                else
                                  let b:asmsyntax = "asm"
                                endif
                              endif
                            
                              exe "setf " . fnameescape(b:asmsyntax)
                            endfunc
                            
    3              0.000006 func! s:FTasmsyntax()
                              " see if file contains any asmsyntax=foo overrides. If so, change
                              " b:asmsyntax appropriately
                              let head = " ".getline(1)." ".getline(2)." ".getline(3)." ".getline(4).
                            	\" ".getline(5)." "
                              let match = matchstr(head, '\sasmsyntax=\zs[a-zA-Z0-9]\+\ze\s')
                              if match != ''
                                let b:asmsyntax = match
                              elseif ((head =~? '\.title') || (head =~? '\.ident') || (head =~? '\.macro') || (head =~? '\.subtitle') || (head =~? '\.library'))
                                let b:asmsyntax = "vmasm"
                              endif
                            endfunc
                            
                            " Macro (VAX)
    3              0.000023 au BufNewFile,BufRead *.mar			setf vmasm
                            
                            " Atlas
    3              0.000030 au BufNewFile,BufRead *.atl,*.as		setf atlas
                            
                            " Autoit v3
    3              0.000019 au BufNewFile,BufRead *.au3			setf autoit
                            
                            " Autohotkey
    3              0.000020 au BufNewFile,BufRead *.ahk			setf autohotkey
                            
                            " Automake
    3              0.000046 au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am	setf automake
                            
                            " Autotest .at files are actually m4
    3              0.000018 au BufNewFile,BufRead *.at			setf m4
                            
                            " Avenue
    3              0.000021 au BufNewFile,BufRead *.ave			setf ave
                            
                            " Awk
    3              0.000018 au BufNewFile,BufRead *.awk			setf awk
                            
                            " B
    3              0.000044 au BufNewFile,BufRead *.mch,*.ref,*.imp		setf b
                            
                            " BASIC or Visual Basic
    3              0.000021 au BufNewFile,BufRead *.bas			call s:FTVB("basic")
                            
                            " Check if one of the first five lines contains "VB_Name".  In that case it is
                            " probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.
    3              0.000009 func! s:FTVB(alt)
                              if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'VB_Name\|Begin VB\.\(Form\|MDIForm\|UserControl\)'
                                setf vb
                              else
                                exe "setf " . a:alt
                              endif
                            endfunc
                            
                            " Visual Basic Script (close to Visual Basic)
    3              0.000052 au BufNewFile,BufRead *.vbs,*.dsm,*.ctl		setf vb
                            
                            " IBasic file (similar to QBasic)
    3              0.000034 au BufNewFile,BufRead *.iba,*.ibi		setf ibasic
                            
                            " FreeBasic file (similar to QBasic)
    3              0.000028 au BufNewFile,BufRead *.fb,*.bi			setf freebasic
                            
                            " Batch file for MSDOS.
    3              0.000035 au BufNewFile,BufRead *.bat,*.sys		setf dosbatch
                            " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
    3              0.000028 au BufNewFile,BufRead *.cmd
                            	\ if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
                            
                            " Batch file for 4DOS
    3              0.000021 au BufNewFile,BufRead *.btm			call s:FTbtm()
    3              0.000007 func! s:FTbtm()
                              if exists("g:dosbatch_syntax_for_btm") && g:dosbatch_syntax_for_btm
                                setf dosbatch
                              else
                                setf btm
                              endif
                            endfunc
                            
                            " BC calculator
    3              0.000020 au BufNewFile,BufRead *.bc			setf bc
                            
                            " BDF font
    3              0.000021 au BufNewFile,BufRead *.bdf			setf bdf
                            
                            " BibTeX bibliography database file
    3              0.000020 au BufNewFile,BufRead *.bib			setf bib
                            
                            " BibTeX Bibliography Style
    3              0.000021 au BufNewFile,BufRead *.bst			setf bst
                            
                            " BIND configuration
    3              0.000040 au BufNewFile,BufRead named.conf,rndc.conf	setf named
                            
                            " BIND zone
    3              0.000025 au BufNewFile,BufRead named.root		setf bindzone
    3              0.000022 au BufNewFile,BufRead *.db			call s:BindzoneCheck('')
                            
    3              0.000009 func! s:BindzoneCheck(default)
                              if getline(1).getline(2).getline(3).getline(4) =~ '^; <<>> DiG [0-9.]\+ <<>>\|BIND.*named\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                setf bindzone
                              elseif a:default != ''
                                exe 'setf ' . a:default
                              endif
                            endfunc
                            
                            " Blank
    3              0.000022 au BufNewFile,BufRead *.bl			setf blank
                            
                            " Blkid cache file
    3              0.000048 au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
                            
                            " C or lpc
    3              0.000020 au BufNewFile,BufRead *.c			call s:FTlpc()
                            
    3              0.000007 func! s:FTlpc()
                              if exists("g:lpc_syntax_for_c")
                                let lnum = 1
                                while lnum <= 12
                                  if getline(lnum) =~# '^\(//\|inherit\|private\|protected\|nosave\|string\|object\|mapping\|mixed\)'
                            	setf lpc
                            	return
                                  endif
                                  let lnum = lnum + 1
                                endwhile
                              endif
                              setf c
                            endfunc
                            
                            " Calendar
    3              0.000027 au BufNewFile,BufRead calendar			setf calendar
                            
                            " C#
    3              0.000022 au BufNewFile,BufRead *.cs			setf cs
                            
                            " Cabal
    3              0.000023 au BufNewFile,BufRead *.cabal			setf cabal
                            
                            " Cdrdao TOC
    3              0.000022 au BufNewFile,BufRead *.toc			setf cdrtoc
                            
                            " Cdrdao config
    3              0.000086 au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao	setf cdrdaoconf
                            
                            " Cfengine
    3              0.000028 au BufNewFile,BufRead cfengine.conf		setf cfengine
                            
                            " ChaiScript
    3              0.000021 au BufRead,BufNewFile *.chai			setf chaiscript
                            
                            " Comshare Dimension Definition Language
    3              0.000022 au BufNewFile,BufRead *.cdl			setf cdl
                            
                            " Conary Recipe
    3              0.000023 au BufNewFile,BufRead *.recipe			setf conaryrecipe
                            
                            " Controllable Regex Mutilator
    3              0.000024 au BufNewFile,BufRead *.crm			setf crm
                            
                            " Cyn++
    3              0.000023 au BufNewFile,BufRead *.cyn			setf cynpp
                            
                            " Cynlib
                            " .cc and .cpp files can be C++ or Cynlib.
    3              0.000027 au BufNewFile,BufRead *.cc
                            	\ if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
    3              0.000029 au BufNewFile,BufRead *.cpp
                            	\ if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
                            
                            " C++
    3              0.000140 au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
    3              0.000011 if has("fname_case")
    3              0.000037   au BufNewFile,BufRead *.C,*.H setf cpp
    3              0.000003 endif
                            
                            " .h files can be C, Ch C++, ObjC or ObjC++.
                            " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
                            " detected automatically.
    3              0.000022 au BufNewFile,BufRead *.h			call s:FTheader()
                            
    3              0.000009 func! s:FTheader()
                              if match(getline(1, min([line("$"), 200])), '^@\(interface\|end\|class\)') > -1
                                setf objc
                              elseif exists("g:c_syntax_for_h")
                                setf c
                              elseif exists("g:ch_syntax_for_h")
                                setf ch
                              else
                                setf cpp
                              endif
                            endfunc
                            
                            " Ch (CHscript)
    3              0.000028 au BufNewFile,BufRead *.chf			setf ch
                            
                            " TLH files are C++ headers generated by Visual C++'s #import from typelibs
    3              0.000026 au BufNewFile,BufRead *.tlh			setf cpp
                            
                            " Cascading Style Sheets
    3              0.000024 au BufNewFile,BufRead *.css			setf css
                            
                            " Century Term Command Scripts (*.cmd too)
    3              0.000025 au BufNewFile,BufRead *.con			setf cterm
                            
                            " Changelog
    3              0.000091 au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch
                            					\	setf debchangelog
                            
    3              0.000050 au BufNewFile,BufRead [cC]hange[lL]og
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| else
                            	\|   setf changelog
                            	\| endif
                            
    3              0.000036 au BufNewFile,BufRead NEWS
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| endif
                            
                            " CHILL
    3              0.000028 au BufNewFile,BufRead *..ch			setf chill
                            
                            " Changes for WEB and CWEB or CHILL
    3              0.000024 au BufNewFile,BufRead *.ch			call s:FTchange()
                            
                            " This function checks if one of the first ten lines start with a '@'.  In
                            " that case it is probably a change file.
                            " If the first line starts with # or ! it's probably a ch file.
                            " If a line has "main", "include", "//" ir "/*" it's probably ch.
                            " Otherwise CHILL is assumed.
    3              0.000007 func! s:FTchange()
                              let lnum = 1
                              while lnum <= 10
                                if getline(lnum)[0] == '@'
                                  setf change
                                  return
                                endif
                                if lnum == 1 && (getline(1)[0] == '#' || getline(1)[0] == '!')
                                  setf ch
                                  return
                                endif
                                if getline(lnum) =~ "MODULE"
                                  setf chill
                                  return
                                endif
                                if getline(lnum) =~ 'main\s*(\|#\s*include\|//'
                                  setf ch
                                  return
                                endif
                                let lnum = lnum + 1
                              endwhile
                              setf chill
                            endfunc
                            
                            " ChordPro
    3              0.000094 au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro	setf chordpro
                            
                            " Clean
    3              0.000043 au BufNewFile,BufRead *.dcl,*.icl		setf clean
                            
                            " Clever
    3              0.000027 au BufNewFile,BufRead *.eni			setf cl
                            
                            " Clever or dtd
    3              0.000026 au BufNewFile,BufRead *.ent			call s:FTent()
                            
    3              0.000007 func! s:FTent()
                              " This function checks for valid cl syntax in the first five lines.
                              " Look for either an opening comment, '#', or a block start, '{".
                              " If not found, assume SGML.
                              let lnum = 1
                              while lnum < 6
                                let line = getline(lnum)
                                if line =~ '^\s*[#{]'
                                  setf cl
                                  return
                                elseif line !~ '^\s*$'
                                  " Not a blank line, not a comment, and not a block start,
                                  " so doesn't look like valid cl code.
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf dtd
                            endfunc
                            
                            " Clipper (or FoxPro; could also be eviews)
    3              0.000043 au BufNewFile,BufRead *.prg
                            	\ if exists("g:filetype_prg") |
                            	\   exe "setf " . g:filetype_prg |
                            	\ else |
                            	\   setf clipper |
                            	\ endif
                            
                            " Cmake
    3              0.000065 au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in		setf cmake
                            
                            " Cmusrc
    3              0.000068 au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
    3              0.000041 au BufNewFile,BufRead */cmus/{rc,*.theme}			setf cmusrc
                            
                            " Cobol
    3              0.000065 au BufNewFile,BufRead *.cbl,*.cob,*.lib	setf cobol
                            "   cobol or zope form controller python script? (heuristic)
    3              0.000041 au BufNewFile,BufRead *.cpy
                            	\ if getline(1) =~ '^##' |
                            	\   setf python |
                            	\ else |
                            	\   setf cobol |
                            	\ endif
                            
                            " Coco/R
    3              0.000029 au BufNewFile,BufRead *.atg			setf coco
                            
                            " Cold Fusion
    3              0.000064 au BufNewFile,BufRead *.cfm,*.cfi,*.cfc		setf cf
                            
                            " Configure scripts
    3              0.000052 au BufNewFile,BufRead configure.in,configure.ac setf config
                            
                            " CUDA  Cumpute Unified Device Architecture
    3              0.000024 au BufNewFile,BufRead *.cu			setf cuda
                            
                            " WildPackets EtherPeek Decoder
    3              0.000027 au BufNewFile,BufRead *.dcd			setf dcd
                            
                            " Enlightenment configuration files
    3              0.000036 au BufNewFile,BufRead *enlightenment/*.cfg	setf c
                            
                            " Eterm
    3              0.000033 au BufNewFile,BufRead *Eterm/*.cfg		setf eterm
                            
                            " Lynx config files
    3              0.000028 au BufNewFile,BufRead lynx.cfg			setf lynx
                            
                            " Quake
    3              0.000061 au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg	setf quake
    3              0.000039 au BufNewFile,BufRead *quake[1-3]/*.cfg			setf quake
                            
                            " Quake C
    3              0.000024 au BufNewFile,BufRead *.qc			setf c
                            
                            " Configure files
    3              0.000029 au BufNewFile,BufRead *.cfg			setf cfg
                            
                            " Cucumber
    3              0.000027 au BufNewFile,BufRead *.feature			setf cucumber
                            
                            " Communicating Sequential Processes
    3              0.000047 au BufNewFile,BufRead *.csp,*.fdr		setf csp
                            
                            " CUPL logic description and simulation
    3              0.000029 au BufNewFile,BufRead *.pld			setf cupl
    3              0.000026 au BufNewFile,BufRead *.si			setf cuplsim
                            
                            " Debian Control
    3              0.000033 au BufNewFile,BufRead */debian/control		setf debcontrol
    3              0.000036 au BufNewFile,BufRead control
                            	\  if getline(1) =~ '^Source:'
                            	\|   setf debcontrol
                            	\| endif
                            
                            " Debian Sources.list
    3              0.000037 au BufNewFile,BufRead */etc/apt/sources.list		setf debsources
    3              0.000045 au BufNewFile,BufRead */etc/apt/sources.list.d/*.list	setf debsources
                            
                            " Deny hosts
    3              0.000034 au BufNewFile,BufRead denyhosts.conf		setf denyhosts
                            
                            " dnsmasq(8) configuration files
    3              0.000032 au BufNewFile,BufRead */etc/dnsmasq.conf	setf dnsmasq
                            
                            " ROCKLinux package description
    3              0.000025 au BufNewFile,BufRead *.desc			setf desc
                            
                            " the D language or dtrace
    3              0.000024 au BufNewFile,BufRead *.d			call s:DtraceCheck()
                            
    3              0.000010 func! s:DtraceCheck()
                              let lines = getline(1, min([line("$"), 100]))
                              if match(lines, '^module\>\|^import\>') > -1
                                " D files often start with a module and/or import statement.
                                setf d
                              elseif match(lines, '^#!\S\+dtrace\|#pragma\s\+D\s\+option\|:\S\{-}:\S\{-}:') > -1
                                setf dtrace
                              else
                                setf d
                              endif
                            endfunc
                            
                            " Desktop files
    3              0.000052 au BufNewFile,BufRead *.desktop,.directory	setf desktop
                            
                            " Dict config
    3              0.000048 au BufNewFile,BufRead dict.conf,.dictrc		setf dictconf
                            
                            " Dictd config
    3              0.000031 au BufNewFile,BufRead dictd.conf		setf dictdconf
                            
                            " Diff files
    3              0.000064 au BufNewFile,BufRead *.diff,*.rej,*.patch	setf diff
                            
                            " Dircolors
    3              0.000074 au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS	setf dircolors
                            
                            " Diva (with Skill) or InstallShield
    3              0.000051 au BufNewFile,BufRead *.rul
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |
                            	\   setf ishd |
                            	\ else |
                            	\   setf diva |
                            	\ endif
                            
                            " DCL (Digital Command Language - vms) or DNS zone file
    3              0.000032 au BufNewFile,BufRead *.com			call s:BindzoneCheck('dcl')
                            
                            " DOT
    3              0.000031 au BufNewFile,BufRead *.dot			setf dot
                            
                            " Dylan - lid files
    3              0.000031 au BufNewFile,BufRead *.lid			setf dylanlid
                            
                            " Dylan - intr files (melange)
    3              0.000027 au BufNewFile,BufRead *.intr			setf dylanintr
                            
                            " Dylan
    3              0.000027 au BufNewFile,BufRead *.dylan			setf dylan
                            
                            " Microsoft Module Definition
    3              0.000030 au BufNewFile,BufRead *.def			setf def
                            
                            " Dracula
    3              0.000082 au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe	setf dracula
                            
                            " Datascript
    3              0.000026 au BufNewFile,BufRead *.ds			setf datascript
                            
                            " dsl
    3              0.000030 au BufNewFile,BufRead *.dsl			setf dsl
                            
                            " DTD (Document Type Definition for XML)
    3              0.000032 au BufNewFile,BufRead *.dtd			setf dtd
                            
                            " EDIF (*.edf,*.edif,*.edn,*.edo)
    3              0.000045 au BufNewFile,BufRead *.ed\(f\|if\|n\|o\)	setf edif
                            
                            " Embedix Component Description
    3              0.000033 au BufNewFile,BufRead *.ecd			setf ecd
                            
                            " Eiffel or Specman
    3              0.000039 au BufNewFile,BufRead *.e,*.E			call s:FTe()
                            
                            " Elinks configuration
    3              0.000062 au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf	setf elinks
                            
    3              0.000006 func! s:FTe()
                              let n = 1
                              while n < 100 && n < line("$")
                                if getline(n) =~ "^\\s*\\(<'\\|'>\\)\\s*$"
                                  setf specman
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf eiffel
                            endfunc
                            
                            " ERicsson LANGuage; Yaws is erlang too
    3              0.000079 au BufNewFile,BufRead *.erl,*.hrl,*.yaws	setf erlang
                            
                            " Elm Filter Rules file
    3              0.000035 au BufNewFile,BufRead filter-rules		setf elmfilt
                            
                            " ESMTP rc file
    3              0.000029 au BufNewFile,BufRead *esmtprc			setf esmtprc
                            
                            " ESQL-C
    3              0.000043 au BufNewFile,BufRead *.ec,*.EC			setf esqlc
                            
                            " Esterel
    3              0.000028 au BufNewFile,BufRead *.strl			setf esterel
                            
                            " Essbase script
    3              0.000031 au BufNewFile,BufRead *.csc			setf csc
                            
                            " Exim
    3              0.000032 au BufNewFile,BufRead exim.conf			setf exim
                            
                            " Expect
    3              0.000033 au BufNewFile,BufRead *.exp			setf expect
                            
                            " Exports
    3              0.000031 au BufNewFile,BufRead exports			setf exports
                            
                            " Falcon
    3              0.000032 au BufNewFile,BufRead *.fal			setf falcon
                            
                            " Fantom
    3              0.000055 au BufNewFile,BufRead *.fan,*.fwt		setf fan
                            
                            " Factor
    3              0.000028 au BufNewFile,BufRead *.factor			setf factor
                            
                            " Fetchmail RC file
    3              0.000035 au BufNewFile,BufRead .fetchmailrc		setf fetchmail
                            
                            " FlexWiki - disabled, because it has side effects when a .wiki file
                            " is not actually FlexWiki
                            "au BufNewFile,BufRead *.wiki			setf flexwiki
                            
                            " Focus Executable
    3              0.000056 au BufNewFile,BufRead *.fex,*.focexec		setf focexec
                            
                            " Focus Master file (but not for auto.master)
    3              0.000033 au BufNewFile,BufRead auto.master		setf conf
    3              0.000055 au BufNewFile,BufRead *.mas,*.master		setf master
                            
                            " Forth
    3              0.000046 au BufNewFile,BufRead *.fs,*.ft			setf forth
                            
                            " Reva Forth
    3              0.000034 au BufNewFile,BufRead *.frt			setf reva
                            
                            " Fortran
    3              0.000015 if has("fname_case")
    3              0.000241   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08	 setf fortran
    3              0.000004 endif
    3              0.000263 au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
                            
                            " Framescript
    3              0.000036 au BufNewFile,BufRead *.fsl			setf framescript
                            
                            " FStab
    3              0.000060 au BufNewFile,BufRead fstab,mtab		setf fstab
                            
                            " GDB command files
    3              0.000032 au BufNewFile,BufRead .gdbinit			setf gdb
                            
                            " GDMO
    3              0.000051 au BufNewFile,BufRead *.mo,*.gdmo		setf gdmo
                            
                            " Gedcom
    3              0.000063 au BufNewFile,BufRead *.ged,lltxxxxx.txt	setf gedcom
                            
                            " Git
    3              0.000039 au BufNewFile,BufRead *.git/COMMIT_EDITMSG setf gitcommit
    3              0.000087 au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig
    3              0.000039 au BufNewFile,BufRead git-rebase-todo      setf gitrebase
    3              0.000051 au BufNewFile,BufRead .msg.[0-9]*
                                  \ if getline(1) =~ '^From.*# This line is ignored.$' |
                                  \   setf gitsendemail |
                                  \ endif
    3              0.000041 au BufNewFile,BufRead *.git/**
                                  \ if getline(1) =~ '^\x\{40\}\>\|^ref: ' |
                                  \   setf git |
                                  \ endif
                            
                            " Gkrellmrc
    3              0.000079 au BufNewFile,BufRead gkrellmrc,gkrellmrc_?	setf gkrellmrc
                            
                            " GP scripts (2.0 and onward)
    3              0.000062 au BufNewFile,BufRead *.gp,.gprc		setf gp
                            
                            " GPG
    3              0.000036 au BufNewFile,BufRead */.gnupg/options		setf gpg
    3              0.000037 au BufNewFile,BufRead */.gnupg/gpg.conf		setf gpg
    3              0.000047 au BufNewFile,BufRead */usr/**/gnupg/options.skel setf gpg
                            
                            " gnash(1) configuration files
    3              0.000117 au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
                            
                            " Gitolite
    3              0.000037 au BufNewFile,BufRead gitolite.conf		setf gitolite
    3              0.000042 au BufNewFile,BufRead */gitolite-admin/conf/*	call s:StarSetf('gitolite')
    3              0.000079 au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc 	setf perl
                            
                            " Gnuplot scripts
    3              0.000038 au BufNewFile,BufRead *.gpi			setf gnuplot
                            
                            " GrADS scripts
    3              0.000030 au BufNewFile,BufRead *.gs			setf grads
                            
                            " Gretl
    3              0.000031 au BufNewFile,BufRead *.gretl			setf gretl
                            
                            " Groovy
    3              0.000032 au BufNewFile,BufRead *.groovy			setf groovy
                            
                            " GNU Server Pages
    3              0.000036 au BufNewFile,BufRead *.gsp			setf gsp
                            
                            " Group file
    3              0.000248 au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
                            
                            " GTK RC
    3              0.000068 au BufNewFile,BufRead .gtkrc,gtkrc		setf gtkrc
                            
                            " Haml
    3              0.000032 au BufNewFile,BufRead *.haml			setf haml
                            
                            " Hamster Classic | Playground files
    3              0.000068 au BufNewFile,BufRead *.hsc,*.hsm		setf hamster
                            
                            " Haskell
    3              0.000063 au BufNewFile,BufRead *.hs,*.hs-boot		setf haskell
    3              0.000041 au BufNewFile,BufRead *.lhs			setf lhaskell
    3              0.000038 au BufNewFile,BufRead *.chs			setf chaskell
                            
                            " Haste
    3              0.000032 au BufNewFile,BufRead *.ht			setf haste
    3              0.000033 au BufNewFile,BufRead *.htpp			setf hastepreproc
                            
                            " Hercules
    3              0.000138 au BufNewFile,BufRead *.vc,*.ev,*.rs,*.sum,*.errsum	setf hercules
                            
                            " HEX (Intel)
    3              0.000071 au BufNewFile,BufRead *.hex,*.h32		setf hex
                            
                            " Tilde (must be before HTML)
    3              0.000033 au BufNewFile,BufRead *.t.html			setf tilde
                            
                            " HTML (.shtml and .stm for server side)
    3              0.000125 au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call s:FThtml()
                            
                            " Distinguish between HTML, XHTML and Django
    3              0.000010 func! s:FThtml()
                              let n = 1
                              while n < 10 && n < line("$")
                                if getline(n) =~ '\<DTD\s\+XHTML\s'
                                  setf xhtml
                                  return
                                endif
                                if getline(n) =~ '{%\s*\(extends\|block\)\>'
                                  setf htmldjango
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf html
                            endfunc
                            
                            " HTML with Ruby - eRuby
    3              0.000068 au BufNewFile,BufRead *.erb,*.rhtml		setf eruby
                            
                            " HTML with M4
    3              0.000036 au BufNewFile,BufRead *.html.m4			setf htmlm4
                            
                            " HTML Cheetah template
    3              0.000035 au BufNewFile,BufRead *.tmpl			setf htmlcheetah
                            
                            " Host config
    3              0.000039 au BufNewFile,BufRead */etc/host.conf		setf hostconf
                            
                            " Hosts access
    3              0.000071 au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
                            
                            " Hyper Builder
    3              0.000033 au BufNewFile,BufRead *.hb			setf hb
                            
                            " Icon
    3              0.000040 au BufNewFile,BufRead *.icn			setf icon
                            
                            " IDL (Interface Description Language)
    3              0.000039 au BufNewFile,BufRead *.idl			call s:FTidl()
                            
                            " Distinguish between standard IDL and MS-IDL
    3              0.000007 func! s:FTidl()
                              let n = 1
                              while n < 50 && n < line("$")
                                if getline(n) =~ '^\s*import\s\+"\(unknwn\|objidl\)\.idl"'
                                  setf msidl
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf idl
                            endfunc
                            
                            " Microsoft IDL (Interface Description Language)  Also *.idl
                            " MOF = WMI (Windows Management Instrumentation) Managed Object Format
    3              0.000075 au BufNewFile,BufRead *.odl,*.mof		setf msidl
                            
                            " Icewm menu
    3              0.000038 au BufNewFile,BufRead */.icewm/menu		setf icemenu
                            
                            " Indent profile (must come before IDL *.pro!)
    3              0.000040 au BufNewFile,BufRead .indent.pro		setf indent
    3              0.000039 au BufNewFile,BufRead indent.pro		call s:ProtoCheck('indent')
                            
                            " IDL (Interactive Data Language)
    3              0.000042 au BufNewFile,BufRead *.pro			call s:ProtoCheck('idlang')
                            
                            " Distinguish between "default" and Cproto prototype file. */
    3              0.000009 func! s:ProtoCheck(default)
                              " Cproto files have a comment in the first line and a function prototype in
                              " the second line, it always ends in ";".  Indent files may also have
                              " comments, thus we can't match comments to see the difference.
                              " IDL files can have a single ';' in the second line, require at least one
                              " chacter before the ';'.
                              if getline(2) =~ '.;$'
                                setf cpp
                              else
                                exe 'setf ' . a:default
                              endif
                            endfunc
                            
                            
                            " Indent RC
    3              0.000040 au BufNewFile,BufRead indentrc			setf indent
                            
                            " Inform
    3              0.000077 au BufNewFile,BufRead *.inf,*.INF		setf inform
                            
                            " Initng
    3              0.000077 au BufNewFile,BufRead */etc/initng/**/*.i,*.ii	setf initng
                            
                            " Ipfilter
    3              0.000099 au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules	setf ipfilter
                            
                            " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
    3              0.000104 au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl	setf fgl
                            
                            " .INI file for MSDOS
    3              0.000041 au BufNewFile,BufRead *.ini			setf dosini
                            
                            " SysV Inittab
    3              0.000037 au BufNewFile,BufRead inittab			setf inittab
                            
                            " Inno Setup
    3              0.000079 au BufNewFile,BufRead *.iss			setf iss
                            
                            " JAL
    3              0.000076 au BufNewFile,BufRead *.jal,*.JAL		setf jal
                            
                            " Jam
    3              0.000077 au BufNewFile,BufRead *.jpl,*.jpr		setf jam
                            
                            " Java
    3              0.000070 au BufNewFile,BufRead *.java,*.jav		setf java
                            
                            " JavaCC
    3              0.000070 au BufNewFile,BufRead *.jj,*.jjt		setf javacc
                            
                            " JavaScript, ECMAScript
    3              0.000159 au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx,*.json   setf javascript
                            
                            " Java Server Pages
    3              0.000043 au BufNewFile,BufRead *.jsp			setf jsp
                            
                            " Java Properties resource file (note: doesn't catch font.properties.pl)
    3              0.000116 au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??	setf jproperties
    3              0.000052 au BufNewFile,BufRead *.properties_??_??_*	call s:StarSetf('jproperties')
                            
                            " Jess
    3              0.000045 au BufNewFile,BufRead *.clp			setf jess
                            
                            " Jgraph
    3              0.000043 au BufNewFile,BufRead *.jgr			setf jgraph
                            
                            " Jovial
    3              0.000110 au BufNewFile,BufRead *.jov,*.j73,*.jovial	setf jovial
                            
                            " Kixtart
    3              0.000044 au BufNewFile,BufRead *.kix			setf kix
                            
                            " Kimwitu[++]
    3              0.000033 au BufNewFile,BufRead *.k			setf kwt
                            
                            " KDE script
    3              0.000036 au BufNewFile,BufRead *.ks			setf kscript
                            
                            " Kconfig
    3              0.000072 au BufNewFile,BufRead Kconfig,Kconfig.debug	setf kconfig
                            
                            " Lace (ISE)
    3              0.000081 au BufNewFile,BufRead *.ace,*.ACE		setf lace
                            
                            " Latte
    3              0.000074 au BufNewFile,BufRead *.latte,*.lte		setf latte
                            
                            " Limits
    3              0.000123 au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf	setf limits
                            
                            " LambdaProlog (*.mod too, see Modsim)
    3              0.000045 au BufNewFile,BufRead *.sig			setf lprolog
                            
                            " LDAP LDIF
    3              0.000036 au BufNewFile,BufRead *.ldif			setf ldif
                            
                            " Ld loader
    3              0.000037 au BufNewFile,BufRead *.ld			setf ld
                            
                            " Lex
    3              0.000071 au BufNewFile,BufRead *.lex,*.l			setf lex
                            
                            " Libao
    3              0.000072 au BufNewFile,BufRead */etc/libao.conf,*/.libao	setf libao
                            
                            " Libsensors
    3              0.000082 au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf	setf sensors
                            
                            " LFTP
    3              0.000106 au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc	setf lftp
                            
                            " Lifelines (or Lex for C++!)
    3              0.000039 au BufNewFile,BufRead *.ll			setf lifelines
                            
                            " Lilo: Linux loader
    3              0.000042 au BufNewFile,BufRead lilo.conf			setf lilo
                            
                            " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
    3              0.000013 if has("fname_case")
    3              0.000265   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
    3              0.000004 else
                              au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
                            endif
                            
                            " SBCL implementation of Common Lisp
    3              0.000073 au BufNewFile,BufRead sbclrc,.sbclrc		setf lisp
                            
                            " Liquid
    3              0.000039 au BufNewFile,BufRead *.liquid			setf liquid
                            
                            " Lite
    3              0.000068 au BufNewFile,BufRead *.lite,*.lt		setf lite
                            
                            " LiteStep RC files
    3              0.000051 au BufNewFile,BufRead */LiteStep/*/*.rc		setf litestep
                            
                            " Login access
    3              0.000045 au BufNewFile,BufRead */etc/login.access	setf loginaccess
                            
                            " Login defs
    3              0.000044 au BufNewFile,BufRead */etc/login.defs		setf logindefs
                            
                            " Logtalk
    3              0.000045 au BufNewFile,BufRead *.lgt			setf logtalk
                            
                            " LOTOS
    3              0.000077 au BufNewFile,BufRead *.lot,*.lotos		setf lotos
                            
                            " Lout (also: *.lt)
    3              0.000077 au BufNewFile,BufRead *.lou,*.lout		setf lout
                            
                            " Lua
    3              0.000046 au BufNewFile,BufRead *.lua			setf lua
                            
                            " Linden Scripting Language (Second Life)
    3              0.000046 au BufNewFile,BufRead *.lsl			setf lsl
                            
                            " Lynx style file (or LotusScript!)
    3              0.000046 au BufNewFile,BufRead *.lss			setf lss
                            
                            " M4
    3              0.000047 au BufNewFile,BufRead *.m4
                            	\ if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
                            
                            " MaGic Point
    3              0.000046 au BufNewFile,BufRead *.mgp			setf mgp
                            
                            " Mail (for Elm, trn, mutt, muttng, rn, slrn)
    3              0.000498 au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
                            
                            " Mail aliases
    3              0.000082 au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases	setf mailaliases
                            
                            " Mailcap configuration file
    3              0.000078 au BufNewFile,BufRead .mailcap,mailcap		setf mailcap
                            
                            " Makefile
    3              0.000164 au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
                            
                            " MakeIndex
    3              0.000090 au BufNewFile,BufRead *.ist,*.mst		setf ist
                            
                            " Manpage
    3              0.000048 au BufNewFile,BufRead *.man			setf man
                            
                            " Man config
    3              0.000080 au BufNewFile,BufRead */etc/man.conf,man.config	setf manconf
                            
                            " Maple V
    3              0.000124 au BufNewFile,BufRead *.mv,*.mpl,*.mws		setf maple
                            
                            " Map (UMN mapserver config file)
    3              0.000050 au BufNewFile,BufRead *.map			setf map
                            
                            " Markdown
    3              0.000191 au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,README.md  setf markdown
                            
                            " Mason
    3              0.000082 au BufNewFile,BufRead *.mason,*.mhtml		setf mason
                            
                            " Matlab or Objective C
    3              0.000039 au BufNewFile,BufRead *.m			call s:FTm()
                            
    3              0.000009 func! s:FTm()
                              let n = 1
                              while n < 10
                                let line = getline(n)
                                if line =~ '^\s*\(#\s*\(include\|import\)\>\|/\*\|//\)'
                                  setf objc
                                  return
                                endif
                                if line =~ '^\s*%'
                                  setf matlab
                                  return
                                endif
                                if line =~ '^\s*(\*'
                                  setf mma
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              if exists("g:filetype_m")
                                exe "setf " . g:filetype_m
                              else
                                setf matlab
                              endif
                            endfunc
                            
                            " Mathematica notebook
    3              0.000047 au BufNewFile,BufRead *.nb			setf mma
                            
                            " Maya Extension Language
    3              0.000051 au BufNewFile,BufRead *.mel			setf mel
                            
                            " Mercurial config (looks like generic config file)
    3              0.000086 au BufNewFile,BufRead *.hgrc,*hgrc		setf cfg
                            
                            " Messages (logs mostly)
    3              0.000178 au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
                            
                            " Metafont
    3              0.000043 au BufNewFile,BufRead *.mf			setf mf
                            
                            " MetaPost
    3              0.000042 au BufNewFile,BufRead *.mp			setf mp
                            
                            " MGL
    3              0.000049 au BufNewFile,BufRead *.mgl			setf mgl
                            
                            " MMIX or VMS makefile
    3              0.000051 au BufNewFile,BufRead *.mms			call s:FTmms()
                            
                            " Symbian meta-makefile definition (MMP)
    3              0.000049 au BufNewFile,BufRead *.mmp			setf mmp
                            
    3              0.000008 func! s:FTmms()
                              let n = 1
                              while n < 10
                                let line = getline(n)
                                if line =~ '^\s*\(%\|//\)' || line =~ '^\*'
                                  setf mmix
                                  return
                                endif
                                if line =~ '^\s*#'
                                  setf make
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf mmix
                            endfunc
                            
                            
                            " Modsim III (or LambdaProlog)
    3              0.000067 au BufNewFile,BufRead *.mod
                            	\ if getline(1) =~ '\<module\>' |
                            	\   setf lprolog |
                            	\ else |
                            	\   setf modsim3 |
                            	\ endif
                            
                            " Modula 2
    3              0.000201 au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.md,*.mi setf modula2
                            
                            " Modula 3 (.m3, .i3, .mg, .ig)
    3              0.000047 au BufNewFile,BufRead *.[mi][3g]		setf modula3
                            
                            " Monk
    3              0.000175 au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc	setf monk
                            
                            " MOO
    3              0.000051 au BufNewFile,BufRead *.moo			setf moo
                            
                            " Modconf
    3              0.000126 au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
                            
                            " Mplayer config
    3              0.000090 au BufNewFile,BufRead mplayer.conf,*/.mplayer/config	setf mplayerconf
                            
                            " Moterola S record
    3              0.000142 au BufNewFile,BufRead *.s19,*.s28,*.s37		setf srec
                            
                            " Mrxvtrc
    3              0.000084 au BufNewFile,BufRead mrxvtrc,.mrxvtrc		setf mrxvtrc
                            
                            " Msql
    3              0.000042 au BufNewFile,BufRead *.msql			setf msql
                            
                            " Mysql
    3              0.000043 au BufNewFile,BufRead *.mysql			setf mysql
                            
                            " Mutt setup files (must be before catch *.rc)
    3              0.000054 au BufNewFile,BufRead */etc/Muttrc.d/*		call s:StarSetf('muttrc')
                            
                            " M$ Resource files
    3              0.000045 au BufNewFile,BufRead *.rc			setf rc
                            
                            " MuPAD source
    3              0.000044 au BufRead,BufNewFile *.mu			setf mupad
                            
                            " Mush
    3              0.000043 au BufNewFile,BufRead *.mush			setf mush
                            
                            " Mutt setup file (also for Muttng)
    3              0.000056 au BufNewFile,BufRead Mutt{ng,}rc		setf muttrc
                            
                            " Nano
    3              0.000086 au BufNewFile,BufRead */etc/nanorc,.nanorc	setf nanorc
                            
                            " Nastran input/DMAP
                            "au BufNewFile,BufRead *.dat			setf nastran
                            
                            " Natural
    3              0.000048 au BufNewFile,BufRead *.NS[ACGLMNPS]		setf natural
                            
                            " Netrc
    3              0.000045 au BufNewFile,BufRead .netrc			setf netrc
                            
                            " Ninja file
    3              0.000044 au BufNewFile,BufRead *.ninja			setf ninja
                            
                            " Novell netware batch files
    3              0.000051 au BufNewFile,BufRead *.ncf			setf ncf
                            
                            " Nroff/Troff (*.ms and *.t are checked below)
    3              0.000058 au BufNewFile,BufRead *.me
                            	\ if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |
                            	\   setf nroff |
                            	\ endif
    3              0.000200 au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom	setf nroff
    3              0.000049 au BufNewFile,BufRead *.[1-9]			call s:FTnroff()
                            
                            " This function checks if one of the first five lines start with a dot.  In
                            " that case it is probably an nroff file: 'filetype' is set and 1 is returned.
    3              0.000012 func! s:FTnroff()
                              if getline(1)[0] . getline(2)[0] . getline(3)[0] . getline(4)[0] . getline(5)[0] =~ '\.'
                                setf nroff
                                return 1
                              endif
                              return 0
                            endfunc
                            
                            " Nroff or Objective C++
    3              0.000048 au BufNewFile,BufRead *.mm			call s:FTmm()
                            
    3              0.000006 func! s:FTmm()
                              let n = 1
                              while n < 10
                                let line = getline(n)
                                if line =~ '^\s*\(#\s*\(include\|import\)\>\|/\*\)'
                                  setf objcpp
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf nroff
                            endfunc
                            
                            " Not Quite C
    3              0.000056 au BufNewFile,BufRead *.nqc			setf nqc
                            
                            " NSIS
    3              0.000055 au BufNewFile,BufRead *.nsi			setf nsis
                            
                            " OCAML
    3              0.000223 au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit	setf ocaml
                            
                            " Occam
    3              0.000056 au BufNewFile,BufRead *.occ			setf occam
                            
                            " Omnimark
    3              0.000101 au BufNewFile,BufRead *.xom,*.xin		setf omnimark
                            
                            " OpenROAD
    3              0.000045 au BufNewFile,BufRead *.or			setf openroad
                            
                            " OPL
    3              0.000051 au BufNewFile,BufRead *.[Oo][Pp][Ll]		setf opl
                            
                            " Oracle config file
    3              0.000056 au BufNewFile,BufRead *.ora			setf ora
                            
                            " Packet filter conf
    3              0.000048 au BufNewFile,BufRead pf.conf			setf pf
                            
                            " Pam conf
    3              0.000049 au BufNewFile,BufRead */etc/pam.conf		setf pamconf
                            
                            " PApp
    3              0.000119 au BufNewFile,BufRead *.papp,*.pxml,*.pxsl	setf papp
                            
                            " Password file
    3              0.000352 au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
                            
                            " Pascal (also *.p)
    3              0.000057 au BufNewFile,BufRead *.pas			setf pascal
                            
                            " Delphi project file
    3              0.000056 au BufNewFile,BufRead *.dpr			setf pascal
                            
                            " PDF
    3              0.000055 au BufNewFile,BufRead *.pdf			setf pdf
                            
                            " Perl
    3              0.000023 if has("fname_case")
    3              0.000094   au BufNewFile,BufRead *.pl,*.PL		call s:FTpl()
    3              0.000007 else
                              au BufNewFile,BufRead *.pl			call s:FTpl()
                            endif
    3              0.000092 au BufNewFile,BufRead *.plx,*.al		setf perl
    3              0.000096 au BufNewFile,BufRead *.p6,*.pm6		setf perl6
                            
    3              0.000012 func! s:FTpl()
                              if exists("g:filetype_pl")
                                exe "setf " . g:filetype_pl
                              else
                                " recognize Prolog by specific text in the first non-empty line
                                " require a blank after the '%' because Perl uses "%list" and "%translate"
                                let l = getline(nextnonblank(1))
                                if l =~ '\<prolog\>' || l =~ '^\s*\(%\+\(\s\|$\)\|/\*\)' || l =~ ':-'
                                  setf prolog
                                else
                                  setf perl
                                endif
                              endif
                            endfunc
                            
                            " Perl, XPM or XPM2
    3              0.000074 au BufNewFile,BufRead *.pm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ elseif getline(1) =~ "XPM" |
                            	\   setf xpm |
                            	\ else |
                            	\   setf perl |
                            	\ endif
                            
                            " Perl POD
    3              0.000059 au BufNewFile,BufRead *.pod			setf pod
                            
                            " Php, php3, php4, etc.
                            " Also Phtml (was used for PHP 2 in the past)
                            " Also .ctp for Cake template file
    3              0.000188 au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp	setf php
                            
                            " Pike
    3              0.000176 au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike
                            
                            " Pinfo config
    3              0.000088 au BufNewFile,BufRead */etc/pinforc,*/.pinforc	setf pinfo
                            
                            " Palm Resource compiler
    3              0.000058 au BufNewFile,BufRead *.rcp			setf pilrc
                            
                            " Pine config
    3              0.000173 au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex		setf pine
                            
                            " PL/M (also: *.inp)
    3              0.000160 au BufNewFile,BufRead *.plm,*.p36,*.pac		setf plm
                            
                            " PL/SQL
    3              0.000098 au BufNewFile,BufRead *.pls,*.plsql		setf plsql
                            
                            " PLP
    3              0.000059 au BufNewFile,BufRead *.plp			setf plp
                            
                            " PO and PO template (GNU gettext)
    3              0.000097 au BufNewFile,BufRead *.po,*.pot		setf po
                            
                            " Postfix main config
    3              0.000051 au BufNewFile,BufRead main.cf			setf pfmain
                            
                            " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
    3              0.000322 au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai	  setf postscr
                            
                            " PostScript Printer Description
    3              0.000062 au BufNewFile,BufRead *.ppd			setf ppd
                            
                            " Povray
    3              0.000057 au BufNewFile,BufRead *.pov			setf pov
                            
                            " Povray configuration
    3              0.000051 au BufNewFile,BufRead .povrayrc			setf povini
                            
                            " Povray, PHP or assembly
    3              0.000059 au BufNewFile,BufRead *.inc			call s:FTinc()
                            
    3              0.000011 func! s:FTinc()
                              if exists("g:filetype_inc")
                                exe "setf " . g:filetype_inc
                              else
                                let lines = getline(1).getline(2).getline(3)
                                if lines =~? "perlscript"
                                  setf aspperl
                                elseif lines =~ "<%"
                                  setf aspvbs
                                elseif lines =~ "<?"
                                  setf php
                                else
                                  call s:FTasmsyntax()
                                  if exists("b:asmsyntax")
                            	exe "setf " . fnameescape(b:asmsyntax)
                                  else
                            	setf pov
                                  endif
                                endif
                              endif
                            endfunc
                            
                            " Printcap and Termcap
    3              0.000077 au BufNewFile,BufRead *printcap
                            	\ let b:ptcap_type = "print" | setf ptcap
    3              0.000053 au BufNewFile,BufRead *termcap
                            	\ let b:ptcap_type = "term" | setf ptcap
                            
                            " PCCTS / ANTRL
                            "au BufNewFile,BufRead *.g			setf antrl
    3              0.000044 au BufNewFile,BufRead *.g			setf pccts
                            
                            " PPWizard
    3              0.000092 au BufNewFile,BufRead *.it,*.ih			setf ppwiz
                            
                            " Obj 3D file format
                            " TODO: is there a way to avoid MS-Windows Object files?
    3              0.000060 au BufNewFile,BufRead *.obj			setf obj
                            
                            " Oracle Pro*C/C++
    3              0.000050 au BufNewFile,BufRead *.pc			setf proc
                            
                            " Privoxy actions file
    3              0.000048 au BufNewFile,BufRead *.action			setf privoxy
                            
                            " Procmail
    3              0.000094 au BufNewFile,BufRead .procmail,.procmailrc	setf procmail
                            
                            " Progress or CWEB
    3              0.000045 au BufNewFile,BufRead *.w			call s:FTprogress_cweb()
                            
    3              0.000008 func! s:FTprogress_cweb()
                              if exists("g:filetype_w")
                                exe "setf " . g:filetype_w
                                return
                              endif
                              if getline(1) =~ '&ANALYZE' || getline(3) =~ '&GLOBAL-DEFINE'
                                setf progress
                              else
                                setf cweb
                              endif
                            endfunc
                            
                            " Progress or assembly
    3              0.000046 au BufNewFile,BufRead *.i			call s:FTprogress_asm()
                            
    3              0.000006 func! s:FTprogress_asm()
                              if exists("g:filetype_i")
                                exe "setf " . g:filetype_i
                                return
                              endif
                              " This function checks for an assembly comment the first ten lines.
                              " If not found, assume Progress.
                              let lnum = 1
                              while lnum <= 10 && lnum < line('$')
                                let line = getline(lnum)
                                if line =~ '^\s*;' || line =~ '^\*'
                                  call s:FTasm()
                                  return
                                elseif line !~ '^\s*$' || line =~ '^/\*'
                                  " Not an empty line: Doesn't look like valid assembly code.
                                  " Or it looks like a Progress /* comment
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf progress
                            endfunc
                            
                            " Progress or Pascal
    3              0.000048 au BufNewFile,BufRead *.p			call s:FTprogress_pascal()
                            
    3              0.000008 func! s:FTprogress_pascal()
                              if exists("g:filetype_p")
                                exe "setf " . g:filetype_p
                                return
                              endif
                              " This function checks for valid Pascal syntax in the first ten lines.
                              " Look for either an opening comment or a program start.
                              " If not found, assume Progress.
                              let lnum = 1
                              while lnum <= 10 && lnum < line('$')
                                let line = getline(lnum)
                                if line =~ '^\s*\(program\|unit\|procedure\|function\|const\|type\|var\)\>'
                            	\ || line =~ '^\s*{' || line =~ '^\s*(\*'
                                  setf pascal
                                  return
                                elseif line !~ '^\s*$' || line =~ '^/\*'
                                  " Not an empty line: Doesn't look like valid Pascal code.
                                  " Or it looks like a Progress /* comment
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf progress
                            endfunc
                            
                            
                            " Software Distributor Product Specification File (POSIX 1387.2-1995)
    3              0.000069 au BufNewFile,BufRead *.psf			setf psf
    3              0.000125 au BufNewFile,BufRead INDEX,INFO
                            	\ if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |
                            	\   setf psf |
                            	\ endif
                            
                            " Prolog
    3              0.000062 au BufNewFile,BufRead *.pdb			setf prolog
                            
                            " Promela
    3              0.000061 au BufNewFile,BufRead *.pml			setf promela
                            
                            " Protocols
    3              0.000052 au BufNewFile,BufRead */etc/protocols		setf protocols
                            
                            " Pyrex
    3              0.000119 au BufNewFile,BufRead *.pyx,*.pxd		setf pyrex
                            
                            " Python
    3              0.000105 au BufNewFile,BufRead *.py,*.pyw		setf python
                            
                            " Quixote (Python-based web framework)
    3              0.000060 au BufNewFile,BufRead *.ptl			setf python
                            
                            " Radiance
    3              0.000115 au BufNewFile,BufRead *.rad,*.mat		setf radiance
                            
                            " Ratpoison config/command files
    3              0.000098 au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc	setf ratpoison
                            
                            " RCS file
    3              0.000051 au BufNewFile,BufRead *\,v			setf rcs
                            
                            " Readline
    3              0.000096 au BufNewFile,BufRead .inputrc,inputrc		setf readline
                            
                            " Registry for MS-Windows
    3              0.000072 au BufNewFile,BufRead *.reg
                            	\ if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
                            
                            " Renderman Interface Bytestream
    3              0.000061 au BufNewFile,BufRead *.rib			setf rib
                            
                            " Rexx
    3              0.000258 au BufNewFile,BufRead *.rexx,*.rex,*.jrexx,*.rxj,*.orx	setf rexx
                            
                            " R (Splus)
    3              0.000017 if has("fname_case")
    3              0.000086   au BufNewFile,BufRead *.s,*.S			setf r
    3              0.000004 else
                              au BufNewFile,BufRead *.s			setf r
                            endif
                            
                            " R Help file
    3              0.000009 if has("fname_case")
    3              0.000099   au BufNewFile,BufRead *.rd,*.Rd		setf rhelp
    3              0.000004 else
                              au BufNewFile,BufRead *.rd			setf rhelp
                            endif
                            
                            " R noweb file
    3              0.000009 if has("fname_case")
    3              0.000233   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw		setf rnoweb
    3              0.000003 else
                              au BufNewFile,BufRead *.rnw,*.snw			setf rnoweb
                            endif
                            
                            " Rexx, Rebol or R
    3              0.000085 au BufNewFile,BufRead *.r,*.R			call s:FTr()
                            
    3              0.000009 func! s:FTr()
                              let max = line("$") > 50 ? 50 : line("$")
                            
                              for n in range(1, max)
                                " Rebol is easy to recognize, check for that first
                                if getline(n) =~? '\<REBOL\>'
                                  setf rebol
                                  return
                                endif
                              endfor
                            
                              for n in range(1, max)
                                " R has # comments
                                if getline(n) =~ '^\s*#'
                                  setf r
                                  return
                                endif
                                " Rexx has /* comments */
                                if getline(n) =~ '^\s*/\*'
                                  setf rexx
                                  return
                                endif
                              endfor
                            
                              " Nothing recognized, use user default or assume Rexx
                              if exists("g:filetype_r")
                                exe "setf " . g:filetype_r
                              else
                                " Rexx used to be the default, but R appears to be much more popular.
                                setf r
                              endif
                            endfunc
                            
                            " Remind
    3              0.000159 au BufNewFile,BufRead .reminders,*.remind,*.rem		setf remind
                            
                            " Resolv.conf
    3              0.000054 au BufNewFile,BufRead resolv.conf		setf resolv
                            
                            " Relax NG Compact
    3              0.000066 au BufNewFile,BufRead *.rnc			setf rnc
                            
                            " RPL/2
    3              0.000062 au BufNewFile,BufRead *.rpl			setf rpl
                            
                            " Robots.txt
    3              0.000052 au BufNewFile,BufRead robots.txt		setf robots
                            
                            " Rpcgen
    3              0.000046 au BufNewFile,BufRead *.x			setf rpcgen
                            
                            " reStructuredText Documentation Format
    3              0.000064 au BufNewFile,BufRead *.rst			setf rst
                            
                            " RTF
    3              0.000065 au BufNewFile,BufRead *.rtf			setf rtf
                            
                            " Interactive Ruby shell
    3              0.000113 au BufNewFile,BufRead .irbrc,irbrc		setf ruby
                            
                            " Ruby
    3              0.000109 au BufNewFile,BufRead *.rb,*.rbw		setf ruby
                            
                            " RubyGems
    3              0.000051 au BufNewFile,BufRead *.gemspec			setf ruby
                            
                            " Rackup
    3              0.000052 au BufNewFile,BufRead *.ru			setf ruby
                            
                            " Bundler
    3              0.000054 au BufNewFile,BufRead Gemfile			setf ruby
                            
                            " Ruby on Rails
    3              0.000154 au BufNewFile,BufRead *.builder,*.rxml,*.rjs	setf ruby
                            
                            " Rantfile and Rakefile is like Ruby
    3              0.000194 au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake	setf ruby
                            
                            " S-lang (or shader language, or SmallLisp)
    3              0.000054 au BufNewFile,BufRead *.sl			setf slang
                            
                            " Samba config
    3              0.000055 au BufNewFile,BufRead smb.conf			setf samba
                            
                            " SAS script
    3              0.000065 au BufNewFile,BufRead *.sas			setf sas
                            
                            " Sass
    3              0.000051 au BufNewFile,BufRead *.sass			setf sass
                            
                            " Sather
    3              0.000052 au BufNewFile,BufRead *.sa			setf sather
                            
                            " Scilab
    3              0.000128 au BufNewFile,BufRead *.sci,*.sce		setf scilab
                            
                            " SCSS
    3              0.000052 au BufNewFile,BufRead *.scss			setf scss
                            
                            " SD: Streaming Descriptors
    3              0.000053 au BufNewFile,BufRead *.sd			setf sd
                            
                            " SDL
    3              0.000112 au BufNewFile,BufRead *.sdl,*.pr		setf sdl
                            
                            " sed
    3              0.000065 au BufNewFile,BufRead *.sed			setf sed
                            
                            " Sieve (RFC 3028)
    3              0.000069 au BufNewFile,BufRead *.siv			setf sieve
                            
                            " Sendmail
    3              0.000055 au BufNewFile,BufRead sendmail.cf		setf sm
                            
                            " Sendmail .mc files are actually m4.  Could also be MS Message text file.
    3              0.000059 au BufNewFile,BufRead *.mc			call s:McSetf()
                            
    3              0.000012 func! s:McSetf()
                              " Rely on the file to start with a comment.
                              " MS message text files use ';', Sendmail files use '#' or 'dnl'
                              for lnum in range(1, min([line("$"), 20]))
                                let line = getline(lnum)
                                if line =~ '^\s*\(#\|dnl\)'
                                  setf m4  " Sendmail .mc file
                                  return
                                elseif line =~ '^\s*;'
                                  setf msmessages  " MS Message text file
                                  return
                                endif
                              endfor
                              setf m4  " Default: Sendmail .mc file
                            endfunc
                            
                            " Services
    3              0.000057 au BufNewFile,BufRead */etc/services		setf services
                            
                            " Service Location config
    3              0.000074 au BufNewFile,BufRead */etc/slp.conf		setf slpconf
                            
                            " Service Location registration
    3              0.000054 au BufNewFile,BufRead */etc/slp.reg		setf slpreg
                            
                            " Service Location SPI
    3              0.000053 au BufNewFile,BufRead */etc/slp.spi		setf slpspi
                            
                            " Setserial config
    3              0.000056 au BufNewFile,BufRead */etc/serial.conf		setf setserial
                            
                            " SGML
    3              0.000149 au BufNewFile,BufRead *.sgm,*.sgml
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |
                            	\   setf sgmllnx |
                            	\ elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |
                            	\   let b:docbk_type="sgml" |
                            	\   setf docbk |
                            	\ else |
                            	\   setf sgml |
                            	\ endif
                            
                            " SGMLDECL
    3              0.000187 au BufNewFile,BufRead *.decl,*.dcl,*.dec
                            	\ if getline(1).getline(2).getline(3) =~? '^<!SGML' |
                            	\    setf sgmldecl |
                            	\ endif
                            
                            " SGML catalog file
    3              0.000056 au BufNewFile,BufRead catalog			setf catalog
    3              0.000058 au BufNewFile,BufRead sgml.catalog*		call s:StarSetf('catalog')
                            
                            " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
                            " Gentoo ebuilds are actually bash scripts
    3              0.000342 au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash_profile*,.bash_logout*,*.bash,*.ebuild call SetFileTypeSH("bash")
    3              0.000119 au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH("ksh")
    3              0.000213 au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1))
                            
                            " Also called from scripts.vim.
    3              0.000008 func! SetFileTypeSH(name)
                              if expand("<amatch>") =~ g:ft_ignore_pat
                                return
                              endif
                              if a:name =~ '\<csh\>'
                                " Some .sh scripts contain #!/bin/csh.
                                call SetFileTypeShell("csh")
                                return
                              elseif a:name =~ '\<tcsh\>'
                                " Some .sh scripts contain #!/bin/tcsh.
                                call SetFileTypeShell("tcsh")
                                return
                              elseif a:name =~ '\<ksh\>'
                                let b:is_kornshell = 1
                                if exists("b:is_bash")
                                  unlet b:is_bash
                                endif
                                if exists("b:is_sh")
                                  unlet b:is_sh
                                endif
                              elseif exists("g:bash_is_sh") || a:name =~ '\<bash\>' || a:name =~ '\<bash2\>'
                                let b:is_bash = 1
                                if exists("b:is_kornshell")
                                  unlet b:is_kornshell
                                endif
                                if exists("b:is_sh")
                                  unlet b:is_sh
                                endif
                              elseif a:name =~ '\<sh\>'
                                let b:is_sh = 1
                                if exists("b:is_kornshell")
                                  unlet b:is_kornshell
                                endif
                                if exists("b:is_bash")
                                  unlet b:is_bash
                                endif
                              endif
                              call SetFileTypeShell("sh")
                            endfunc
                            
                            " For shell-like file types, check for an "exec" command hidden in a comment,
                            " as used for Tcl.
                            " Also called from scripts.vim, thus can't be local to this script.
    3              0.000006 func! SetFileTypeShell(name)
                              if expand("<amatch>") =~ g:ft_ignore_pat
                                return
                              endif
                              let l = 2
                              while l < 20 && l < line("$") && getline(l) =~ '^\s*\(#\|$\)'
                                " Skip empty and comment lines.
                                let l = l + 1
                              endwhile
                              if l < line("$") && getline(l) =~ '\s*exec\s' && getline(l - 1) =~ '^\s*#.*\\$'
                                " Found an "exec" line after a comment with continuation
                                let n = substitute(getline(l),'\s*exec\s\+\([^ ]*/\)\=', '', '')
                                if n =~ '\<tclsh\|\<wish'
                                  setf tcl
                                  return
                                endif
                              endif
                              exe "setf " . a:name
                            endfunc
                            
                            " tcsh scripts
    3              0.000207 au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login	call SetFileTypeShell("tcsh")
                            
                            " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
    3              0.000358 au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call s:CSH()
                            
    3              0.000010 func! s:CSH()
                              if exists("g:filetype_csh")
                                call SetFileTypeShell(g:filetype_csh)
                              elseif &shell =~ "tcsh"
                                call SetFileTypeShell("tcsh")
                              else
                                call SetFileTypeShell("csh")
                              endif
                            endfunc
                            
                            " Z-Shell script
    3              0.000159 au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
    3              0.000163 au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
    3              0.000069 au BufNewFile,BufRead *.zsh			setf zsh
                            
                            " Scheme
    3              0.000116 au BufNewFile,BufRead *.scm,*.ss		setf scheme
                            
                            " Screen RC
    3              0.000106 au BufNewFile,BufRead .screenrc,screenrc	setf screen
                            
                            " Simula
    3              0.000068 au BufNewFile,BufRead *.sim			setf simula
                            
                            " SINDA
    3              0.000132 au BufNewFile,BufRead *.sin,*.s85		setf sinda
                            
                            " SiSU
    3              0.000291 au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
    3              0.000154 au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
                            
                            " SKILL
    3              0.000181 au BufNewFile,BufRead *.il,*.ils,*.cdf		setf skill
                            
                            " SLRN
    3              0.000057 au BufNewFile,BufRead .slrnrc			setf slrnrc
    3              0.000056 au BufNewFile,BufRead *.score			setf slrnsc
                            
                            " Smalltalk (and TeX)
    3              0.000057 au BufNewFile,BufRead *.st			setf st
    3              0.000084 au BufNewFile,BufRead *.cls
                            	\ if getline(1) =~ '^%' |
                            	\  setf tex |
                            	\ else |
                            	\  setf st |
                            	\ endif
                            
                            " Smarty templates
    3              0.000069 au BufNewFile,BufRead *.tpl			setf smarty
                            
                            " SMIL or XML
    3              0.000069 au BufNewFile,BufRead *.smil
                            	\ if getline(1) =~ '<?\s*xml.*?>' |
                            	\   setf xml |
                            	\ else |
                            	\   setf smil |
                            	\ endif
                            
                            " SMIL or SNMP MIB file
    3              0.000084 au BufNewFile,BufRead *.smi
                            	\ if getline(1) =~ '\<smil\>' |
                            	\   setf smil |
                            	\ else |
                            	\   setf mib |
                            	\ endif
                            
                            " SMITH
    3              0.000118 au BufNewFile,BufRead *.smt,*.smith		setf smith
                            
                            " Snobol4 and spitbol
    3              0.000162 au BufNewFile,BufRead *.sno,*.spt		setf snobol4
                            
                            " SNMP MIB files
    3              0.000121 au BufNewFile,BufRead *.mib,*.my		setf mib
                            
                            " Snort Configuration
    3              0.000174 au BufNewFile,BufRead *.hog,snort.conf,vision.conf	setf hog
    3              0.000058 au BufNewFile,BufRead *.rules			call s:FTRules()
                            
    3              0.000022 let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'
    3              0.000009 func! s:FTRules()
                              let path = expand('<amatch>:p')
                              if path =~ '^/\(etc/udev/\%(rules\.d/\)\=.*\.rules\|lib/udev/\%(rules\.d/\)\=.*\.rules\)$'
                                setf udevrules
                                return
                              endif
                              if path =~ '^/etc/ufw/'
                                setf conf  " Better than hog
                                return
                              endif
                              try
                                let config_lines = readfile('/etc/udev/udev.conf')
                              catch /^Vim\%((\a\+)\)\=:E484/
                                setf hog
                                return
                              endtry
                              let dir = expand('<amatch>:p:h')
                              for line in config_lines
                                if line =~ s:ft_rules_udev_rules_pattern
                                  let udev_rules = substitute(line, s:ft_rules_udev_rules_pattern, '\1', "")
                                  if dir == udev_rules
                                    setf udevrules
                                  endif
                                  break
                                endif
                              endfor
                              setf hog
                            endfunc
                            
                            
                            " Spec (Linux RPM)
    3              0.000062 au BufNewFile,BufRead *.spec			setf spec
                            
                            " Speedup (AspenTech plant simulator)
    3              0.000170 au BufNewFile,BufRead *.speedup,*.spdata,*.spd	setf spup
                            
                            " Slice
    3              0.000070 au BufNewFile,BufRead *.ice			setf slice
                            
                            " Spice
    3              0.000106 au BufNewFile,BufRead *.sp,*.spice		setf spice
                            
                            " Spyce
    3              0.000134 au BufNewFile,BufRead *.spy,*.spi		setf spyce
                            
                            " Squid
    3              0.000059 au BufNewFile,BufRead squid.conf		setf squid
                            
                            " SQL for Oracle Designer
    3              0.000347 au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks	setf sql
                            
                            " SQL
    3              0.000073 au BufNewFile,BufRead *.sql			call s:SQL()
                            
    3              0.000007 func! s:SQL()
                              if exists("g:filetype_sql")
                                exe "setf " . g:filetype_sql
                              else
                                setf sql
                              endif
                            endfunc
                            
                            " SQLJ
    3              0.000072 au BufNewFile,BufRead *.sqlj			setf sqlj
                            
                            " SQR
    3              0.000135 au BufNewFile,BufRead *.sqr,*.sqi		setf sqr
                            
                            " OpenSSH configuration
    3              0.000112 au BufNewFile,BufRead ssh_config,*/.ssh/config	setf sshconfig
                            
                            " OpenSSH server configuration
    3              0.000060 au BufNewFile,BufRead sshd_config		setf sshdconfig
                            
                            " Stata
    3              0.000277 au BufNewFile,BufRead *.ado,*.class,*.do,*.imata,*.mata   setf stata
                            
                            " SMCL
    3              0.000174 au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl	setf smcl
                            
                            " Stored Procedures
    3              0.000072 au BufNewFile,BufRead *.stp			setf stp
                            
                            " Standard ML
    3              0.000070 au BufNewFile,BufRead *.sml			setf sml
                            
                            " Sratus VOS command macro
    3              0.000059 au BufNewFile,BufRead *.cm			setf voscm
                            
                            " Sysctl
    3              0.000125 au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf	setf sysctl
                            
                            " Synopsys Design Constraints
    3              0.000074 au BufNewFile,BufRead *.sdc			setf sdc
                            
                            " Sudoers
    3              0.000113 au BufNewFile,BufRead */etc/sudoers,sudoers.tmp	setf sudoers
                            
                            " SVG (Scalable Vector Graphics)
    3              0.000074 au BufNewFile,BufRead *.svg			setf svg
                            
                            " If the file has an extension of 't' and is in a directory 't' then it is
                            " almost certainly a Perl test file.
                            " If the first line starts with '#' and contains 'perl' it's probably a Perl
                            " file.
                            " (Slow test) If a file contains a 'use' statement then it is almost certainly
                            " a Perl file.
    3              0.000009 func! s:FTperl()
                              if expand("%:e") == 't' && expand("%:p:h:t") == 't'
                                setf perl
                                return 1
                              endif
                              if getline(1)[0] == '#' && getline(1) =~ 'perl'
                                setf perl
                                return 1
                              endif
                              if search('^use\s\s*\k', 'nc', 30)
                                setf perl
                                return 1
                              endif
                              return 0
                            endfunc
                            
                            " Tads (or Nroff or Perl test file)
    3              0.000064 au BufNewFile,BufRead *.t
                            	\ if !s:FTnroff() && !s:FTperl() | setf tads | endif
                            
                            " Tags
    3              0.000062 au BufNewFile,BufRead tags			setf tags
                            
                            " TAK
    3              0.000075 au BufNewFile,BufRead *.tak			setf tak
                            
                            " Task
    3              0.000084 au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
    3              0.000061 au BufRead,BufNewFile *.task                    setf taskedit
                            
                            " Tcl (JACL too)
    3              0.000300 au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl	setf tcl
                            
                            " TealInfo
    3              0.000075 au BufNewFile,BufRead *.tli			setf tli
                            
                            " Telix Salt
    3              0.000075 au BufNewFile,BufRead *.slt			setf tsalt
                            
                            " Terminfo
    3              0.000060 au BufNewFile,BufRead *.ti			setf terminfo
                            
                            " TeX
    3              0.000333 au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl	setf tex
    3              0.000077 au BufNewFile,BufRead *.tex			call s:FTtex()
                            
                            " Choose context, plaintex, or tex (LaTeX) based on these rules:
                            " 1. Check the first line of the file for "%&<format>".
                            " 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.
                            " 3. Default to "latex" or to g:tex_flavor, can be set in user's vimrc.
    3              0.000008 func! s:FTtex()
                              let firstline = getline(1)
                              if firstline =~ '^%&\s*\a\+'
                                let format = tolower(matchstr(firstline, '\a\+'))
                                let format = substitute(format, 'pdf', '', '')
                                if format == 'tex'
                                  let format = 'plain'
                                endif
                              else
                                " Default value, may be changed later:
                                let format = exists("g:tex_flavor") ? g:tex_flavor : 'plain'
                                " Save position, go to the top of the file, find first non-comment line.
                                let save_cursor = getpos('.')
                                call cursor(1,1)
                                let firstNC = search('^\s*[^[:space:]%]', 'c', 1000)
                                if firstNC " Check the next thousand lines for a LaTeX or ConTeXt keyword.
                                  let lpat = 'documentclass\>\|usepackage\>\|begin{\|newcommand\>\|renewcommand\>\|part\>\|chapter\>\|section\>\|subsection\>\|subsubsection\>\|paragraph\>\|subparagraph\>\|subsubparagraph'
                                  let cpat = 'start\a\+\|setup\a\+\|usemodule\|enablemode\|enableregime\|setvariables\|useencoding\|usesymbols\|stelle\a\+\|verwende\a\+\|stel\a\+\|gebruik\a\+\|usa\a\+\|imposta\a\+\|regle\a\+\|utilisemodule\>'
                                  let kwline = search('^\s*\\\%(' . lpat . '\)\|^\s*\\\(' . cpat . '\)',
                            			      \ 'cnp', firstNC + 1000)
                                  if kwline == 1	" lpat matched
                            	let format = 'latex'
                                  elseif kwline == 2	" cpat matched
                            	let format = 'context'
                                  endif		" If neither matched, keep default set above.
                                  " let lline = search('^\s*\\\%(' . lpat . '\)', 'cn', firstNC + 1000)
                                  " let cline = search('^\s*\\\%(' . cpat . '\)', 'cn', firstNC + 1000)
                                  " if cline > 0
                                  "   let format = 'context'
                                  " endif
                                  " if lline > 0 && (cline == 0 || cline > lline)
                                  "   let format = 'tex'
                                  " endif
                                endif " firstNC
                                call setpos('.', save_cursor)
                              endif " firstline =~ '^%&\s*\a\+'
                            
                              " Translation from formats to file types.  TODO:  add AMSTeX, RevTex, others?
                              if format == 'plain'
                                setf plaintex
                              elseif format == 'context'
                                setf context
                              else " probably LaTeX
                                setf tex
                              endif
                              return
                            endfunc
                            
                            " ConTeXt
    3              0.000189 au BufNewFile,BufRead tex/context/*/*.tex,*.mkii,*.mkiv   setf context
                            
                            " Texinfo
    3              0.000181 au BufNewFile,BufRead *.texinfo,*.texi,*.txi	setf texinfo
                            
                            " TeX configuration
    3              0.000063 au BufNewFile,BufRead texmf.cnf			setf texmf
                            
                            " Tidy config
    3              0.000116 au BufNewFile,BufRead .tidyrc,tidyrc		setf tidy
                            
                            " TF mud client
    3              0.000187 au BufNewFile,BufRead *.tf,.tfrc,tfrc		setf tf
                            
                            " TPP - Text Presentation Program
    3              0.000078 au BufNewFile,BufReadPost *.tpp			setf tpp
                            
                            " Treetop
    3              0.000059 au BufRead,BufNewFile *.treetop			setf treetop
                            
                            " Trustees
    3              0.000063 au BufNewFile,BufRead trustees.conf		setf trustees
                            
                            " TSS - Geometry
    3              0.000061 au BufNewFile,BufReadPost *.tssgm		setf tssgm
                            
                            " TSS - Optics
    3              0.000060 au BufNewFile,BufReadPost *.tssop		setf tssop
                            
                            " TSS - Command Line (temporary)
    3              0.000060 au BufNewFile,BufReadPost *.tsscl		setf tsscl
                            
                            " Motif UIT/UIL files
    3              0.000148 au BufNewFile,BufRead *.uit,*.uil		setf uil
                            
                            " Udev conf
    3              0.000068 au BufNewFile,BufRead */etc/udev/udev.conf	setf udevconf
                            
                            " Udev permissions
    3              0.000081 au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
                            "
                            " Udev symlinks config
    3              0.000068 au BufNewFile,BufRead */etc/udev/cdsymlinks.conf	setf sh
                            
                            " UnrealScript
    3              0.000061 au BufNewFile,BufRead *.uc			setf uc
                            
                            " Updatedb
    3              0.000065 au BufNewFile,BufRead */etc/updatedb.conf	setf updatedb
                            
                            " Upstart (init(8)) config files
    3              0.000125 au BufNewFile,BufRead */etc/init/*.conf,*/.init/*.conf          setf upstart
    3              0.000130 au BufNewFile,BufRead */etc/init/*.override,*/.init/*.override  setf upstart
                            
                            " Vera
    3              0.000201 au BufNewFile,BufRead *.vr,*.vri,*.vrh		setf vera
                            
                            " Verilog HDL
    3              0.000056 au BufNewFile,BufRead *.v			setf verilog
                            
                            " Verilog-AMS HDL
    3              0.000118 au BufNewFile,BufRead *.va,*.vams		setf verilogams
                            
                            " VHDL
    3              0.000341 au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
    3              0.000067 au BufNewFile,BufRead *.vhdl_[0-9]*		call s:StarSetf('vhdl')
                            
                            " Vim script
    3              0.000295 au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc	setf vim
                            
                            " Viminfo file
    3              0.000126 au BufNewFile,BufRead .viminfo,_viminfo		setf viminfo
                            
                            " Virata Config Script File or Drupal module
    3              0.000202 au BufRead,BufNewFile *.hw,*.module,*.pkg
                            	\ if getline(1) =~ '<?php' |
                            	\   setf php |
                            	\ else |
                            	\   setf virata |
                            	\ endif
                            
                            " Visual Basic (also uses *.bas) or FORM
    3              0.000081 au BufNewFile,BufRead *.frm			call s:FTVB("form")
                            
                            " SaxBasic is close to Visual Basic
    3              0.000080 au BufNewFile,BufRead *.sba			setf vb
                            
                            " Vgrindefs file
    3              0.000063 au BufNewFile,BufRead vgrindefs			setf vgrindefs
                            
                            " VRML V1.0c
    3              0.000078 au BufNewFile,BufRead *.wrl			setf vrml
                            
                            " Webmacro
    3              0.000062 au BufNewFile,BufRead *.wm			setf webmacro
                            
                            " Wget config
    3              0.000120 au BufNewFile,BufRead .wgetrc,wgetrc		setf wget
                            
                            " Website MetaLanguage
    3              0.000079 au BufNewFile,BufRead *.wml			setf wml
                            
                            " Winbatch
    3              0.000079 au BufNewFile,BufRead *.wbt			setf winbatch
                            
                            " WSML
    3              0.000063 au BufNewFile,BufRead *.wsml			setf wsml
                            
                            " WvDial
    3              0.000123 au BufNewFile,BufRead wvdial.conf,.wvdialrc	setf wvdial
                            
                            " CVS RC file
    3              0.000066 au BufNewFile,BufRead .cvsrc			setf cvsrc
                            
                            " CVS commit file
    3              0.000067 au BufNewFile,BufRead cvs\d\+			setf cvs
                            
                            " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
                            " lines in a WEB file).
    3              0.000103 au BufNewFile,BufRead *.web
                            	\ if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |
                            	\   setf web |
                            	\ else |
                            	\   setf winbatch |
                            	\ endif
                            
                            " Windows Scripting Host and Windows Script Component
    3              0.000065 au BufNewFile,BufRead *.ws[fc]			setf wsh
                            
                            " XHTML
    3              0.000141 au BufNewFile,BufRead *.xhtml,*.xht		setf xhtml
                            
                            " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
    3              0.000023 au BufEnter *.xpm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ else |
                            	\   setf xpm |
                            	\ endif
    3              0.000011 au BufEnter *.xpm2				setf xpm2
                            
                            " XFree86 config
    3              0.000082 au BufNewFile,BufRead XF86Config
                            	\ if getline(1) =~ '\<XConfigurator\>' |
                            	\   let b:xf86conf_xfree86_version = 3 |
                            	\ endif |
                            	\ setf xf86conf
    3              0.000081 au BufNewFile,BufRead */xorg.conf.d/*.conf
                            	\ let b:xf86conf_xfree86_version = 4 |
                            	\ setf xf86conf
                            
                            " Xorg config
    3              0.000126 au BufNewFile,BufRead xorg.conf,xorg.conf-4	let b:xf86conf_xfree86_version = 4 | setf xf86conf
                            
                            " Xinetd conf
    3              0.000066 au BufNewFile,BufRead */etc/xinetd.conf		setf xinetd
                            
                            " XS Perl extension interface language
    3              0.000065 au BufNewFile,BufRead *.xs			setf xs
                            
                            " X resources file
    3              0.000298 au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
                            
                            " Xmath
    3              0.000155 au BufNewFile,BufRead *.msc,*.msf		setf xmath
    3              0.000070 au BufNewFile,BufRead *.ms
                            	\ if !s:FTnroff() | setf xmath | endif
                            
                            " XML  specific variants: docbk and xbl
    3              0.000082 au BufNewFile,BufRead *.xml			call s:FTxml()
                            
    3              0.000014 func! s:FTxml()
                              let n = 1
                              while n < 100 && n < line("$")
                                let line = getline(n)
                                if line =~ '<!DOCTYPE.*DocBook'
                                  let b:docbk_type = "xml"
                                  setf docbk
                                  return
                                endif
                                if line =~ 'xmlns:xbl="http://www.mozilla.org/xbl"'
                                  setf xbl
                                  return
                                endif
                                let n += 1
                              endwhile
                              setf xml
                            endfunc
                            
                            " XMI (holding UML models) is also XML
    3              0.000086 au BufNewFile,BufRead *.xmi			setf xml
                            
                            " CSPROJ files are Visual Studio.NET's XML-based project config files
    3              0.000122 au BufNewFile,BufRead *.csproj,*.csproj.user	setf xml
                            
                            " Qt Linguist translation source and Qt User Interface Files are XML
    3              0.000124 au BufNewFile,BufRead *.ts,*.ui			setf xml
                            
                            " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
    3              0.000086 au BufNewFile,BufRead *.tpm			setf xml
                            
                            " Xdg menus
    3              0.000075 au BufNewFile,BufRead */etc/xdg/menus/*.menu	setf xml
                            
                            " ATI graphics driver configuration
    3              0.000066 au BufNewFile,BufRead fglrxrc			setf xml
                            
                            " XLIFF (XML Localisation Interchange File Format) is also XML
    3              0.000082 au BufNewFile,BufRead *.xlf			setf xml
    3              0.000064 au BufNewFile,BufRead *.xliff			setf xml
                            
                            " X11 xmodmap (also see below)
    3              0.000062 au BufNewFile,BufRead *Xmodmap			setf xmodmap
                            
                            " Xquery
    3              0.000346 au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy	setf xquery
                            
                            " XSD
    3              0.000083 au BufNewFile,BufRead *.xsd			setf xsd
                            
                            " Xslt
    3              0.000144 au BufNewFile,BufRead *.xsl,*.xslt		setf xslt
                            
                            " Yacc
    3              0.000066 au BufNewFile,BufRead *.yy			setf yacc
                            
                            " Yacc or racc
    3              0.000065 au BufNewFile,BufRead *.y			call s:FTy()
                            
    3              0.000009 func! s:FTy()
                              let n = 1
                              while n < 100 && n < line("$")
                                let line = getline(n)
                                if line =~ '^\s*%'
                                  setf yacc
                                  return
                                endif
                                if getline(n) =~ '^\s*\(#\|class\>\)' && getline(n) !~ '^\s*#\s*include'
                                  setf racc
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf yacc
                            endfunc
                            
                            
                            " Yaml
    3              0.000146 au BufNewFile,BufRead *.yaml,*.yml		setf yaml
                            
                            " yum conf (close enough to dosini)
    3              0.000067 au BufNewFile,BufRead */etc/yum.conf 		setf dosini
                            
                            " Zope
                            "   dtml (zope dynamic template markup language), pt (zope page template),
                            "   cpt (zope form controller page template)
    3              0.000200 au BufNewFile,BufRead *.dtml,*.pt,*.cpt		call s:FThtml()
                            "   zsql (zope sql method)
    3              0.000066 au BufNewFile,BufRead *.zsql			call s:SQL()
                            
                            " Z80 assembler asz80
    3              0.000082 au BufNewFile,BufRead *.z8a			setf z8a
                            
    3              0.000006 augroup END
                            
                            
                            " Source the user-specified filetype file, for backwards compatibility with
                            " Vim 5.x.
    3              0.000031 if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
                              execute "source " . myfiletypefile
                            endif
                            
                            
                            " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
                            " when there are no matching file name extensions.
                            " Don't do this for compressed files.
    3              0.000005 augroup filetypedetect
    3              0.000071 au BufNewFile,BufRead *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\ | runtime! scripts.vim | endif
    3              0.000017 au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
                            
                            
                            " Extra checks for when no filetype has been detected now.  Mostly used for
                            " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
                            " script file.
                            " Most of these should call s:StarSetf() to avoid names ending in .gz and the
                            " like are used.
                            
                            " More Apache config files
    3              0.000302 au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*	call s:StarSetf('apache')
    3              0.000364 au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*		call s:StarSetf('apache')
                            
                            " Asterisk config file
    3              0.000073 au BufNewFile,BufRead *asterisk/*.conf*		call s:StarSetf('asterisk')
    3              0.000078 au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
                            
                            " Bazaar version control
    3              0.000065 au BufNewFile,BufRead bzr_log.*			setf bzr
                            
                            " BIND zone
    3              0.000121 au BufNewFile,BufRead */named/db.*,*/bind/db.*	call s:StarSetf('bindzone')
                            
                            " Calendar
    3              0.000205 au BufNewFile,BufRead */.calendar/*,
                            	\*/share/calendar/*/calendar.*,*/share/calendar/calendar.*
                            	\					call s:StarSetf('calendar')
                            
                            " Changelog
    3              0.000090 au BufNewFile,BufRead [cC]hange[lL]og*
                            	\ if getline(1) =~ '; urgency='
                            	\|  call s:StarSetf('debchangelog')
                            	\|else
                            	\|  call s:StarSetf('changelog')
                            	\|endif
                            
                            " Crontab
    3              0.000189 au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*		call s:StarSetf('crontab')
                            
                            " dnsmasq(8) configuration
    3              0.000069 au BufNewFile,BufRead */etc/dnsmasq.d/*		call s:StarSetf('dnsmasq')
                            
                            " Dracula
    3              0.000069 au BufNewFile,BufRead drac.*			call s:StarSetf('dracula')
                            
                            " Fvwm
    3              0.000064 au BufNewFile,BufRead */.fvwm/*			call s:StarSetf('fvwm')
    3              0.000133 au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook
                            	\ let b:fvwm_version = 1 | call s:StarSetf('fvwm')
    3              0.000083 au BufNewFile,BufRead *fvwm2rc*
                            	\ if expand("<afile>:e") == "m4"
                            	\|  call s:StarSetf('fvwm2m4')
                            	\|else
                            	\|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')
                            	\|endif
                            
                            " Gedcom
    3              0.000066 au BufNewFile,BufRead */tmp/lltmp*		call s:StarSetf('gedcom')
                            
                            " GTK RC
    3              0.000127 au BufNewFile,BufRead .gtkrc*,gtkrc*		call s:StarSetf('gtkrc')
                            
                            " Jam
    3              0.000138 au BufNewFile,BufRead Prl*.*,JAM*.*		call s:StarSetf('jam')
                            
                            " Jargon
    3              0.000085 au! BufNewFile,BufRead *jarg*
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'
                            	\|  call s:StarSetf('jargon')
                            	\|endif
                            
                            " Kconfig
    3              0.000068 au BufNewFile,BufRead Kconfig.*			call s:StarSetf('kconfig')
                            
                            " Lilo: Linux loader
    3              0.000068 au BufNewFile,BufRead lilo.conf*		call s:StarSetf('lilo')
                            
                            " Logcheck
    3              0.000079 au BufNewFile,BufRead */etc/logcheck/*.d*/*	call s:StarSetf('logcheck')
                            
                            " Makefile
    3              0.000070 au BufNewFile,BufRead [mM]akefile*		call s:StarSetf('make')
                            
                            " Ruby Makefile
    3              0.000070 au BufNewFile,BufRead [rR]akefile*		call s:StarSetf('ruby')
                            
                            " Mail (also matches muttrc.vim, so this is below the other checks)
    3              0.000090 au BufNewFile,BufRead mutt[[:alnum:]._-]\{6\}	setf mail
                            
                            " Modconf
    3              0.000081 au BufNewFile,BufRead */etc/modutils/*
                            	\ if executable(expand("<afile>")) != 1
                            	\|  call s:StarSetf('modconf')
                            	\|endif
    3              0.000069 au BufNewFile,BufRead */etc/modprobe.*		call s:StarSetf('modconf')
                            
                            " Mutt setup file
    3              0.000161 au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*	call s:StarSetf('muttrc')
    3              0.000142 au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*		call s:StarSetf('muttrc')
                            
                            " Nroff macros
    3              0.000072 au BufNewFile,BufRead tmac.*			call s:StarSetf('nroff')
                            
                            " Pam conf
    3              0.000071 au BufNewFile,BufRead */etc/pam.d/*		call s:StarSetf('pamconf')
                            
                            " Printcap and Termcap
    3              0.000079 au BufNewFile,BufRead *printcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')
                            	\|endif
    3              0.000078 au BufNewFile,BufRead *termcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')
                            	\|endif
                            
                            " Remind
    3              0.000070 au BufNewFile,BufRead .reminders*		call s:StarSetf('remind')
                            
                            " Vim script
    3              0.000069 au BufNewFile,BufRead *vimrc*			call s:StarSetf('vim')
                            
                            " Subversion commit file
    3              0.000075 au BufNewFile,BufRead svn-commit*.tmp		setf svn
                            
                            " X resources file
    3              0.000195 au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
                            
                            " XFree86 config
    3              0.000076 au BufNewFile,BufRead XF86Config-4*
                            	\ let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
    3              0.000083 au BufNewFile,BufRead XF86Config*
                            	\ if getline(1) =~ '\<XConfigurator\>'
                            	\|  let b:xf86conf_xfree86_version = 3
                            	\|endif
                            	\|call s:StarSetf('xf86conf')
                            
                            " X11 xmodmap
    3              0.000069 au BufNewFile,BufRead *xmodmap*			call s:StarSetf('xmodmap')
                            
                            " Xinetd conf
    3              0.000070 au BufNewFile,BufRead */etc/xinetd.d/*		call s:StarSetf('xinetd')
                            
                            " yum conf (close enough to dosini)
    3              0.000071 au BufNewFile,BufRead */etc/yum.repos.d/* 	call s:StarSetf('dosini')
                            
                            " Z-Shell script
    3              0.000151 au BufNewFile,BufRead zsh*,zlog*		call s:StarSetf('zsh')
                            
                            
                            " Plain text files, needs to be far down to not override others.  This avoids
                            " the "conf" type being used if there is a line starting with '#'.
    3              0.000154 au BufNewFile,BufRead *.txt,*.text		setf text
                            
                            
                            " Use the filetype detect plugins.  They may overrule any of the previously
                            " detected filetypes.
    3              0.000299 runtime! ftdetect/*.vim
                            
                            
                            " Generic configuration file (check this last, it's just guessing!)
    3              0.000101 au BufNewFile,BufRead,StdinReadPost *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'
                            	\	|| getline(4) =~ '^#' || getline(5) =~ '^#') |
                            	\   setf conf |
                            	\ endif
                            
    3              0.000006 augroup END
                            
                            
                            " If the GUI is already running, may still need to install the Syntax menu.
                            " Don't do it when the 'M' flag is included in 'guioptions'.
    3              0.000049 if has("menu") && has("gui_running")
                                  \ && !exists("did_install_syntax_menu") && &guioptions !~# "M"
                              source <sfile>:p:h/menu.vim
                            endif
                            
                            " Function called for testing all functions defined here.  These are
                            " script-local, thus need to be executed here.
                            " Returns a string with error messages (hopefully empty).
    3              0.000012 func! TestFiletypeFuncs(testlist)
                              let output = ''
                              for f in a:testlist
                                try
                                  exe f
                                catch
                                  let output = output . "\n" . f . ": " . v:exception
                                endtry
                              endfor
                              return output
                            endfunc
                            
                            " Restore 'cpoptions'
    3              0.000079 let &cpo = s:cpo_save
    3              0.000020 unlet s:cpo_save

SCRIPT  /home/joshb/.vimrc
Sourced 1 time
Total time:   0.046429
 Self time:   0.001477

count  total (s)   self (s)
                            filetype off
                            
                            "
                            "     surrounds a TraceLine with a Verbose check
                            "     '<,'>g/TraceLine/-1s/^.*$/&\rif (verbose){/ | +2s/^.*$/}\r&/
                            "
                            "
                            " set the starting path
                            "cd c:\Users\Mark\Documents\Visual\ Studio\ 2008\Projects\
                            
                            "source $VIMRUNTIME/vimrc_example.vim
                            "source $VIMRUNTIME/mswin.vim
                            "behave mswin
    1              0.000056 set nocompatible
                            " changes it so the mouse starts Visual mode not Select mode
    1              0.000004 set selectmode="key"
                            " make i_^y do what it is supposed to do
    1              0.000016 inoremap <c-Y> <c-Y>
                            " make Y act similar to D or C in that it yanks to end of line
    1              0.000005 noremap Y y$
                            
                            
                            
                            
                            
                            
                            "My Custom vimrc stuff
                            "
                            "PLugins I've got so far: tcomment, NerdTree, colorschemes from vim.org
                            " Pathogen, autocorrect, sparkup, vim-taglist, ctags, surround, matching
                            "
                            "retab
                            "
    1              0.000002 set relativenumber
                            
    1              0.000002 set autoread
    1              0.000002 set ignorecase
    1              0.000002 set smartcase
    1              0.000002 set gdefault
    1              0.000001 set nohlsearch
    1              0.000002 set visualbell
                            
    1              0.000001 set lazyredraw
                            
                            
    1              0.000002 set nowrap
                            
                            "gui stuff, last one is the default
    1              0.000006 set guioptions=ac
                            "set guioptions=egmrLtT
                            
                            "set thesaurus+=C:\Users\Mark\Documents\Thesaurus\mthesaur.txt
                            
                            " filetype plugin indent on
    1              0.000190 filetype plugin on
    1              0.000034 filetype indent on
                            
    1              0.000007 set cursorline
                            
    1              0.000002 set expandtab
    1              0.000006 set tabstop=4
    1              0.000003 set softtabstop=4
    1              0.000001 set shiftwidth=4
                            " set smartindent
    1              0.000002 set autoindent
    1              0.000003 set textwidth=80
                            
                            " allow editing virtual space only in blocks
    1              0.000015 set virtualedit=block
                            
                            "draws the line on the textwidth line
    1              0.000004 set colorcolumn=+1
                            
                            " Allows for undo history after close
    1              0.000002 set undofile
                            
                            "history edits
    1              0.000002 set history=1000
    1              0.000004 set undolevels=1000
                            
                            "ignores certain files for tab completion
    1              0.000003 set wildignore=*.swp,*.png,*.cd,*.ico,*.jpg,*.ico,*.cs~,*.txt~,*.py~
                            "
                            " Allows for having files offscreen without saving first
    1              0.000002 set hidden
                            
                            " allows for crazy tab menu
    1              0.000001 set wildmenu
                            
                            " font size
                            " set guifont=:h20
                            "set guifont=Consolas:h14
    1              0.000002 set guifont=ProggyClean\ 12
                            " set guifont="Consolas for Powerline/CONSOLAS-Powerline":h15
    1              0.000027 colorscheme vividchalk
                            
                            
    1              0.000004 let g:buftabs_only_basename=1
                            
                            " " " "pathogen "  "  " 
    1              0.000026 call pathogen#infect()
    1   0.005581   0.000015 call pathogen#helptags()
                            
                            " " " " Taglist variables "  "  "  
                            
                            "let Tlist_Ctags_Cmd = shellescape('E:\Program Files (x86)\Vim\ctags\ctags58\ctags.exe')
    1              0.000012 map <F4> :TlistToggle<cr>
                            
                            " Display function name in status bar:
    1              0.000003 let g:ctags_statusline=1
                            " Automatically start script
    1              0.000002 let generate_tags=1
                            " Displays taglist results in a vertical window:
    1              0.000003 let Tlist_Use_Horiz_Window=0
                            " Shorter commands to toggle Taglist display
    1              0.000009 nnoremap TT :TlistToggle<CR>
    1              0.000006 map <F4> :TlistToggle<CR>
                            " Various Taglist diplay config:
    1              0.000003 let Tlist_Use_Right_Window = 1
    1              0.000003 let Tlist_Compact_Format = 1
    1              0.000003 let Tlist_Exit_OnlyWindow = 1
    1              0.000005 let Tlist_GainFocus_On_ToggleOpen = 1
    1              0.000003 let Tlist_File_Fold_Auto_Close = 1
    1              0.000002 let Tlist_WinWidth = 40
                            
                            
                            " NERDtree stuff
    1              0.000007 let NERDTreeIgnore=['\.jpg$','\.png$','\.ico$','\.csproj$',    '\.user$', '\.cachefile$','\.cd$','\.jpeg$',   '\.pyc$', '\~$']
    1              0.000007 noremap <f3> :NERDTreeToggle<cr>
                            
                            " MRU plugin
    1              0.000002 let MRU_Max_Entries = 1000
                            
                            "full screen
                            " map <F11> <Esc>:call libcallnr("gvimfullscreen.dll", "ToggleFullScreen", 0)<CR> 
                            "map <F11> :simalt ~x<cr>
                            
                            "hard mode for insert mode
    1              0.000003 inoremap <Esc> <Nop>
    1              0.000004 inoremap <Backspace> <Nop>
    1              0.000004 inoremap <c-b> <Del>
                            
    1              0.000004 inoremap ^c <Esc>
    1              0.000004 vnoremap ^c <Esc>
    1              0.000004 nnoremap ^c <Esc>
                            
                            
                            "change leader key
    1              0.000002 let mapleader = ","
                            
                            "map keys for next and prev buffer
    1              0.000008 noremap <Leader>n :bn
    1              0.000006 noremap <Leader>p :bp
    1              0.000006 noremap <Leader>d :pwd
                            
    1              0.000007 noremap <Leader>c :lcd %:p:h
    1              0.000006 noremap <Leader>l :ls
                            
                            "map keys for running current file in Python
    1              0.000008 noremap <Leader>z :!python %
    1              0.000007 noremap <Leader>c :e $MYVIMRC
    1              0.000007 noremap <Leader>a :MRU
                            
                            "make it so ,s and ,S enable or disable smart indent
    1              0.000009 noremap <Leader>s :set nosmartindent<cr>
    1              0.000009 noremap <Leader>S :set smartindent<cr>
                            
                            
    1              0.000006 noremap <Leader>l :ls<cr>
                            " override windows redo, back to scroll up.
    1              0.000004 noremap <c-y> <c-y>
                            
                            " map f8 to edit vimrc, but removed because I don't like the F keys
                            " noremap <F8> :e $myvimrc\
                            " noremap <F6> :MRU\
                            
                            " noremap <F7> :!python %\
                            
                            
                            "makes the cmdline 2 lines high. need to do this for the sake of avoiding
                            " \"PRESS ENTER TO CONTINUE"
    1              0.000019 set cmdheight=2
                            
                            
                            " sets spell on if it's a .txt file
    1              0.000151 au BufNewFile,BufRead *.txt set spell  
                            " sets the cwd to current directory
    1              0.000004 autocmd BufEnter * silent! lcd %:p:h
                            
                            "end custom
                            
    1              0.000004 set diffexpr=MyDiff()
    1              0.000003 function MyDiff()
                              let opt = '-a --binary '
                              if &diffopt =~ 'icase' | let opt = opt . '-i ' | endif
                              if &diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
                              let arg1 = v:fname_in
                              if arg1 =~ ' ' | let arg1 = '"' . arg1 . '"' | endif
                              let arg2 = v:fname_new
                              if arg2 =~ ' ' | let arg2 = '"' . arg2 . '"' | endif
                              let arg3 = v:fname_out
                              if arg3 =~ ' ' | let arg3 = '"' . arg3 . '"' | endif
                              let eq = ''
                              if $VIMRUNTIME =~ ' '
                                if &sh =~ '\<cmd'
                                  let cmd = '""' . $VIMRUNTIME . '\diff"'
                                  let eq = '"'
                                else
                                  let cmd = substitute($VIMRUNTIME, ' ', '" ', '') . '\diff"'
                                endif
                              else
                                let cmd = $VIMRUNTIME . '\diff'
                              endif
                              silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3 . eq
                            endfunction
                            
                            "here is a more exotic version of my original Kwbd script
                            "delete the buffer; keep windows; create a scratch buffer if no buffers left
    1              0.000004 function s:Kwbd(kwbdStage)
                              if(a:kwbdStage == 1)
                                if(!buflisted(winbufnr(0)))
                                  bd!
                                  return
                                endif
                                let s:kwbdBufNum = bufnr("%")
                                let s:kwbdWinNum = winnr()
                                windo call s:Kwbd(2)
                                execute s:kwbdWinNum . 'wincmd w'
                                let s:buflistedLeft = 0
                                let s:bufFinalJump = 0
                                let l:nBufs = bufnr("$")
                                let l:i = 1
                                while(l:i <= l:nBufs)
                                  if(l:i != s:kwbdBufNum)
                                    if(buflisted(l:i))
                                      let s:buflistedLeft = s:buflistedLeft + 1
                                    else
                                      if(bufexists(l:i) && !strlen(bufname(l:i)) && !s:bufFinalJump)
                                        let s:bufFinalJump = l:i
                                      endif
                                    endif
                                  endif
                                  let l:i = l:i + 1
                                endwhile
                                if(!s:buflistedLeft)
                                  if(s:bufFinalJump)
                                    windo if(buflisted(winbufnr(0))) | execute "b! " . s:bufFinalJump | endif
                                  else
                                    enew
                                    let l:newBuf = bufnr("%")
                                    windo if(buflisted(winbufnr(0))) | execute "b! " . l:newBuf | endif
                                  endif
                                  execute s:kwbdWinNum . 'wincmd w'
                                endif
                                if(buflisted(s:kwbdBufNum) || s:kwbdBufNum == bufnr("%"))
                                  execute "bd! " . s:kwbdBufNum
                                endif
                                if(!s:buflistedLeft)
                                  set buflisted
                                  set bufhidden=delete
                                  set buftype=
                                  setlocal noswapfile
                                endif
                              else
                                if(bufnr("%") == s:kwbdBufNum)
                                  let prevbufvar = bufnr("#")
                                  if(prevbufvar > 0 && buflisted(prevbufvar) && prevbufvar != s:kwbdBufNum)
                                    b #
                                  else
                                    bn
                                  endif
                                endif
                              endif
                            endfunction
                            
    1              0.000007 command! Kwbd call s:Kwbd(1)
    1              0.000009 nnoremap <silent> <Plug>Kwbd :<C-u>Kwbd<CR>
                            
                            " Create a mapping (e.g. in your .vimrc) like this:
    1              0.000007 nmap <f2> <Plug>Kwbd
                            
                            
    1              0.000008 if has("gui_running")
                              " GUI is running or is about to start.
                              " Maximize gvim window.
                              set lines=999 columns=999
                            else
                              " This is console Vim.
    1              0.000004   if exists("+lines")
    1              0.000003     set lines=50
    1              0.000001   endif
    1              0.000003   if exists("+columns")
    1              0.000003     set columns=100
    1              0.000001   endif
    1              0.000001 endif
                            
                            "powerline stuff
    1              0.000003 set laststatus=2
    1              0.000069 set encoding=utf-8 " Necessary to show Unicode glyphs
    1              0.000004 let g:Powerline_symbols = 'compatible'
                            "let g:Powerline_symbols = 'fancy'
                            "let g:Powerline_symbols = 'unicode'
                            
                            " Overriding symbols
    1              0.000011 let g:Powerline_symbols_override = {
                                \   'BRANCH': [0x2b60]
                                \ , 'RO'    : [0x2b64]
                                \ , 'FT'    : [0x2b62, 0x2b63]
                                \ , 'LINE'  : [0x2b61]
                            \}
                            " Overriding dividers
    1              0.000004 let g:Powerline_dividers_override = ['', [0x2b81], '', [0x2b83]]
                            
                            
                            " custom build files for Orchid
    1              0.000005 let &makeprg='"C:\Users\Mark\Documents\Visual Studio 2010\Projects\Orchid\Orchid\Orchid\build.bat"'
    1              0.000005 set errorformat=\ %#%f(%l\\\,%c):\ %m
                            
                            " for switching case of text in visual mode
    1              0.000002 function! TwiddleCase(str)
                              if a:str ==# toupper(a:str)
                                let result = tolower(a:str)
                              elseif a:str ==# tolower(a:str)
                                let result = substitute(a:str,'\(\<\w\+\>\)', '\u\1', 'g')
                              else
                                let result = toupper(a:str)
                              endif
                              return result
                            endfunction
    1              0.000009 vnoremap ~ ygv"=TwiddleCase(@")<CR>Pgv
                            
                            
                            
                            " go fullscreen
                            "simalt ~x<cr>
                            "au GUIEnter * simalt ~x
                            
                            " python-mode stuff
    1              0.000003 let g:pymode_doc_key = '<Leader><Leader>a'
    1              0.000004 let g:pymode_folding = 0

SCRIPT  /usr/share/vim/vim73/ftoff.vim
Sourced 2 times
Total time:   0.001076
 Self time:   0.001076

count  total (s)   self (s)
                            " Vim support file to switch off detection of file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2001 Jun 11
                            
    2              0.000010 if exists("did_load_filetypes")
    2              0.000004   unlet did_load_filetypes
    2              0.000002 endif
                            
                            " Remove all autocommands in the filetypedetect group
    2              0.001047 silent! au! filetypedetect *

SCRIPT  /usr/share/vim/vim73/ftplugin.vim
Sourced 1 time
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
                            " Vim support file to switch on loading plugins for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2006 Apr 30
                            
    1              0.000005 if exists("did_load_ftplugin")
                              finish
                            endif
    1              0.000004 let did_load_ftplugin = 1
                            
    1              0.000003 augroup filetypeplugin
    1              0.000006   au FileType * call s:LoadFTPlugin()
                            
    1              0.000005   func! s:LoadFTPlugin()
                                if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
                                let s = expand("<amatch>")
                                if s != ""
                                  if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
                                  for name in split(s, '\.')
                            	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
                                  endfor
                                endif
                              endfunc
    1              0.000003 augroup END

SCRIPT  /usr/share/vim/vim73/indent.vim
Sourced 1 time
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
                            " Vim support file to switch on loading indent files for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2008 Feb 22
                            
    1              0.000005 if exists("did_indent_on")
                              finish
                            endif
    1              0.000003 let did_indent_on = 1
                            
    1              0.000002 augroup filetypeindent
    1              0.000006   au FileType * call s:LoadIndent()
    1              0.000003   func! s:LoadIndent()
                                if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
                                let s = expand("<amatch>")
                                if s != ""
                                  if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
                                  for name in split(s, '\.')
                            	exe 'runtime! indent/' . name . '.vim'
                                  endfor
                                endif
                              endfunc
    1              0.000002 augroup END

SCRIPT  /home/joshb/.vim/colors/vividchalk.vim
Sourced 1 time
Total time:   0.002067
 Self time:   0.000923

count  total (s)   self (s)
                            " Vim color scheme
                            " Name:         vividchalk.vim
                            " Author:       Tim Pope <vimNOSPAM@tpope.info>
                            " Version:      2.0
                            " GetLatestVimScripts: 1891 1 :AutoInstall: vividchalk.vim
                            
                            " Based on the Vibrank Ink theme for TextMate
                            " Distributable under the same terms as Vim itself (see :help license)
                            
    1              0.000007 if has("gui_running")
                                set background=dark
                            endif
    1              0.000173 hi clear
    1              0.000006 if exists("syntax_on")
    1              0.000039    syntax reset
    1              0.000002 endif
                            
    1              0.000004 let colors_name = "vividchalk"
                            
                            " First two functions adapted from inkpot.vim
                            
                            " map a urxvt cube number to an xterm-256 cube number
    1              0.000003 fun! s:M(a)
                                return strpart("0245", a:a, 1) + 0
                            endfun
                            
                            " map a urxvt colour to an xterm-256 colour
    1              0.000002 fun! s:X(a)
                                if &t_Co == 88
                                    return a:a
                                else
                                    if a:a == 8
                                        return 237
                                    elseif a:a < 16
                                        return a:a
                                    elseif a:a > 79
                                        return 232 + (3 * (a:a - 80))
                                    else
                                        let l:b = a:a - 16
                                        let l:x = l:b % 4
                                        let l:y = (l:b / 4) % 4
                                        let l:z = (l:b / 16)
                                        return 16 + s:M(l:x) + (6 * s:M(l:y)) + (36 * s:M(l:z))
                                    endif
                                endif
                            endfun
                            
    1              0.000002 function! E2T(a)
                                return s:X(a:a)
                            endfunction
                            
    1              0.000002 function! s:choose(mediocre,good)
                                if &t_Co != 88 && &t_Co != 256
                                    return a:mediocre
                                else
                                    return s:X(a:good)
                                endif
                            endfunction
                            
    1              0.000003 function! s:hifg(group,guifg,first,second,...)
                                if a:0 && &t_Co == 256
                                    let ctermfg = a:1
                                else
                                    let ctermfg = s:choose(a:first,a:second)
                                endif
                                exe "highlight ".a:group." guifg=".a:guifg." ctermfg=".ctermfg
                            endfunction
                            
    1              0.000003 function! s:hibg(group,guibg,first,second)
                                let ctermbg = s:choose(a:first,a:second)
                                exe "highlight ".a:group." guibg=".a:guibg." ctermbg=".ctermbg
                            endfunction
                            
    1              0.000004 hi link railsMethod         PreProc
    1              0.000003 hi link rubyDefine          Keyword
    1              0.000003 hi link rubySymbol          Constant
    1              0.000003 hi link rubyAccess          rubyMethod
    1              0.000002 hi link rubyAttribute       rubyMethod
    1              0.000002 hi link rubyEval            rubyMethod
    1              0.000003 hi link rubyException       rubyMethod
    1              0.000002 hi link rubyInclude         rubyMethod
    1              0.000009 hi link rubyStringDelimiter rubyString
    1              0.000003 hi link rubyRegexp          Regexp
    1              0.000003 hi link rubyRegexpDelimiter rubyRegexp
                            "hi link rubyConstant        Variable
                            "hi link rubyGlobalVariable  Variable
                            "hi link rubyClassVariable   Variable
                            "hi link rubyInstanceVariable Variable
    1              0.000003 hi link javascriptRegexpString  Regexp
    1              0.000003 hi link javascriptNumber        Number
    1              0.000003 hi link javascriptNull          Constant
    1              0.000002 highlight link diffAdded        String
    1              0.000003 highlight link diffRemoved      Statement
    1              0.000003 highlight link diffLine         PreProc
    1              0.000008 highlight link diffSubname      Comment
                            
    1   0.000049   0.000014 call s:hifg("Normal","#EEEEEE","White",87)
    1              0.000005 if &background == "light" || has("gui_running")
    1              0.000011     hi Normal guibg=Black ctermbg=Black
    1              0.000002 else
                                hi Normal guibg=Black ctermbg=NONE
                            endif
    1              0.000007 highlight StatusLine    guifg=Black   guibg=#aabbee gui=bold ctermfg=Black ctermbg=White  cterm=bold
    1              0.000006 highlight StatusLineNC  guifg=#444444 guibg=#aaaaaa gui=none ctermfg=Black ctermbg=Grey   cterm=none
                            "if &t_Co == 256
                                "highlight StatusLine ctermbg=117
                            "else
                                "highlight StatusLine ctermbg=43
                            "endif
                            
    1              0.000003 highlight Ignore        ctermfg=Black
    1              0.000007 highlight WildMenu      guifg=Black   guibg=#ffff00 gui=bold ctermfg=Black ctermbg=Yellow cterm=bold
    1              0.000004 highlight Cursor        guifg=Black guibg=White ctermfg=Black ctermbg=White
    1              0.000004 highlight CursorLine    guibg=#333333 guifg=NONE
    1              0.000003 highlight CursorColumn  guibg=#333333 guifg=NONE
    1              0.000003 highlight NonText       guifg=#404040 ctermfg=8
    1              0.000004 highlight SpecialKey    guifg=#404040 ctermfg=8
    1              0.000002 highlight Directory     none
    1              0.000002 high link Directory     Identifier
    1              0.000005 highlight ErrorMsg      guibg=Red ctermbg=DarkRed guifg=NONE ctermfg=NONE
    1              0.000004 highlight Search        guifg=NONE ctermfg=NONE gui=none cterm=none
    1   0.000032   0.000008 call s:hibg("Search"    ,"#555555","DarkBlue",81)
    1              0.000005 highlight IncSearch     guifg=White guibg=Black ctermfg=White ctermbg=Black
    1              0.000005 highlight MoreMsg       guifg=#00AA00 ctermfg=Green
    1              0.000004 highlight LineNr        guifg=#DDEEFF ctermfg=White
    1   0.000029   0.000007 call s:hibg("LineNr"    ,"#222222","DarkBlue",80)
    1              0.000003 highlight Question      none
    1              0.000003 high link Question      MoreMsg
    1              0.000007 highlight Title         guifg=Magenta ctermfg=Magenta
    1              0.000003 highlight VisualNOS     gui=none cterm=none
    1   0.000030   0.000007 call s:hibg("Visual"    ,"#555577","LightBlue",83)
    1   0.000029   0.000007 call s:hibg("VisualNOS" ,"#444444","DarkBlue",81)
    1   0.000028   0.000007 call s:hibg("MatchParen","#1100AA","DarkBlue",18)
    1              0.000005 highlight WarningMsg    guifg=Red ctermfg=Red
    1              0.000002 highlight Error         ctermbg=DarkRed
    1              0.000003 highlight SpellBad      ctermbg=DarkRed
                            " FIXME: Comments
    1              0.000002 highlight SpellRare     ctermbg=DarkMagenta
    1              0.000003 highlight SpellCap      ctermbg=DarkBlue
    1              0.000002 highlight SpellLocal    ctermbg=DarkCyan
                            
    1   0.000028   0.000006 call s:hibg("Folded"    ,"#110077","DarkBlue",17)
    1   0.000035   0.000008 call s:hifg("Folded"    ,"#aaddee","LightCyan",63)
    1              0.000003 highlight FoldColumn    none
    1              0.000003 high link FoldColumn    Folded
    1              0.000003 highlight DiffAdd       ctermbg=4 guibg=DarkBlue
    1              0.000004 highlight DiffChange    ctermbg=5 guibg=DarkMagenta
    1              0.000007 highlight DiffDelete    ctermfg=12 ctermbg=6 gui=bold guifg=Blue guibg=DarkCyan
    1              0.000003 highlight DiffText      ctermbg=DarkRed
    1              0.000004 highlight DiffText      cterm=bold ctermbg=9 gui=bold guibg=Red
                            
    1              0.000005 highlight Pmenu         guifg=White ctermfg=White gui=bold cterm=bold
    1              0.000004 highlight PmenuSel      guifg=White ctermfg=White gui=bold cterm=bold
    1   0.000029   0.000007 call s:hibg("Pmenu"     ,"#000099","Blue",18)
    1   0.000028   0.000007 call s:hibg("PmenuSel"  ,"#5555ff","DarkCyan",39)
    1              0.000004 highlight PmenuSbar     guibg=Grey ctermbg=Grey
    1              0.000004 highlight PmenuThumb    guibg=White ctermbg=White
    1              0.000003 highlight TabLine       gui=underline cterm=underline
    1   0.000034   0.000008 call s:hifg("TabLine"   ,"#bbbbbb","LightGrey",85)
    1   0.000029   0.000007 call s:hibg("TabLine"   ,"#333333","DarkGrey",80)
    1              0.000006 highlight TabLineSel    guifg=White guibg=Black ctermfg=White ctermbg=Black
    1              0.000003 highlight TabLineFill   gui=underline cterm=underline
    1   0.000034   0.000007 call s:hifg("TabLineFill","#bbbbbb","LightGrey",85)
    1   0.000029   0.000007 call s:hibg("TabLineFill","#808080","Grey",83)
                            
    1              0.000003 hi Type gui=none
    1              0.000002 hi Statement gui=none
    1              0.000005 if !has("gui_mac")
                                " Mac GUI degrades italics to ugly underlining.
    1              0.000003     hi Comment gui=italic
    1              0.000003     hi railsUserClass  gui=italic
    1              0.000003     hi railsUserMethod gui=italic
    1              0.000001 endif
    1              0.000002 hi Identifier cterm=none
                            " Commented numbers at the end are *old* 256 color values
                            "highlight PreProc       guifg=#EDF8F9
    1   0.000034   0.000007 call s:hifg("Comment"        ,"#9933CC","DarkMagenta",34) " 92
                            " 26 instead?
    1   0.000032   0.000006 call s:hifg("Constant"       ,"#339999","DarkCyan",21) " 30
    1   0.000033   0.000007 call s:hifg("rubyNumber"     ,"#CCFF33","Yellow",60) " 190
    1   0.000035   0.000008 call s:hifg("String"         ,"#66FF00","LightGreen",44,82) " 82
    1   0.000033   0.000007 call s:hifg("Identifier"     ,"#FFCC00","Yellow",72) " 220
    1   0.000032   0.000006 call s:hifg("Statement"      ,"#FF6600","Brown",68) " 202
    1   0.000033   0.000007 call s:hifg("PreProc"        ,"#AAFFFF","LightCyan",47) " 213
    1   0.000032   0.000007 call s:hifg("railsUserMethod","#AACCFF","LightCyan",27)
    1   0.000033   0.000007 call s:hifg("Type"           ,"#AAAA77","Grey",57) " 101
    1   0.000032   0.000006 call s:hifg("railsUserClass" ,"#AAAAAA","Grey",7) " 101
    1   0.000033   0.000007 call s:hifg("Special"        ,"#33AA00","DarkGreen",24) " 7
    1   0.000032   0.000006 call s:hifg("Regexp"         ,"#44B4CC","DarkCyan",21) " 74
    1   0.000032   0.000007 call s:hifg("rubyMethod"     ,"#DDE93D","Yellow",77) " 191
                            "highlight railsMethod   guifg=#EE1122 ctermfg=1

SCRIPT  /home/joshb/.vim/autoload/pathogen.vim
Sourced 1 time
Total time:   0.000470
 Self time:   0.000470

count  total (s)   self (s)
                            " pathogen.vim - path option manipulation
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            " Version:      2.2
                            
                            " Install in ~/.vim/autoload (or ~\vimfiles\autoload).
                            "
                            " For management of individually installed plugins in ~/.vim/bundle (or
                            " ~\vimfiles\bundle), adding `call pathogen#infect()` to the top of your
                            " .vimrc is the only other setup necessary.
                            "
                            " The API is documented inline below.  For maximum ease of reading,
                            " :set foldmethod=marker
                            
    1              0.000011 if exists("g:loaded_pathogen") || &cp
                              finish
                            endif
    1              0.000003 let g:loaded_pathogen = 1
                            
    1              0.000003 function! s:warn(msg)
                              if &verbose
                                echohl WarningMsg
                                echomsg a:msg
                                echohl NONE
                              endif
                            endfunction
                            
                            " Point of entry for basic default usage.  Give a relative path to invoke
                            " pathogen#incubate() (defaults to "bundle/{}"), or an absolute path to invoke
                            " pathogen#surround().  For backwards compatibility purposes, a full path that
                            " does not end in {} or * is given to pathogen#runtime_prepend_subdirectories()
                            " instead.
    1              0.000003 function! pathogen#infect(...) abort " {{{1
                              for path in a:0 ? reverse(copy(a:000)) : ['bundle/{}']
                                if path =~# '^[^\\/]\+$'
                                  call s:warn('Change pathogen#infect('.string(path).') to pathogen#infect('.string(path.'/{}').')')
                                  call pathogen#incubate(path . '/{}')
                                elseif path =~# '^[^\\/]\+[\\/]\%({}\|\*\)$'
                                  call pathogen#incubate(path)
                                elseif path =~# '[\\/]\%({}\|\*\)$'
                                  call pathogen#surround(path)
                                else
                                  call s:warn('Change pathogen#infect('.string(path).') to pathogen#infect('.string(path.'/{}').')')
                                  call pathogen#surround(path . '/{}')
                                endif
                              endfor
                              call pathogen#cycle_filetype()
                              return ''
                            endfunction " }}}1
                            
                            " Split a path into a list.
    1              0.000003 function! pathogen#split(path) abort " {{{1
                              if type(a:path) == type([]) | return a:path | endif
                              let split = split(a:path,'\\\@<!\%(\\\\\)*\zs,')
                              return map(split,'substitute(v:val,''\\\([\\,]\)'',''\1'',"g")')
                            endfunction " }}}1
                            
                            " Convert a list to a path.
    1              0.000003 function! pathogen#join(...) abort " {{{1
                              if type(a:1) == type(1) && a:1
                                let i = 1
                                let space = ' '
                              else
                                let i = 0
                                let space = ''
                              endif
                              let path = ""
                              while i < a:0
                                if type(a:000[i]) == type([])
                                  let list = a:000[i]
                                  let j = 0
                                  while j < len(list)
                                    let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
                                    let path .= ',' . escaped
                                    let j += 1
                                  endwhile
                                else
                                  let path .= "," . a:000[i]
                                endif
                                let i += 1
                              endwhile
                              return substitute(path,'^,','','')
                            endfunction " }}}1
                            
                            " Convert a list to a path with escaped spaces for 'path', 'tag', etc.
    1              0.000003 function! pathogen#legacyjoin(...) abort " {{{1
                              return call('pathogen#join',[1] + a:000)
                            endfunction " }}}1
                            
                            " Remove duplicates from a list.
    1              0.000003 function! pathogen#uniq(list) abort " {{{1
                              let i = 0
                              let seen = {}
                              while i < len(a:list)
                                if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
                                  call remove(a:list,i)
                                elseif a:list[i] ==# ''
                                  let i += 1
                                  let empty = 1
                                else
                                  let seen[a:list[i]] = 1
                                  let i += 1
                                endif
                              endwhile
                              return a:list
                            endfunction " }}}1
                            
                            " \ on Windows unless shellslash is set, / everywhere else.
    1              0.000003 function! pathogen#separator() abort " {{{1
                              return !exists("+shellslash") || &shellslash ? '/' : '\'
                            endfunction " }}}1
                            
                            " Convenience wrapper around glob() which returns a list.
    1              0.000003 function! pathogen#glob(pattern) abort " {{{1
                              let files = split(glob(a:pattern),"\n")
                              return map(files,'substitute(v:val,"[".pathogen#separator()."/]$","","")')
                            endfunction "}}}1
                            
                            " Like pathogen#glob(), only limit the results to directories.
    1              0.000003 function! pathogen#glob_directories(pattern) abort " {{{1
                              return filter(pathogen#glob(a:pattern),'isdirectory(v:val)')
                            endfunction "}}}1
                            
                            " Turn filetype detection off and back on again if it was already enabled.
    1              0.000002 function! pathogen#cycle_filetype() " {{{1
                              if exists('g:did_load_filetypes')
                                filetype off
                                filetype on
                              endif
                            endfunction " }}}1
                            
                            " Check if a bundle is disabled.  A bundle is considered disabled if it ends
                            " in a tilde or its basename or full name is included in the list
                            " g:pathogen_disabled.
    1              0.000003 function! pathogen#is_disabled(path) " {{{1
                              if a:path =~# '\~$'
                                return 1
                              elseif !exists("g:pathogen_disabled")
                                return 0
                              endif
                              let sep = pathogen#separator()
                              let blacklist = g:pathogen_disabled
                              return index(blacklist, strpart(a:path, strridx(a:path, sep)+1)) != -1 && index(blacklist, a:path) != 1
                            endfunction "}}}1
                            
                            " Prepend the given directory to the runtime path and append its corresponding
                            " after directory.  If the directory is already included, move it to the
                            " outermost position.  Wildcards are added as is.  Ending a path in /{} causes
                            " all subdirectories to be added (except those in g:pathogen_disabled).
    1              0.000003 function! pathogen#surround(path) abort " {{{1
                              let sep = pathogen#separator()
                              let rtp = pathogen#split(&rtp)
                              if a:path =~# '[\\/]{}$'
                                let path = fnamemodify(a:path[0:-4], ':p:s?[\\/]\=$??')
                                let before = filter(pathogen#glob_directories(path.sep.'*'), '!pathogen#is_disabled(v:val)')
                                let after  = filter(reverse(pathogen#glob_directories(path.sep."*".sep."after")), '!pathogen#is_disabled(v:val[0:-7])')
                                call filter(rtp,'v:val[0:strlen(path)-1] !=# path')
                              else
                                let path = fnamemodify(a:path, ':p:s?[\\/]\=$??')
                                let before = [path]
                                let after = [path . sep . 'after']
                                call filter(rtp, 'index(before + after, v:val) == -1')
                              endif
                              let &rtp = pathogen#join(before, rtp, after)
                              return &rtp
                            endfunction " }}}1
                            
                            " Prepend all subdirectories of path to the rtp, and append all 'after'
                            " directories in those subdirectories.  Deprecated.
    1              0.000003 function! pathogen#runtime_prepend_subdirectories(path) " {{{1
                              call s:warn('Change pathogen#runtime_prepend_subdirectories('.string(a:path).') to pathogen#surround('.string(a:path.'/{}').')')
                              return pathogen#surround(a:path . pathogen#separator() . '{}')
                            endfunction " }}}1
                            
                            " For each directory in the runtime path, add a second entry with the given
                            " argument appended.  If the argument ends in '/{}', add a separate entry for
                            " each subdirectory.  The default argument is 'bundle/{}', which means that
                            " .vim/bundle/*, $VIM/vimfiles/bundle/*, $VIMRUNTIME/bundle/*,
                            " $VIM/vim/files/bundle/*/after, and .vim/bundle/*/after will be added (on
                            " UNIX).
    1              0.000003 function! pathogen#incubate(...) abort " {{{1
                              let sep = pathogen#separator()
                              let name = a:0 ? a:1 : 'bundle/{}'
                              if "\n".s:done_bundles =~# "\\M\n".name."\n"
                                return ""
                              endif
                              let s:done_bundles .= name . "\n"
                              let list = []
                              for dir in pathogen#split(&rtp)
                                if dir =~# '\<after$'
                                  if name =~# '{}$'
                                    let list +=  filter(pathogen#glob_directories(substitute(dir,'after$',name[0:-3],'').'*[^~]'.sep.'after'), '!pathogen#is_disabled(v:val[0:-7])') + [dir]
                                  else
                                    let list += [dir, substitute(dir, 'after$', '', '') . name . sep . 'after']
                                  endif
                                else
                                  if name =~# '{}$'
                                    let list +=  [dir] + filter(pathogen#glob_directories(dir.sep.name[0:-3].'*[^~]'), '!pathogen#is_disabled(v:val)')
                                  else
                                    let list += [dir . sep . name, dir]
                                  endif
                                endif
                              endfor
                              let &rtp = pathogen#join(pathogen#uniq(list))
                              return 1
                            endfunction " }}}1
                            
                            " Deprecated alias for pathogen#incubate().
    1              0.000004 function! pathogen#runtime_append_all_bundles(...) abort " {{{1
                              if a:0
                                call s:warn('Change pathogen#runtime_append_all_bundles('.string(a:1).') to pathogen#incubate('.string(a:1.'/{}').')')
                              else
                                call s:warn('Change pathogen#runtime_append_all_bundles() to pathogen#incubate()')
                              endif
                              return call('pathogen#incubate', map(copy(a:000),'v:val . "/{}"'))
                            endfunction
                            
    1              0.000003 let s:done_bundles = ''
                            " }}}1
                            
                            " Invoke :helptags on all non-$VIM doc directories in runtimepath.
    1              0.000002 function! pathogen#helptags() abort " {{{1
                              let sep = pathogen#separator()
                              for glob in pathogen#split(&rtp)
                                for dir in split(glob(glob), "\n")
                                  if (dir.sep)[0 : strlen($VIMRUNTIME)] !=# $VIMRUNTIME.sep && filewritable(dir.sep.'doc') == 2 && !empty(filter(split(glob(dir.sep.'doc'.sep.'*'),"\n>"),'!isdirectory(v:val)')) && (!filereadable(dir.sep.'doc'.sep.'tags') || filewritable(dir.sep.'doc'.sep.'tags'))
                                    helptags `=dir.'/doc'`
                                  endif
                                endfor
                              endfor
                            endfunction " }}}1
                            
    1              0.000009 command! -bar Helptags :call pathogen#helptags()
                            
                            " Execute the given command.  This is basically a backdoor for --remote-expr.
    1              0.000003 function! pathogen#execute(...) abort " {{{1
                              for command in a:000
                                execute command
                              endfor
                              return ''
                            endfunction " }}}1
                            
                            " Like findfile(), but hardcoded to use the runtimepath.
    1              0.000003 function! pathogen#runtime_findfile(file,count) abort "{{{1
                              let rtp = pathogen#join(1,pathogen#split(&rtp))
                              let file = findfile(a:file,rtp,a:count)
                              if file ==# ''
                                return ''
                              else
                                return fnamemodify(file,':p')
                              endif
                            endfunction " }}}1
                            
                            " Backport of fnameescape().
    1              0.000003 function! pathogen#fnameescape(string) abort " {{{1
                              if exists('*fnameescape')
                                return fnameescape(a:string)
                              elseif a:string ==# '-'
                                return '\-'
                              else
                                return substitute(escape(a:string," \t\n*?[{`$\\%#'\"|!<"),'^[+>]','\\&','')
                              endif
                            endfunction " }}}1
                            
    1              0.000004 if exists(':Vedit')
                              finish
                            endif
                            
    1              0.000003 let s:vopen_warning = 0
                            
    1              0.000003 function! s:find(count,cmd,file,lcd) " {{{1
                              let rtp = pathogen#join(1,pathogen#split(&runtimepath))
                              let file = pathogen#runtime_findfile(a:file,a:count)
                              if file ==# ''
                                return "echoerr 'E345: Can''t find file \"".a:file."\" in runtimepath'"
                              endif
                              if !s:vopen_warning
                                let s:vopen_warning = 1
                                let warning = '|echohl WarningMsg|echo "Install scriptease.vim to continue using :V'.a:cmd.'"|echohl NONE'
                              else
                                let warning = ''
                              endif
                              if a:lcd
                                let path = file[0:-strlen(a:file)-2]
                                execute 'lcd `=path`'
                                return a:cmd.' '.pathogen#fnameescape(a:file) . warning
                              else
                                return a:cmd.' '.pathogen#fnameescape(file) . warning
                              endif
                            endfunction " }}}1
                            
    1              0.000003 function! s:Findcomplete(A,L,P) " {{{1
                              let sep = pathogen#separator()
                              let cheats = {
                                    \'a': 'autoload',
                                    \'d': 'doc',
                                    \'f': 'ftplugin',
                                    \'i': 'indent',
                                    \'p': 'plugin',
                                    \'s': 'syntax'}
                              if a:A =~# '^\w[\\/]' && has_key(cheats,a:A[0])
                                let request = cheats[a:A[0]].a:A[1:-1]
                              else
                                let request = a:A
                              endif
                              let pattern = substitute(request,'/\|\'.sep,'*'.sep,'g').'*'
                              let found = {}
                              for path in pathogen#split(&runtimepath)
                                let path = expand(path, ':p')
                                let matches = split(glob(path.sep.pattern),"\n")
                                call map(matches,'isdirectory(v:val) ? v:val.sep : v:val')
                                call map(matches,'expand(v:val, ":p")[strlen(path)+1:-1]')
                                for match in matches
                                  let found[match] = 1
                                endfor
                              endfor
                              return sort(keys(found))
                            endfunction " }}}1
                            
    1              0.000017 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Ve       :execute s:find(<count>,'edit<bang>',<q-args>,0)
    1              0.000014 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vedit    :execute s:find(<count>,'edit<bang>',<q-args>,0)
    1              0.000014 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vopen    :execute s:find(<count>,'edit<bang>',<q-args>,1)
    1              0.000015 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vsplit   :execute s:find(<count>,'split',<q-args>,<bang>1)
    1              0.000014 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vvsplit  :execute s:find(<count>,'vsplit',<q-args>,<bang>1)
    1              0.000014 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vtabedit :execute s:find(<count>,'tabedit',<q-args>,<bang>1)
    1              0.000014 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vpedit   :execute s:find(<count>,'pedit',<q-args>,<bang>1)
    1              0.000014 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vread    :execute s:find(<count>,'read',<q-args>,<bang>1)
                            
                            " vim:set et sw=2:

SCRIPT  /home/joshb/.vim/plugin/mru.vim
Sourced 1 time
Total time:   0.001539
 Self time:   0.001041

count  total (s)   self (s)
                            " File: mru.vim
                            " Author: Yegappan Lakshmanan (yegappan AT yahoo DOT com)
                            " Version: 3.4
                            " Last Modified: April 13, 2012
                            " Copyright: Copyright (C) 2003-2012 Yegappan Lakshmanan
                            "            Permission is hereby granted to use and distribute this code,
                            "            with or without modifications, provided that this copyright
                            "            notice is copied with it. Like anything else that's free,
                            "            mru.vim is provided *as is* and comes with no warranty of any
                            "            kind, either expressed or implied. In no event will the copyright
                            "            holder be liable for any damamges resulting from the use of this
                            "            software.
                            "
                            " Overview
                            " --------
                            " The Most Recently Used (MRU) plugin provides an easy access to a list of
                            " recently opened/edited files in Vim. This plugin automatically stores the
                            " file names as you open/edit them in Vim.
                            "
                            " This plugin will work on all the platforms where Vim is supported. This
                            " plugin will work in both console and GUI Vim. This version of the MRU
                            " plugin needs Vim 7.0 and above. If you are using an earlier version of
                            " Vim, then you should use an older version of the MRU plugin.
                            "
                            " The recently used filenames are stored in a file specified by the Vim
                            " MRU_File variable.
                            "
                            " Installation
                            " ------------
                            " 1. Copy the mru.vim file to one of the following directories:
                            "
                            "       $HOME/.vim/plugin     - Unix like systems
                            "       $HOME/vimfiles/plugin - MS-Windows
                            "       $VIM:vimfiles:plugin  - Macintosh
                            "       $VIM/vimfiles/plugin  - All
                            "
                            "    Refer to the following Vim help topics for more information about Vim
                            "    plugins:
                            "
                            "       :help add-plugin
                            "       :help add-global-plugin
                            "       :help runtimepath
                            "
                            " 2. Set the MRU_File Vim variable in the .vimrc file to the location of a
                            "    file to store the most recently edited file names. This step is needed
                            "    only if you want to change the default MRU filename.
                            " 3. Restart Vim.
                            " 4. You can use the ":MRU" command to list and edit the recently used files.
                            "    In GUI Vim, you can use the 'File->Recent Files' menu to access the
                            "    recently used files.
                            "
                            " To uninstall this plugin, remove this file (mru.vim) from the
                            " $HOME/.vim/plugin or $HOME/vimfiles/plugin or the $VIM/vimfile/plugin
                            " directory.
                            "
                            " Usage
                            " -----
                            " To list and edit files from the MRU list, you can use the ":MRU" command.
                            " The ":MRU" command displays the MRU file list in a temporary Vim window.  If
                            " the MRU window is already opened, then the MRU list displayed in the window
                            " is refreshed.
                            "
                            " If you are using GUI Vim, then the names of the recently edited files are
                            " added to the "File->Recent Files" menu. You can select the name of a file
                            " from this sub-menu to edit the file.
                            "
                            " You can use the normal Vim commands to move around in the MRU window. You
                            " cannot make changes in the MRU window.
                            "
                            " You can select a file name to edit by pressing the <Enter> key or by double
                            " clicking the left mouse button on a file name.  The selected file will be
                            " opened. If the file is already opened in a window, the cursor will be moved
                            " to that window. Otherwise, the file is opened in the previous window. If the
                            " previous window has a modified buffer or is the preview window or is used by
                            " some other plugin, then the file is opened in a new window.
                            "
                            " You can press the 'o' key to open the file name under the cursor in the
                            " MRU window in a new window.
                            "
                            " To open a file from the MRU window in read-only mode (view), press the 'v'
                            " key.
                            "
                            " To open a file from the MRU window in a new tab, press the 't' key.  If the
                            " file is already opened in a window in the current or in another tab, then
                            " the cursor is moved to that tab. Otherwise, a new tab is opened.
                            "
                            " You can open multiple files from the MRU window by specifying a count before
                            " pressing '<Enter>' or 'v' or 'o' or 't'. You can also visually select
                            " multiple filenames and invoke the commands to open the files. Each selected
                            " file will be opened in a separate window or tab.
                            "
                            " You can press the 'u' key in the MRU window to update the file list. This is
                            " useful if you keep the MRU window open always.
                            "
                            " You can close the MRU window by pressing the 'q' key or using one of the Vim
                            " window commands.
                            "
                            " To display only files matching a pattern from the MRU list in the MRU
                            " window, you can specify a pattern to the ":MRU" command. For example, to
                            " display only file names matching "vim" in them, you can use the following
                            " command ":MRU vim".  When you specify a partial file name and only one
                            " matching filename is found, then the ":MRU" command will edit that file.
                            "
                            " The ":MRU" command supports command-line completion of file names from
                            " the MRU list. You can enter a partial file name and then press <Tab>
                            " or <Ctrl-D> to complete or list all the matching file names. Note that
                            " after typing the ":MRU" command, you have to enter a space before completing
                            " the file names with <Tab>.
                            "
                            " When a file supplied to the ":MRU" command is not present in the MRU list,
                            " but it is a readable file, then the file will be opened (even though it is
                            " not present in the MRU list). This is useful if you want to open a file
                            " present in the same directory as a file in the MRU list. You can use the
                            " command-line completion of the ":MRU" command to complete the full path of a
                            " file and then modify the path to open another file present in the same path.
                            "
                            " Whenever the MRU list changes, the MRU file is updated with the latest MRU
                            " list. When you have multiple instances of Vim running at the same time, the
                            " latest MRU list will show up in all the instances of Vim.
                            "
                            " Configuration
                            " -------------
                            " By changing the following variables you can configure the behavior of this
                            " plugin. Set the following variables in your .vimrc file using the 'let'
                            " command.
                            "
                            " The list of recently edited file names is stored in the file specified by the
                            " MRU_File variable.  The default setting for this variable is
                            " $HOME/.vim_mru_files for Unix-like systems and $USERPROFILE/_vim_mru_files
                            " for MS-Windows systems. You can change this variable to point to a file by
                            " adding the following line to the .vimrc file:
                            "
                            "       let MRU_File = 'd:\myhome\_vim_mru_files'
                            "
                            " By default, the plugin will remember the names of the last 100 used files.
                            " As you edit more files, old file names will be removed from the MRU list.
                            " You can set the 'MRU_Max_Entries' variable to remember more file names. For
                            " example, to remember 1000 most recently used file names, you can use
                            "
                            "       let MRU_Max_Entries = 1000
                            "
                            " By default, all the edited file names will be added to the MRU list. If you
                            " want to exclude file names matching a list of patterns, you can set the
                            " MRU_Exclude_Files variable to a list of Vim regular expressions. By default,
                            " this variable is set to an empty string. For example, to not include files
                            " in the temporary (/tmp, /var/tmp and d:\temp) directories, you can set the
                            " MRU_Exclude_Files variable to
                            "
                            "       let MRU_Exclude_Files = '^/tmp/.*\|^/var/tmp/.*'  " For Unix
                            "       let MRU_Exclude_Files = '^c:\\temp\\.*'           " For MS-Windows
                            " 
                            " The specified pattern should be a Vim regular expression pattern.
                            "
                            " If you want to add only file names matching a set of patterns to the MRU
                            " list, then you can set the MRU_Include_Files variable. This variable should
                            " be set to a Vim regular expression pattern. For example, to add only .c and
                            " .h files to the MRU list, you can set this variable as below:
                            "
                            "       let MRU_Include_Files = '\.c$\|\.h$'
                            "
                            " By default, MRU_Include_Files is set to an empty string and all the edited
                            " filenames are added to the MRU list.
                            "
                            " The default height of the MRU window is 8. You can set the MRU_Window_Height
                            " variable to change the window height.
                            "
                            "       let MRU_Window_Height = 15
                            "
                            " By default, when the :MRU command is invoked, the MRU list will be displayed
                            " in a new window. Instead, if you want the MRU plugin to reuse the current
                            " window, then you can set the 'MRU_Use_Current_Window' variable to one.
                            "
                            "       let MRU_Use_Current_Window = 1
                            "
                            " The MRU plugin will reuse the current window. When a file name is selected,
                            " the file is also opened in the current window.
                            "
                            " When you select a file from the MRU window, the MRU window will be
                            " automatically closed and the selected file will be opened in the previous
                            " window. You can set the 'MRU_Auto_Close' variable to zero to keep the MRU
                            " window open.
                            "
                            "       let MRU_Auto_Close = 0
                            "
                            " If you don't use the "File->Recent Files" menu and want to disable it,
                            " then you can set the 'MRU_Add_Menu' variable to zero. By default, the
                            " menu is enabled.
                            "
                            "       let MRU_Add_Menu = 0
                            "
                            " If too many file names are present in the MRU list, then updating the MRU
                            " menu to list all the file names makes Vim slow. To avoid this, the
                            " MRU_Max_Menu_Entries variable controls the number of file names to show in
                            " the MRU menu. By default, this is set to 10. You can change this to show
                            " more entries in the menu.
                            "
                            "       let MRU_Max_Menu_Entries = 20
                            "
                            " If many file names are present in the MRU list, then the MRU menu is split
                            " into sub-menus. Each sub-menu contains MRU_Max_Submenu_Entries file names.
                            " The default setting for this is 10. You can change this to increase the
                            " number of file names displayed in a single sub-menu:
                            "
                            "       let MRU_Max_Submenu_Entries = 15
                            "
                            " ****************** Do not modify after this line ************************
    1              0.000005 if exists('loaded_mru')
                                finish
                            endif
    1              0.000002 let loaded_mru=1
                            
    1              0.000002 if v:version < 700
                                finish
                            endif
                            
                            " Line continuation used here
    1              0.000009 let s:cpo_save = &cpo
    1              0.000010 set cpo&vim
                            
                            " MRU configuration variables {{{1
                            " Maximum number of entries allowed in the MRU list
    1              0.000004 if !exists('MRU_Max_Entries')
                                let MRU_Max_Entries = 100
                            endif
                            
                            " Files to exclude from the MRU list
    1              0.000003 if !exists('MRU_Exclude_Files')
    1              0.000003     let MRU_Exclude_Files = ''
    1              0.000001 endif
                            
                            " Files to include in the MRU list
    1              0.000003 if !exists('MRU_Include_Files')
    1              0.000003     let MRU_Include_Files = ''
    1              0.000001 endif
                            
                            " Height of the MRU window
                            " Default height is 8
    1              0.000003 if !exists('MRU_Window_Height')
    1              0.000003     let MRU_Window_Height = 8
    1              0.000001 endif
                            
    1              0.000003 if !exists('MRU_Use_Current_Window')
    1              0.000003     let MRU_Use_Current_Window = 0
    1              0.000001 endif
                            
    1              0.000002 if !exists('MRU_Auto_Close')
    1              0.000002     let MRU_Auto_Close = 1
    1              0.000001 endif
                            
    1              0.000003 if !exists('MRU_File')
    1              0.000003     if has('unix') || has('macunix')
    1              0.000005         let MRU_File = $HOME . '/.vim_mru_files'
    1              0.000001     else
                                    let MRU_File = $VIM . '/_vim_mru_files'
                                    if has('win32')
                                        " MS-Windows
                                        if $USERPROFILE != ''
                                            let MRU_File = $USERPROFILE . '\_vim_mru_files'
                                        endif
                                    endif
                                endif
    1              0.000001 endif
                            
                            " Option for enabling or disabling the MRU menu
    1              0.000003 if !exists('MRU_Add_Menu')
    1              0.000002     let MRU_Add_Menu = 1
    1              0.000001 endif
                            
                            " Maximum number of file names to show in the MRU menu. If too many files are
                            " listed in the menu, then Vim becomes slow when updating the menu. So set
                            " this to a low value.
    1              0.000003 if !exists('MRU_Max_Menu_Entries')
    1              0.000003     let MRU_Max_Menu_Entries = 10
    1              0.000001 endif
                            
                            " Maximum number of file names to show in a MRU sub-menu. If the MRU list
                            " contains more file names than this setting, then the MRU menu is split into
                            " one or more sub-menus.
    1              0.000003 if !exists('MRU_Max_Submenu_Entries')
    1              0.000003     let MRU_Max_Submenu_Entries = 10
    1              0.000001 endif
                            
                            " When only a single matching filename is found in the MRU list, the following
                            " option controls whether the file name is displayed in the MRU window or the
                            " file is directly opened. When this variable is set to 0 and a single
                            " matching file name is found, then the file is directly opened.
    1              0.000003 if !exists('MRU_Window_Open_Always')
    1              0.000003     let MRU_Window_Open_Always = 0
    1              0.000001 endif
                            
                            " When opening a file from the MRU list, the file is opened in the current
                            " tab. If the selected file has to be opened in a tab always, then set the
                            " following variable to 1. If the file is already opened in a tab, then the
                            " cursor will be moved to that tab.
    1              0.000003 if !exists('MRU_Open_File_Use_Tabs')
    1              0.000003     let MRU_Open_File_Use_Tabs = 0
    1              0.000001 endif
                            
                            " Control to temporarily lock the MRU list. Used to prevent files from
                            " getting added to the MRU list when the ':vimgrep' command is executed.
    1              0.000003 let s:mru_list_locked = 0
                            
                            " MRU_LoadList                          {{{1
                            " Loads the latest list of file names from the MRU file
    1              0.000004 function! s:MRU_LoadList()
                                " If the MRU file is present, then load the list of filenames. Otherwise
                                " start with an empty list.
                                if filereadable(g:MRU_File)
                                    let s:MRU_files = readfile(g:MRU_File)
                                    if s:MRU_files[0] =~# '^\s*" Most recently edited files in Vim'
                                        " Generated by the previous version of the MRU plugin.
                                        " Discard the list.
                                        let s:MRU_files = []
                                    elseif s:MRU_files[0] =~# '^#'
                                        " Remove the comment line
                                        call remove(s:MRU_files, 0)
                                    else
                                        " Unsupported format
                                        let s:MRU_files = []
                                    endif
                                else
                                    let s:MRU_files = []
                                endif
                            
                                " Refresh the MRU menu with the latest list of filenames
                                call s:MRU_Refresh_Menu()
                            endfunction
                            
                            " MRU_SaveList                          {{{1
                            " Saves the MRU file names to the MRU file
    1              0.000002 function! s:MRU_SaveList()
                                let l = []
                                call add(l, '# Most recently edited files in Vim (version 3.0)')
                                call extend(l, s:MRU_files)
                                call writefile(l, g:MRU_File)
                            endfunction
                            
                            " MRU_AddFile                           {{{1
                            " Adds a file to the MRU file list
                            "   acmd_bufnr - Buffer number of the file to add
    1              0.000002 function! s:MRU_AddFile(acmd_bufnr)
                                if s:mru_list_locked
                                    " MRU list is currently locked
                                    return
                                endif
                            
                                " Get the full path to the filename
                                let fname = fnamemodify(bufname(a:acmd_bufnr + 0), ':p')
                                if fname == ''
                                    return
                                endif
                            
                                " Skip temporary buffers with buftype set. The buftype is set for buffers
                                " used by plugins.
                                if &buftype != ''
                                    return
                                endif
                            
                                if g:MRU_Include_Files != ''
                                    " If MRU_Include_Files is set, include only files matching the
                                    " specified pattern
                                    if fname !~# g:MRU_Include_Files
                                        return
                                    endif
                                endif
                            
                                if g:MRU_Exclude_Files != ''
                                    " Do not add files matching the pattern specified in the
                                    " MRU_Exclude_Files to the MRU list
                                    if fname =~# g:MRU_Exclude_Files
                                        return
                                    endif
                                endif
                            
                                " If the filename is not already present in the MRU list and is not
                                " readable then ignore it
                                let idx = index(s:MRU_files, fname)
                                if idx == -1
                                    if !filereadable(fname)
                                        " File is not readable and is not in the MRU list
                                        return
                                    endif
                                endif
                            
                                " Load the latest MRU file list
                                call s:MRU_LoadList()
                            
                                " Remove the new file name from the existing MRU list (if already present)
                                call filter(s:MRU_files, 'v:val !=# fname')
                            
                                " Add the new file list to the beginning of the updated old file list
                                call insert(s:MRU_files, fname, 0)
                            
                                " Trim the list
                                if len(s:MRU_files) > g:MRU_Max_Entries
                                    call remove(s:MRU_files, g:MRU_Max_Entries, -1)
                                endif
                            
                                " Save the updated MRU list
                                call s:MRU_SaveList()
                            
                                " Refresh the MRU menu
                                call s:MRU_Refresh_Menu()
                            
                                " If the MRU window is open, update the displayed MRU list
                                let bname = '__MRU_Files__'
                                let winnum = bufwinnr(bname)
                                if winnum != -1
                                    let cur_winnr = winnr()
                                    call s:MRU_Open_Window()
                                    if winnr() != cur_winnr
                                        exe cur_winnr . 'wincmd w'
                                    endif
                                endif
                            endfunction
                            
                            " MRU_escape_filename                   {{{1
                            " Escape special characters in a filename. Special characters in file names
                            " that should be escaped (for security reasons)
    1              0.000005 let s:esc_filename_chars = ' *?[{`$%#"|!<>();&' . "'\t\n"
    1              0.000003 function! s:MRU_escape_filename(fname)
                                return escape(a:fname, s:esc_filename_chars)
                            endfunction
                            
                            " MRU_Edit_File                         {{{1
                            " Edit the specified file
                            "   filename - Name of the file to edit
                            "   sanitized - Specifies whether the filename is already escaped for special
                            "   characters or not.
    1              0.000002 function! s:MRU_Edit_File(filename, sanitized)
                                if !a:sanitized
                            	let esc_fname = s:MRU_escape_filename(a:filename)
                                else
                            	let esc_fname = a:filename
                                endif
                            
                                " If the user wants to always open the file in a tab, then open the file
                                " in a tab. If it is already opened in a tab, then the cursor will be
                                " moved to that tab.
                                if g:MRU_Open_File_Use_Tabs
                            	call s:MRU_Open_File_In_Tab(a:filename, esc_fname)
                            	return
                                endif
                            
                                " If the file is already open in one of the windows, jump to it
                                let winnum = bufwinnr('^' . a:filename . '$')
                                if winnum != -1
                                    if winnum != winnr()
                                        exe winnum . 'wincmd w'
                                    endif
                                else
                                    if &modified || &buftype != '' || &previewwindow
                                        " Current buffer has unsaved changes or is a special buffer or is
                                        " the preview window.  So open the file in a new window
                                        exe 'split ' . esc_fname
                                    else
                                        exe 'edit ' . esc_fname
                                    endif
                                endif
                            endfunction
                            
                            " MRU_Open_File_In_Tab
                            " Open a file in a tab. If the file is already opened in a tab, jump to the
                            " tab. Otherwise, create a new tab and open the file.
                            "   fname     : Name of the file to open
                            "   esc_fname : File name with special characters escaped
    1              0.000004 function! s:MRU_Open_File_In_Tab(fname, esc_fname)
                                " If the selected file is already open in the current tab or in
                                " another tab, jump to it. Otherwise open it in a new tab
                                if bufwinnr('^' . a:fname . '$') == -1
                            	let tabnum = -1
                            	let i = 1
                            	let bnum = bufnr('^' . a:fname . '$')
                            	while i <= tabpagenr('$')
                            	    if index(tabpagebuflist(i), bnum) != -1
                            		let tabnum = i
                            		break
                            	    endif
                            	    let i += 1
                            	endwhile
                            
                            	if tabnum != -1
                            	    " Goto the tab containing the file
                            	    exe 'tabnext ' . i
                            	else
                            	    " Open a new tab as the last tab page
                            	    exe '999tabnew ' . a:esc_fname
                            	endif
                                endif
                            
                                " Jump to the window containing the file
                                let winnum = bufwinnr('^' . a:fname . '$')
                                if winnum != winnr()
                            	exe winnum . 'wincmd w'
                                endif
                            endfunction
                            
                            " MRU_Window_Edit_File                  {{{1
                            "   fname     : Name of the file to edit. May specify single or multiple
                            "               files.
                            "   edit_type : Specifies how to edit the file. Can be one of 'edit' or 'view'.
                            "               'view' - Open the file as a read-only file
                            "               'edit' - Edit the file as a regular file
                            "   multi     : Specifies  whether a single file or multiple files need to be
                            "               opened.
                            "   open_type : Specifies where to open the file. Can be one of 'useopen' or
                            "               'newwin' or 'newtab'.
                            "               useopen - If the file is already present in a window, then
                            "                         jump to that window.  Otherwise, open the file in
                            "                         the previous window.
                            "               newwin_horiz - Open the file in a new horizontal window.
                            "               newwin_vert - Open the file in a new vertical window.
                            "               newtab  - Open the file in a new tab. If the file is already
                            "                         opened in a tab, then jump to that tab.
    1              0.000004 function! s:MRU_Window_Edit_File(fname, multi, edit_type, open_type)
                                let esc_fname = s:MRU_escape_filename(a:fname)
                            
                                if a:open_type == 'newwin_horiz'
                                    " Edit the file in a new horizontally split window above the previous
                                    " window
                                    wincmd p
                                    exe 'belowright new ' . esc_fname
                                elseif a:open_type == 'newwin_vert'
                                    " Edit the file in a new vertically split window above the previous
                                    " window
                                    wincmd p
                                    exe 'belowright vnew ' . esc_fname
                                elseif a:open_type == 'newtab' || g:MRU_Open_File_Use_Tabs
                            	call s:MRU_Open_File_In_Tab(a:fname, esc_fname)
                                else
                                    " If the selected file is already open in one of the windows,
                                    " jump to it
                                    let winnum = bufwinnr('^' . a:fname . '$')
                                    if winnum != -1
                                        exe winnum . 'wincmd w'
                                    else
                                        if g:MRU_Auto_Close == 1 && g:MRU_Use_Current_Window == 0
                                            " Jump to the window from which the MRU window was opened
                                            if exists('s:MRU_last_buffer')
                                                let last_winnr = bufwinnr(s:MRU_last_buffer)
                                                if last_winnr != -1 && last_winnr != winnr()
                                                    exe last_winnr . 'wincmd w'
                                                endif
                                            endif
                                        else
                                            if g:MRU_Use_Current_Window == 0
                                                " Goto the previous window
                                                " If MRU_Use_Current_Window is set to one, then the
                                                " current window is used to open the file
                                                wincmd p
                                            endif
                                        endif
                            
                                        let split_window = 0
                            
                                        if &modified || &previewwindow || a:multi
                                            " Current buffer has unsaved changes or is the preview window
                                            " or the user is opening multiple files
                                            " So open the file in a new window
                                            let split_window = 1
                                        endif
                            
                                        if &buftype != ''
                                            " Current buffer is a special buffer (maybe used by a plugin)
                                            if g:MRU_Use_Current_Window == 0 ||
                                                        \ bufnr('%') != bufnr('__MRU_Files__')
                                                let split_window = 1
                                            endif
                                        endif
                            
                                        " Edit the file
                                        if split_window
                                            " Current buffer has unsaved changes or is a special buffer or
                                            " is the preview window.  So open the file in a new window
                                            if a:edit_type == 'edit'
                                                exe 'split ' . esc_fname
                                            else
                                                exe 'sview ' . esc_fname
                                            endif
                                        else
                                            if a:edit_type == 'edit'
                                                exe 'edit ' . esc_fname
                                            else
                                                exe 'view ' . esc_fname
                                            endif
                                        endif
                                    endif
                                endif
                            endfunction
                            
                            " MRU_Select_File_Cmd                   {{{1
                            " Open a file selected from the MRU window
                            "
                            "   'opt' has two values separated by comma. The first value specifies how to
                            "   edit the file  and can be either 'edit' or 'view'. The second value
                            "   specifies where to open the file. It can take one of the following values:
                            "     'useopen' to open file in the previous window
                            "     'newwin_horiz' to open the file in a new horizontal split window
                            "     'newwin_vert' to open the file in a new vertical split window.
                            "     'newtab' to open the file in a new tab.
                            " If multiple file names are selected using visual mode, then open multiple
                            " files (either in split windows or tabs)
    1              0.000004 function! s:MRU_Select_File_Cmd(opt) range
                                let [edit_type, open_type] = split(a:opt, ',')
                            
                                let fnames = getline(a:firstline, a:lastline)
                            
                                if g:MRU_Auto_Close == 1 && g:MRU_Use_Current_Window == 0
                                    " Automatically close the window if the file window is
                                    " not used to display the MRU list.
                                    silent! close
                                endif
                            
                                let multi = 0
                            
                                for f in fnames
                                    if f == ''
                                        continue
                                    endif
                            
                                    " The text in the MRU window contains the filename in parenthesis
                                    let file = matchstr(f, '(\zs.*\ze)')
                            
                                    call s:MRU_Window_Edit_File(file, multi, edit_type, open_type)
                            
                                    if a:firstline != a:lastline
                                        " Opening multiple files
                                        let multi = 1
                                    endif
                                endfor
                            endfunction
                            
                            " MRU_Warn_Msg                          {{{1
                            " Display a warning message
    1              0.000003 function! s:MRU_Warn_Msg(msg)
                                echohl WarningMsg
                                echo a:msg
                                echohl None
                            endfunction
                            
                            " MRU_Open_Window                       {{{1
                            " Display the Most Recently Used file list in a temporary window.
                            " If the optional argument is supplied, then it specifies the pattern of files
                            " to selectively display in the MRU window.
    1              0.000002 function! s:MRU_Open_Window(...)
                            
                                " Load the latest MRU file list
                                call s:MRU_LoadList()
                            
                                " Check for empty MRU list
                                if empty(s:MRU_files)
                                    call s:MRU_Warn_Msg('MRU file list is empty')
                                    return
                                endif
                            
                                " Save the current buffer number. This is used later to open a file when a
                                " entry is selected from the MRU window. The window number is not saved,
                                " as the window number will change when new windows are opened.
                                let s:MRU_last_buffer = bufnr('%')
                            
                                let bname = '__MRU_Files__'
                            
                                " If the window is already open, jump to it
                                let winnum = bufwinnr(bname)
                                if winnum != -1
                                    if winnr() != winnum
                                        " If not already in the window, jump to it
                                        exe winnum . 'wincmd w'
                                    endif
                            
                                    setlocal modifiable
                            
                                    " Delete the contents of the buffer to the black-hole register
                                    silent! %delete _
                                else
                                    if g:MRU_Use_Current_Window
                                        " Reuse the current window
                                        "
                                        " If the __MRU_Files__ buffer exists, then reuse it. Otherwise open
                                        " a new buffer
                                        let bufnum = bufnr(bname)
                                        if bufnum == -1
                                            let cmd = 'edit ' . bname
                                        else
                                            let cmd = 'buffer ' . bufnum
                                        endif
                            
                                        exe cmd
                            
                                        if bufnr('%') != bufnr(bname)
                                            " Failed to edit the MRU buffer
                                            return
                                        endif
                                    else
                                        " Open a new window at the bottom
                            
                                        " If the __MRU_Files__ buffer exists, then reuse it. Otherwise open
                                        " a new buffer
                                        let bufnum = bufnr(bname)
                                        if bufnum == -1
                                            let wcmd = bname
                                        else
                                            let wcmd = '+buffer' . bufnum
                                        endif
                            
                                        exe 'silent! botright ' . g:MRU_Window_Height . 'split ' . wcmd
                                    endif
                                endif
                            
                                " Mark the buffer as scratch
                                setlocal buftype=nofile
                                setlocal bufhidden=delete
                                setlocal noswapfile
                                setlocal nowrap
                                setlocal nobuflisted
                                " Use fixed height for the MRU window
                                setlocal winfixheight
                            
                                " Setup the cpoptions properly for the maps to work
                                let old_cpoptions = &cpoptions
                                set cpoptions&vim
                            
                                " Create mappings to select and edit a file from the MRU list
                                nnoremap <buffer> <silent> <CR>
                                            \ :call <SID>MRU_Select_File_Cmd('edit,useopen')<CR>
                                vnoremap <buffer> <silent> <CR>
                                            \ :call <SID>MRU_Select_File_Cmd('edit,useopen')<CR>
                                nnoremap <buffer> <silent> o
                                            \ :call <SID>MRU_Select_File_Cmd('edit,newwin_horiz')<CR>
                                vnoremap <buffer> <silent> o
                                            \ :call <SID>MRU_Select_File_Cmd('edit,newwin_horiz')<CR>
                                nnoremap <buffer> <silent> O
                                            \ :call <SID>MRU_Select_File_Cmd('edit,newwin_vert')<CR>
                                vnoremap <buffer> <silent> O
                                            \ :call <SID>MRU_Select_File_Cmd('edit,newwin_vert')<CR>
                                nnoremap <buffer> <silent> t
                                            \ :call <SID>MRU_Select_File_Cmd('edit,newtab')<CR>
                                vnoremap <buffer> <silent> t
                                            \ :call <SID>MRU_Select_File_Cmd('edit,newtab')<CR>
                                nnoremap <buffer> <silent> v
                                            \ :call <SID>MRU_Select_File_Cmd('view,useopen')<CR>
                                nnoremap <buffer> <silent> u :MRU<CR>
                                nnoremap <buffer> <silent> <2-LeftMouse>
                                            \ :call <SID>MRU_Select_File_Cmd('edit,useopen')<CR>
                                nnoremap <buffer> <silent> q :close<CR>
                            
                                " Restore the previous cpoptions settings
                                let &cpoptions = old_cpoptions
                            
                                " Display the MRU list
                                if a:0 == 0
                                    " No search pattern specified. Display the complete list
                                    let m = copy(s:MRU_files)
                                else
                                    " Display only the entries matching the specified pattern
                            	" First try using it as a literal pattern
                            	let m = filter(copy(s:MRU_files), 'stridx(v:val, a:1) != -1')
                            	if len(m) == 0
                            	    " No match. Try using it as a regular expression
                            	    let m = filter(copy(s:MRU_files), 'v:val =~# a:1')
                            	endif
                                endif
                            
                                " Get the tail part of the file name (without the directory) and display
                                " it along with the full path
                                let  output = map(m, 'fnamemodify(v:val, ":t") . " (" . v:val . ")"')
                                silent! 0put =output
                            
                                " Delete the empty line at the end of the buffer
                                $delete
                            
                                " Move the cursor to the beginning of the file
                                normal! gg
                            
                                setlocal nomodifiable
                            endfunction
                            
                            " MRU_Complete                          {{{1
                            " Command-line completion function used by :MRU command
    1              0.000004 function! s:MRU_Complete(ArgLead, CmdLine, CursorPos)
                                if a:ArgLead == ''
                                    " Return the complete list of MRU files
                                    return s:MRU_files
                                else
                                    " Return only the files matching the specified pattern
                                    return filter(copy(s:MRU_files), 'v:val =~? a:ArgLead')
                                endif
                            endfunction
                            
                            " MRU_Cmd                               {{{1
                            " Function to handle the MRU command
                            "   pat - File name pattern passed to the MRU command
    1              0.000003 function! s:MRU_Cmd(pat)
                                if a:pat == ''
                                    " No arguments specified. Open the MRU window
                                    call s:MRU_Open_Window()
                                    return
                                endif
                            
                                " Load the latest MRU file
                                call s:MRU_LoadList()
                            
                                " Empty MRU list
                                if empty(s:MRU_files)
                                    call s:MRU_Warn_Msg('MRU file list is empty')
                                    return
                                endif
                            
                                " First use the specified string as a literal string and search for
                                " filenames containing the string. If only one filename is found,
                                " then edit it (unless the user wants to open the MRU window always)
                                let m = filter(copy(s:MRU_files), 'stridx(v:val, a:pat) != -1')
                                if len(m) > 0
                            	if len(m) == 1 && !g:MRU_Window_Open_Always
                            	    call s:MRU_Edit_File(m[0], 0)
                            	    return
                            	endif
                            
                            	" More than one file matches. Try find an accurate match
                            	let new_m = filter(m, 'v:val ==# a:pat')
                            	if len(new_m) == 1 && !g:MRU_Window_Open_Always
                            	    call s:MRU_Edit_File(new_m[0], 0)
                            	    return
                            	endif
                            
                            	" Couldn't find an exact match, open the MRU window with all the
                                    " files matching the pattern.
                            	call s:MRU_Open_Window(a:pat)
                            	return
                                endif
                            
                                " Use the specified string as a regular expression pattern and search
                                " for filenames matching the pattern
                                let m = filter(copy(s:MRU_files), 'v:val =~? a:pat')
                            
                                if len(m) == 0
                                    " If an existing file (not present in the MRU list) is specified,
                                    " then open the file.
                                    if filereadable(a:pat)
                                        call s:MRU_Edit_File(a:pat, 0)
                                        return
                                    endif
                            
                                    " No filenames matching the specified pattern are found
                                    call s:MRU_Warn_Msg("MRU file list doesn't contain " .
                                                \ "files matching " . a:pat)
                                    return
                                endif
                            
                                if len(m) == 1 && !g:MRU_Window_Open_Always
                                    call s:MRU_Edit_File(m[0], 0)
                                    return
                                endif
                            
                                call s:MRU_Open_Window(a:pat)
                            endfunction
                            
                            " MRU_add_files_to_menu                 {{{1
                            " Adds a list of files to the "Recent Files" sub menu under the "File" menu.
                            "   prefix - Prefix to use for each of the menu entries
                            "   file_list - List of file names to add to the menu
    1              0.000003 function! s:MRU_add_files_to_menu(prefix, file_list)
                                for fname in a:file_list
                                    " Escape special characters in the filename
                                    let esc_fname = escape(fnamemodify(fname, ':t'), ".\\" .
                                                                    \ s:esc_filename_chars)
                                    let esc_fname = substitute(esc_fname, '&', '&&', 'g')
                            
                                    " Truncate the directory name if it is long
                                    let dir_name = fnamemodify(fname, ':h')
                                    let len = strlen(dir_name)
                                    " Shorten long file names by adding only few characters from
                                    " the beginning and end.
                                    if len > 30
                                        let dir_name = strpart(dir_name, 0, 10) .
                                                    \ '...' . 
                                                    \ strpart(dir_name, len - 20)
                                    endif
                                    let esc_dir_name = escape(dir_name, ".\\" . s:esc_filename_chars)
                                    let esc_dir_name = substitute(esc_dir_name, '&', '&&', 'g')
                            
                            	let menu_path = '&File.&Recent\ Files.' . a:prefix . esc_fname .
                            		    \ '\ (' . esc_dir_name . ')'
                            	let esc_mfname = s:MRU_escape_filename(fname)
                                    exe 'anoremenu <silent> ' . menu_path .
                                                \ " :call <SID>MRU_Edit_File('" . esc_mfname . "', 1)<CR>"
                            	exe 'tmenu ' . menu_path . ' Edit file ' . esc_mfname
                                endfor
                            endfunction
                            
                            " MRU_Refresh_Menu                      {{{1
                            " Refresh the MRU menu
    1              0.000002 function! s:MRU_Refresh_Menu()
                                if !has('menu') || !g:MRU_Add_Menu
                                    " No support for menus
                                    return
                                endif
                            
                                " Setup the cpoptions properly for the maps to work
                                let old_cpoptions = &cpoptions
                                set cpoptions&vim
                            
                                " Remove the MRU menu
                                " To retain the teared-off MRU menu, we need to add a dummy entry
                                silent! unmenu &File.&Recent\ Files
                                " The menu priority of the File menu is 10. If the MRU plugin runs
                                " first before menu.vim, the File menu order may not be correct.
                                " So specify the priority of the File menu here.
                                10noremenu &File.&Recent\ Files.Dummy <Nop>
                                silent! unmenu! &File.&Recent\ Files
                            
                                anoremenu <silent> &File.&Recent\ Files.Refresh\ list
                                            \ :call <SID>MRU_LoadList()<CR>
                                exe 'tmenu File.&Recent\ Files.Refresh\ list Reload the MRU file list from '
                            		\ . s:MRU_escape_filename(g:MRU_File)
                                anoremenu File.&Recent\ Files.-SEP1-           :
                            
                                " Add the filenames in the MRU list to the menu
                                let entry_cnt = len(s:MRU_files)
                                if entry_cnt > g:MRU_Max_Menu_Entries
                                    " Show only MRU_Max_Menu_Entries file names in the menu
                                    let mru_list = s:MRU_files[1 : g:MRU_Max_Menu_Entries]
                                    let entry_cnt = g:MRU_Max_Menu_Entries
                                else
                                    let mru_list = s:MRU_files
                                endif
                                if entry_cnt > g:MRU_Max_Submenu_Entries
                            	" Split the MRU menu into sub-menus
                                    for start_idx in range(0, entry_cnt, g:MRU_Max_Submenu_Entries)
                                        let last_idx = start_idx + g:MRU_Max_Submenu_Entries - 1
                                        if last_idx >= entry_cnt
                                            let last_idx = entry_cnt - 1
                                        endif
                                        let prefix = 'Files\ (' . (start_idx + 1) . '\.\.\.' .
                                                    \ (last_idx + 1) . ').'
                                        call s:MRU_add_files_to_menu(prefix,
                                                    \ mru_list[start_idx : last_idx])
                                    endfor
                                else
                                    call s:MRU_add_files_to_menu('', mru_list)
                                endif
                            
                                " Remove the dummy menu entry
                                unmenu &File.&Recent\ Files.Dummy
                            
                                " Restore the previous cpoptions settings
                                let &cpoptions = old_cpoptions
                            endfunction
                            
                            " Load the MRU list on plugin startup
    1   0.000506   0.000008 call s:MRU_LoadList()
                            
                            " MRU autocommands {{{1
                            " Autocommands to detect the most recently used files
    1              0.000036 autocmd BufRead * call s:MRU_AddFile(expand('<abuf>'))
    1              0.000032 autocmd BufNewFile * call s:MRU_AddFile(expand('<abuf>'))
    1              0.000004 autocmd BufWritePost * call s:MRU_AddFile(expand('<abuf>'))
                            
                            " The ':vimgrep' command adds all the files searched to the buffer list.
                            " This also modifies the MRU list, even though the user didn't edit the
                            " files. Use the following autocmds to prevent this.
    1              0.000006 autocmd QuickFixCmdPre *vimgrep* let s:mru_list_locked = 1
    1              0.000006 autocmd QuickFixCmdPost *vimgrep* let s:mru_list_locked = 0
                            
                            " Command to open the MRU window
    1              0.000011 command! -nargs=? -complete=customlist,s:MRU_Complete MRU
                                        \ call s:MRU_Cmd(<q-args>)
    1              0.000008 command! -nargs=? -complete=customlist,s:MRU_Complete Mru
                                        \ call s:MRU_Cmd(<q-args>)
                            
                            " }}}
                            
                            " restore 'cpo'
    1              0.000010 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            
                            " vim:set foldenable foldmethod=marker:

SCRIPT  /home/joshb/.vim/bundle/FuzzyFinder/plugin/fuf.vim
Sourced 1 time
Total time:   0.012628
 Self time:   0.000208

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (c) 2007-2010 Takeshi NISHIDA
                            "
                            " GetLatestVimScripts: 1984 1 :AutoInstall: FuzzyFinder
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1              0.000002 try
    1              0.000033   if !l9#guardScriptLoading(expand('<sfile>:p'), 702, 101, [])
                                finish
                              endif
    1              0.000002 catch /E117/
                              echoerr '***** L9 library must be installed! *****'
                              finish
                            endtry
                            
                            " }}}1
                            "=============================================================================
                            " LOCAL FUNCTIONS {{{1
                            
                            "
    1              0.000003 function s:initialize()
                              "---------------------------------------------------------------------------
                              call l9#defineVariableDefault('g:fuf_modesDisable'     , [ 'mrufile', 'mrucmd', ])
                              call l9#defineVariableDefault('g:fuf_keyOpen'          , '<CR>')
                              call l9#defineVariableDefault('g:fuf_keyOpenSplit'     , '<C-j>')
                              call l9#defineVariableDefault('g:fuf_keyOpenVsplit'    , '<C-k>')
                              call l9#defineVariableDefault('g:fuf_keyOpenTabpage'   , '<C-l>')
                              call l9#defineVariableDefault('g:fuf_keyPreview'       , '<C-@>')
                              call l9#defineVariableDefault('g:fuf_keyNextMode'      , '<C-t>')
                              call l9#defineVariableDefault('g:fuf_keyPrevMode'      , '<C-y>')
                              call l9#defineVariableDefault('g:fuf_keyPrevPattern'   , '<C-s>')
                              call l9#defineVariableDefault('g:fuf_keyNextPattern'   , '<C-_>')
                              call l9#defineVariableDefault('g:fuf_keySwitchMatching', '<C-\><C-\>')
                              call l9#defineVariableDefault('g:fuf_dataDir'          , '~/.vim-fuf-data')
                              call l9#defineVariableDefault('g:fuf_abbrevMap'        , {})
                              call l9#defineVariableDefault('g:fuf_patternSeparator' , ';')
                              call l9#defineVariableDefault('g:fuf_promptHighlight'  , 'Question')
                              call l9#defineVariableDefault('g:fuf_ignoreCase'       , 1)
                              call l9#defineVariableDefault('g:fuf_splitPathMatching', 1)
                              call l9#defineVariableDefault('g:fuf_fuzzyRefining'    , 0)
                              call l9#defineVariableDefault('g:fuf_smartBs'          , 1)
                              call l9#defineVariableDefault('g:fuf_reuseWindow'      , 1)
                              call l9#defineVariableDefault('g:fuf_timeFormat'       , '(%Y-%m-%d %H:%M:%S)')
                              call l9#defineVariableDefault('g:fuf_learningLimit'    , 100)
                              call l9#defineVariableDefault('g:fuf_enumeratingLimit' , 50)
                              call l9#defineVariableDefault('g:fuf_maxMenuWidth'     , 78)
                              call l9#defineVariableDefault('g:fuf_previewHeight'    , 0)
                              call l9#defineVariableDefault('g:fuf_autoPreview'      , 0)
                              call l9#defineVariableDefault('g:fuf_useMigemo'        , 0)
                              "---------------------------------------------------------------------------
                              call l9#defineVariableDefault('g:fuf_buffer_prompt'     , '>Buffer[]>')
                              call l9#defineVariableDefault('g:fuf_buffer_switchOrder', 10)
                              call l9#defineVariableDefault('g:fuf_buffer_mruOrder'   , 1)
                              call l9#defineVariableDefault('g:fuf_buffer_keyDelete'  , '<C-]>')
                              "---------------------------------------------------------------------------
                              call l9#defineVariableDefault('g:fuf_file_prompt'     , '>File[]>')
                              call l9#defineVariableDefault('g:fuf_file_switchOrder', 20)
                              call l9#defineVariableDefault('g:fuf_file_exclude'    , '\v\~$|\.(o|exe|dll|bak|orig|sw[po])$|(^|[/\\])\.(hg|git|bzr)($|[/\\])')
                              "---------------------------------------------------------------------------
                              call l9#defineVariableDefault('g:fuf_coveragefile_prompt'     , '>CoverageFile[]>')
                              call l9#defineVariableDefault('g:fuf_coveragefile_switchOrder', 30)
                              call l9#defineVariableDefault('g:fuf_coveragefile_exclude'    , '\v\~$|\.(o|exe|dll|bak|orig|sw[po])$|(^|[/\\])\.(hg|git|bzr)($|[/\\])')
                              call l9#defineVariableDefault('g:fuf_coveragefile_globPatterns', ['**/.*', '**/*'])
                              "---------------------------------------------------------------------------
                              call l9#defineVariableDefault('g:fuf_dir_prompt'     , '>Dir[]>')
                              call l9#defineVariableDefault('g:fuf_dir_switchOrder', 40)
                              call l9#defineVariableDefault('g:fuf_dir_exclude'    , '\v(^|[/\\])\.(hg|git|bzr)($|[/\\])')
                              "---------------------------------------------------------------------------
                              call l9#defineVariableDefault('g:fuf_mrufile_prompt'     , '>MRU-File[]>')
                              call l9#defineVariableDefault('g:fuf_mrufile_switchOrder', 50)
                              call l9#defineVariableDefault('g:fuf_mrufile_exclude'    , '\v\~$|\.(o|exe|dll|bak|orig|sw[po])$|^(\/\/|\\\\|\/mnt\/|\/media\/)')
                              call l9#defineVariableDefault('g:fuf_mrufile_maxItem'    , 200)
                              call l9#defineVariableDefault('g:fuf_mrufile_maxItemDir' , 50)
                              call l9#defineVariableDefault('g:fuf_mrufile_keyExpand'  , '<C-]>')
                              "---------------------------------------------------------------------------
                              call l9#defineVariableDefault('g:fuf_mrucmd_prompt'     , '>MRU-Cmd[]>')
                              call l9#defineVariableDefault('g:fuf_mrucmd_switchOrder', 60)
                              call l9#defineVariableDefault('g:fuf_mrucmd_exclude'    , '^$')
                              call l9#defineVariableDefault('g:fuf_mrucmd_maxItem'    , 200)
                              "---------------------------------------------------------------------------
                              call l9#defineVariableDefault('g:fuf_bookmarkfile_prompt'     , '>Bookmark-File[]>')
                              call l9#defineVariableDefault('g:fuf_bookmarkfile_switchOrder', 70)
                              call l9#defineVariableDefault('g:fuf_bookmarkfile_searchRange', 400)
                              call l9#defineVariableDefault('g:fuf_bookmarkfile_keyDelete'  , '<C-]>')
                              "---------------------------------------------------------------------------
                              call l9#defineVariableDefault('g:fuf_bookmarkdir_prompt'     , '>Bookmark-Dir[]>')
                              call l9#defineVariableDefault('g:fuf_bookmarkdir_switchOrder', 80)
                              call l9#defineVariableDefault('g:fuf_bookmarkdir_keyDelete'  , '<C-]>')
                              "---------------------------------------------------------------------------
                              call l9#defineVariableDefault('g:fuf_tag_prompt'     , '>Tag[]>')
                              call l9#defineVariableDefault('g:fuf_tag_switchOrder', 90)
                              "---------------------------------------------------------------------------
                              call l9#defineVariableDefault('g:fuf_buffertag_prompt'     , '>Buffer-Tag[]>')
                              call l9#defineVariableDefault('g:fuf_buffertag_switchOrder', 100)
                              call l9#defineVariableDefault('g:fuf_buffertag_ctagsPath'  , 'ctags')
                              "---------------------------------------------------------------------------
                              call l9#defineVariableDefault('g:fuf_taggedfile_prompt'     , '>Tagged-File[]>')
                              call l9#defineVariableDefault('g:fuf_taggedfile_switchOrder', 110)
                              "---------------------------------------------------------------------------
                              call l9#defineVariableDefault('g:fuf_jumplist_prompt'     , '>Jump-List[]>')
                              call l9#defineVariableDefault('g:fuf_jumplist_switchOrder', 120)
                              "---------------------------------------------------------------------------
                              call l9#defineVariableDefault('g:fuf_changelist_prompt'     , '>Change-List[]>')
                              call l9#defineVariableDefault('g:fuf_changelist_switchOrder', 130)
                              "---------------------------------------------------------------------------
                              call l9#defineVariableDefault('g:fuf_quickfix_prompt'     , '>Quickfix[]>')
                              call l9#defineVariableDefault('g:fuf_quickfix_switchOrder', 140)
                              "---------------------------------------------------------------------------
                              call l9#defineVariableDefault('g:fuf_line_prompt'     , '>Line[]>')
                              call l9#defineVariableDefault('g:fuf_line_switchOrder', 150)
                              "---------------------------------------------------------------------------
                              call l9#defineVariableDefault('g:fuf_help_prompt'     , '>Help[]>')
                              call l9#defineVariableDefault('g:fuf_help_switchOrder', 160)
                              "---------------------------------------------------------------------------
                              command! -bang -narg=0 FufEditDataFile call fuf#editDataFile()
                              command! -bang -narg=0 FufRenewCache   call s:renewCachesOfAllModes()
                              "---------------------------------------------------------------------------
                              call fuf#addMode('buffer')
                              call fuf#addMode('file')
                              call fuf#addMode('coveragefile')
                              call fuf#addMode('dir')
                              call fuf#addMode('mrufile')
                              call fuf#addMode('mrucmd')
                              call fuf#addMode('bookmarkfile')
                              call fuf#addMode('bookmarkdir')
                              call fuf#addMode('tag')
                              call fuf#addMode('buffertag')
                              call fuf#addMode('taggedfile')
                              call fuf#addMode('jumplist')
                              call fuf#addMode('changelist')
                              call fuf#addMode('quickfix')
                              call fuf#addMode('line')
                              call fuf#addMode('help')
                              call fuf#addMode('givenfile')
                              call fuf#addMode('givendir')
                              call fuf#addMode('givencmd')
                              call fuf#addMode('callbackfile')
                              call fuf#addMode('callbackitem')
                              "---------------------------------------------------------------------------
                            endfunction
                            
                            "
    1              0.000003 function s:renewCachesOfAllModes()
                              for m in fuf#getModeNames()
                                call fuf#{m}#renewCache()
                              endfor
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " INITIALIZATION {{{1
                            
    1              0.001138 call s:initialize()
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/L9/autoload/l9.vim
Sourced 1 time
Total time:   0.000581
 Self time:   0.000581

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (c) 2009-2010 Takeshi NISHIDA
                            "
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1              0.000005 if exists('g:loaded_autoload_l9')
                              finish
                            endif
    1              0.000003 let g:loaded_autoload_l9 = 1
                            
                            " }}}1
                            "=============================================================================
                            " COMPATIBILITY TEST {{{1
                            
                            "
    1              0.000003 let s:L9_VERSION_CURRENT  = 101
    1              0.000003 let s:L9_VERSION_PASSABLE = 101
                            
                            " returns true if given version is compatible.
    1              0.000003 function l9#isCompatible(ver)
                              return 
                            endfunction
                            
    1              0.000030 let s:VERSION_FACTOR = str2float('0.01')
                            
                            " returns false if the caller script should finish.
                            " a:vimVersion: if 0, don't check vim version
                            " a:l9Version: same rule as v:version
    1              0.000004 function l9#guardScriptLoading(path, vimVersion, l9Version, exprs)
                              let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
                              if exists(loadedVarName)
                                return 0
                              elseif a:vimVersion > 0 && a:vimVersion > v:version
                                echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
                                return 0
                              elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||
                                    \                    a:l9Version < s:L9_VERSION_PASSABLE)
                                echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
                                return 0
                              endif
                              for expr in a:exprs
                                if !eval(expr)
                                  echoerr a:path . ' requires: ' . expr
                                  return 0
                                endif
                              endfor
                              let {loadedVarName} = 1
                              return 1
                            endfunction
                            
                            " 
    1              0.000003 function l9#getVersion()
                              return s:L9_VERSION_CURRENT
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " LIST {{{1
                            
                            " Removes duplicates (unstable)
                            " This function doesn't change the list of argument.
    1              0.000002 function l9#unique(items)
                              let sorted = sort(a:items)
                              if len(sorted) < 2
                                return sorted
                              endif
                              let last = remove(sorted, 0)
                              let result = [last]
                              for item in sorted
                                if item != last
                                  call add(result, item)
                                  let last = item
                                endif
                              endfor
                              return result
                            endfunction
                            
                            " Removes duplicates (stable)
                            " This function doesn't change the list of argument.
    1              0.000002 function l9#uniqueStably(items)
                              let result = []
                              for item in a:items
                                if count(result, item, &ignorecase) == 0
                                  call add(result, item)
                                endif
                              endfor
                              return result
                            endfunction
                            
                            " [ [0], [1,2], [3] ] -> [ 0, 1, 2, 3 ]
                            " This function doesn't change the list of argument.
    1              0.000002 function l9#concat(items)
                              let result = []
                              for l in a:items
                                let result += l
                              endfor
                              return result
                            endfunction
                            
                            " [ [0,1,2], [3,4], [5,6,7,8] ] -> [ [0,3,5],[1,4,6] ]
                            " This function doesn't change the list of argument.
    1              0.000002 function l9#zip(items)
                              let result = []
                              for i in range(min(map(copy(a:items), 'len(v:val)')))
                                call add(result, map(copy(a:items), 'v:val[i]'))
                              endfor
                              return result
                            endfunction
                            
                            " filter() with the maximum number of items
                            " This function doesn't change the list of argument.
    1              0.000003 function l9#filterWithLimit(items, expr, limit)
                              if a:limit <= 0
                                return filter(copy(a:items), a:expr)
                              endif
                              let result = []
                              let stride = a:limit * 3 / 2 " x1.5
                              for i in range(0, len(a:items) - 1, stride)
                                let result += filter(a:items[i : i + stride - 1], a:expr)
                                if len(result) >= a:limit
                                  return remove(result, 0, a:limit - 1)
                                endif
                              endfor
                              return result
                            endfunction
                            
                            " Removes if a:expr is evaluated as non-zero and returns removed items.
                            " This function change the list of argument.
    1              0.000002 function l9#removeIf(items, expr)
                              let removed = filter(copy(a:items), a:expr)
                              call filter(a:items, '!( ' . a:expr . ')')
                              return removed
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " NUMERIC {{{1
                            
                            " }}}1
                            "=============================================================================
                            " STRING {{{1
                            
                            " Snips a:str and add a:mask if the length of a:str is more than a:len
    1              0.000002 function l9#snipHead(str, len, mask)
                              if a:len >= len(a:str)
                                return a:str
                              elseif a:len <= len(a:mask)
                                return a:mask
                              endif
                              return a:mask . a:str[-a:len + len(a:mask):]
                            endfunction
                            
                            " Snips a:str and add a:mask if the length of a:str is more than a:len
    1              0.000003 function l9#snipTail(str, len, mask)
                              if a:len >= len(a:str)
                                return a:str
                              elseif a:len <= len(a:mask)
                                return a:mask
                              endif
                              return a:str[:a:len - 1 - len(a:mask)] . a:mask
                            endfunction
                            
                            " Snips a:str and add a:mask if the length of a:str is more than a:len
    1              0.000002 function l9#snipMid(str, len, mask)
                              if a:len >= len(a:str)
                                return a:str
                              elseif a:len <= len(a:mask)
                                return a:mask
                              endif
                              let len_head = (a:len - len(a:mask)) / 2
                              let len_tail = a:len - len(a:mask) - len_head
                              return  (len_head > 0 ? a:str[: len_head - 1] : '') . a:mask .
                                    \ (len_tail > 0 ? a:str[-len_tail :] : '')
                            endfunction
                            
                            "
    1              0.000002 function l9#hash224(str)
                              let a = 0x00000800 " shift 11 bit (if unsigned)
                              let b = 0x001fffff " extract 11 bit (if unsigned)
                              let nHash = 7
                              let hashes = repeat([0], nHash)
                              for i in range(len(a:str))
                                let iHash = i % nHash
                                let hashes[iHash] = hashes[iHash] * a + hashes[iHash] / b
                                let hashes[iHash] += char2nr(a:str[i])
                              endfor
                              return join(map(hashes, 'printf("%08x", v:val)'), '')
                            endfunction
                            
                            " wildcard -> regexp
    1              0.000003 function l9#convertWildcardToRegexp(expr)
                              let re = escape(a:expr, '\')
                              for [pat, sub] in [ [ '*', '\\.\\*' ], [ '?', '\\.' ], [ '[', '\\[' ], ]
                                let re = substitute(re, pat, sub, 'g')
                              endfor
                              return '\V' . re
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " LINES {{{1
                            
                            " Removes from the line matching with a:begin first to the line matching with
                            " a:end next and returns removed lines.
                            " If matching range is not found, returns []
    1              0.000003 function l9#removeLinesBetween(lines, begin, end)
                              for i in range(len(a:lines) - 1)
                                if a:lines[i] =~ a:begin
                                  break
                                endif
                              endfor
                              for j in range(i + 1, len(a:lines) - 1)
                                if a:lines[j] =~ a:end
                                  let g:l0 += [a:lines[i : j]]
                                  return remove(a:lines, i, j)
                                endif
                              endfor
                              return []
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " PATH {{{1
                            
                            " returns the path separator charactor.
    1              0.000002 function l9#getPathSeparator()
                              return (!&shellslash && (has('win32') || has('win64')) ? '\' : '/')
                            endfunction
                            
                            " [ 'a', 'b/', '/c' ] -> 'a/b/c'
    1              0.000002 function l9#concatPaths(paths)
                              let result = ''
                              for p in a:paths
                                if empty(p)
                                  continue
                                elseif empty(result)
                                  let result = p
                                else
                                  let result = substitute(result, '[/\\]$', '', '') . l9#getPathSeparator()
                                        \    . substitute(p, '^[/\\]', '', '')
                                endif
                              endfor
                              return result
                            endfunction
                            
                            " path: '/a/b/c/d', dir: '/a/b' => 'c/d'
    1              0.000003 function l9#modifyPathRelativeToDir(path, dir)
                              let pathFull = fnamemodify(a:path, ':p')
                              let dirFull = fnamemodify(a:dir, ':p')
                              if len(pathFull) < len(dirFull) || pathFull[:len(dirFull) - 1] !=# dirFull
                                return pathFull
                              endif
                              return pathFull[len(dirFull):]
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " FILE {{{1
                            
                            " Almost same as readfile().
    1              0.000002 function l9#readFile(...)
                              let args = copy(a:000)
                              let args[0] = expand(args[0])
                              try
                                return call('readfile', args)
                              catch
                              endtry
                              return []
                            endfunction
                            
                            " Almost same as writefile().
    1              0.000002 function l9#writeFile(...)
                              let args = copy(a:000)
                              let args[1] = expand(args[1])
                              let dir = fnamemodify(args[1], ':h')
                              try
                                if !isdirectory(dir)
                                  call mkdir(dir, 'p')
                                endif
                                return call('writefile', args)
                              catch
                              endtry
                              return -1 " -1 is error code.
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " BUFFER {{{1
                            
                            " :wall/:wall! wrapper. Useful for writing readonly buffers.
    1              0.000002 function l9#writeAll()
                              try
                                silent update " NOTE: avoiding a problem with a buftype=acwrite buffer.
                                silent wall
                              catch /^Vim/ " E45, E505
                                if l9#inputHl('Question', v:exception . "\nWrite readonly files? (Y/N) : ", 'Y') ==? 'y'
                                  redraw
                                  :wall!
                                endif
                              endtry
                            endfunction
                            
                            " Loads given files with :edit command
    1              0.000003 function l9#loadFilesToBuffers(files)
                              for file in filter(copy(a:files), '!bufloaded(v:val)')
                                execute 'edit ' . fnameescape(file)
                                if !exists('bufNrFirst')
                                  let bufNrFirst = bufnr('%')
                                endif
                              endfor
                              if exists('bufNrFirst')
                                execute bufNrFirst . 'buffer'
                              endif
                            endfunction
                            
                            " Deletes all buffers except given files with :bdelete command
    1              0.000003 function l9#deleteAllBuffersExcept(files)
                              let bufNrExcepts = map(copy(a:files), 'bufnr("^" . v:val . "$")')
                              for bufNr in filter(range(1, bufnr('$')), 'bufloaded(v:val)')
                                if count(bufNrExcepts, bufNr) == 0
                                  execute bufNr . 'bdelete'
                                endif
                              endfor
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " WINDOW {{{1
                            
                            " move current window to next tabpage.
    1              0.000002 function l9#shiftWinNextTabpage()
                              if tabpagenr('$') < 2
                                return
                              endif
                              let bufnr = bufnr('%')
                              tabnext
                              execute bufnr . 'sbuffer'
                              tabprevious
                              if winnr('$') > 1
                                close
                                tabnext
                              else
                                close " if tabpage is closed, next tabpage will become current
                              endif
                            endfunction
                            
                            " move current window to previous tabpage.
    1              0.000002 function l9#shiftWinPrevTabpage()
                              if tabpagenr('$') < 2
                                return
                              endif
                              let bufnr = bufnr('%')
                              tabprevious
                              execute bufnr . 'sbuffer'
                              tabnext
                              close
                              tabprevious
                            endfunction
                            
                            " move to a window containing specified buffer.
                            " returns 0 if the buffer is not found.
    1              0.000003 function l9#moveToBufferWindowInCurrentTabpage(bufNr)
                              if bufnr('%') == a:bufNr
                                return 1
                              elseif count(tabpagebuflist(), a:bufNr) == 0
                                return 0
                              endif
                              execute bufwinnr(a:bufNr) . 'wincmd w'
                              return 1
                            endfunction
                            
                            " returns 0 if the buffer is not found.
    1              0.000004 function s:moveToOtherTabpageOpeningBuffer(bufNr)
                              for tabNr in range(1, tabpagenr('$'))
                                if tabNr != tabpagenr() && count(tabpagebuflist(tabNr), a:bufNr) > 0
                                  execute 'tabnext ' . tabNr
                                  return 1
                                endif
                              endfor
                              return 0
                            endfunction
                            
                            " move to a window containing specified buffer.
                            " returns 0 if the buffer is not found.
    1              0.000003 function l9#moveToBufferWindowInOtherTabpage(bufNr)
                              if !s:moveToOtherTabpageOpeningBuffer(a:bufNr)
                                return 0
                              endif
                              return l9#moveToBufferWindowInCurrentTabpage(a:bufNr)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " COMMAND LINE {{{1
                            
                            " echo/echomsg with highlighting.
    1              0.000003 function l9#echoHl(hl, msg, prefix, addingHistory)
                              let echoCmd = (a:addingHistory ? 'echomsg' : 'echo')
                              execute "echohl " . a:hl
                              try
                                for l in (type(a:msg) == type([]) ? a:msg : split(a:msg, "\n"))
                                  execute echoCmd . ' a:prefix . l'
                                endfor
                              finally
                                echohl None
                              endtry
                            endfunction
                            
                            " input() with highlighting.
                            " This function can take list as {completion} argument.
    1              0.000002 function l9#inputHl(hl, ...)
                              execute "echohl " . a:hl
                              try
                                let args = copy(a:000)
                                if len(args) > 2 && type(args[2]) == type([])
                                  let s:candidatesForInputHl = args[2]
                                  let args[2] = 'custom,l9#completeForInputHl'
                                endif
                                let s = call('input', args)
                                unlet! s:candidatesForInputHl
                              finally
                                echohl None
                              endtry
                              redraw " needed to show following echo to next line.
                              return s
                            endfunction
                            
                            " only called by l9#inputHl() for completion.
    1              0.000003 function l9#completeForInputHl(lead, line, pos)
                              return join(s:candidatesForInputHl, "\n")
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " VISUAL MODE {{{1
                            
                            " returns last selected text in Visual mode.
    1              0.000002 function l9#getSelectedText()
                              let reg_ = [@", getregtype('"')]
                              let regA = [@a, getregtype('a')]
                              if mode() =~# "[vV\<C-v>]"
                                silent normal! "aygv
                              else
                                let pos = getpos('.')
                                silent normal! gv"ay
                                call setpos('.', pos)
                              endif
                              let text = @a
                              call setreg('"', reg_[0], reg_[1])
                              call setreg('a', regA[0], regA[1])
                              return text
                            endfunction
                            
                            
                            " }}}1
                            "=============================================================================
                            " EVAL {{{1
                            
                            " loads given text as Vim script with :source command
    1              0.000002 function l9#loadScript(text)
                              let lines = (type(a:text) == type([]) ? a:text : split(a:text, "\n"))
                              let fname = tempname()
                              call writefile(lines, fname)
                              source `=fname`
                              call delete(fname)
                            endfunction
                            
                            
                            " }}}1
                            "=============================================================================
                            " VARIABLES {{{1
                            
                            " 
    1              0.000003 function l9#defineVariableDefault(name, default)
                              if !exists(a:name)
                                let {a:name} = a:default
                              endif
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " GREP {{{1
                            
                            " Execute :vimgrep and opens the quickfix window if matches are found.
                            "
                            " a:pattern: search pattern. If ommitted, last search pattern (@/) is used.
                            " a:files: List of files
    1              0.000003 function l9#grepFiles(pattern, files)
                              let target = join(map(a:files, 'escape(v:val, " ")'), ' ')
                              let pattern = (a:pattern[0] ==# '/' ? a:pattern[1:] : a:pattern)
                              let pattern = (empty(pattern)  ? @/ : pattern)
                              try
                                execute printf('vimgrep/%s/j %s', pattern, target)
                              catch /^Vim/
                                call setqflist([])
                              endtry
                              call l9#quickfix#sort()
                              call l9#quickfix#openIfNotEmpty(1, 0)
                            endfunction
                            
                            " Execute :vimgrep for buffers using l9#grepFiles()
                            " See also: :L9GrepBuffer :L9GrepBufferAll
    1              0.000003 function l9#grepBuffers(pattern, bufNrs)
                              let files = map(filter(a:bufNrs, 'bufloaded(v:val)'), 'bufname(v:val)')
                              call l9#grepFiles(a:pattern, files)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " SIGN {{{1
                            
                            " Highlights lines using :sign define and :sign place.
                            " 
                            " a:linehl, a:text, a:texthl: See |signs|. Ignored if empty string.
                            " a:locations: List of [{buffer number}, {line number}] for highlighting
    1              0.000003 function l9#placeSign(linehl, text, texthl, locations)
                              let argLinehl = (empty(a:linehl) ? '' : 'linehl=' . a:linehl)
                              let argText = (empty(a:text) ? '' : 'text=' . a:text)
                              let argTexthl = (empty(a:texthl) ? '' : 'texthl=' . a:texthl)
                              let name = 'l9--' . a:linehl . '--' . a:text . '--' . a:texthl
                              execute printf('sign define %s linehl=%s text=%s texthl=%s',
                                    \        name, a:linehl, a:text, a:texthl)
                              for [bufNr, lnum] in a:locations
                                execute printf('sign place 1 line=%d name=%s buffer=%d', lnum, name, bufNr)
                              endfor
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " NOTIFY EXTERNALLY {{{1
                            
                            " Notify a message using an external program.
                            " Currently supports Balloonly, Screen, and Tmux.
    1              0.000003 function l9#notifyExternally(msg)
                              return     l9#notifyBalloonly(a:msg)
                                    \ || l9#notifyScreen(a:msg)
                                    \ || l9#notifyTmux(a:msg)
                            endfunction
                            
                            "
    1              0.000003 function l9#notifyBalloonly(msg)
                              if !(has('win32') || has('win64')) || !executable(g:l9_balloonly)
                                return 0
                              endif
                              execute 'silent !start ' . shellescape(g:l9_balloonly) . ' 4000 "l9" ' . shellescape(a:msg)
                              return 1
                            endfunction
                            
                            "
    1              0.000002 function l9#notifyScreen(msg)
                              if !has('unix') || has('gui_running') || $WINDOW !~ '\d' || !executable('screen')
                                return 0
                              endif
                              call system('screen -X wall ' . shellescape('l9: ' . a:msg))
                              return 1
                            endfunction
                            
                            "
    1              0.000003 function l9#notifyTmux(msg)
                              if !has('unix') || has('gui_running') || empty($TMUX) || !executable('tmux')
                                return 0
                              endif
                              call system('tmux display-message ' . shellescape('l9: ' . a:msg))
                              return 1
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/FuzzyFinder/autoload/fuf.vim
Sourced 1 time
Total time:   0.001761
 Self time:   0.001483

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (c) 2007-2010 Takeshi NISHIDA
                            "
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1   0.000063   0.000012 if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
                              finish
                            endif
                            
                            " }}}1
                            "=============================================================================
                            " GLOBAL FUNCTIONS {{{1
                            
                            
                            " returns list of paths.
                            " An argument for glob() is normalized in order to avoid a bug on Windows.
    1              0.000003 function fuf#glob(expr)
                              " Substitutes "\", because on Windows, "**\" doesn't include ".\",
                              " but "**/" include "./". I don't know why.
                              return split(glob(substitute(a:expr, '\', '/', 'g')), "\n")
                            endfunction
                            
                            "
    1              0.000004 function fuf#countModifiedFiles(files, time)
                              return len(filter(copy(a:files), 'getftime(expand(v:val)) > a:time'))
                            endfunction
                            
                            "
    1              0.000003 function fuf#getCurrentTagFiles()
                              return sort(filter(map(tagfiles(), 'fnamemodify(v:val, '':p'')'), 'filereadable(v:val)'))
                            endfunction
                            
                            "
    1              0.000003 function fuf#mapToSetSerialIndex(in, offset)
                              for i in range(len(a:in))
                                let a:in[i].index = i + a:offset
                              endfor
                              return a:in
                            endfunction
                            
                            "
    1              0.000003 function fuf#updateMruList(mrulist, newItem, maxItem, exclude)
                              let result = copy(a:mrulist)
                              let result = filter(result,'v:val.word !=# a:newItem.word')
                              let result = insert(result, a:newItem)
                              if len(a:exclude)
                                let result = filter(result, 'v:val.word !~ a:exclude')
                              endif
                              return result[0 : a:maxItem - 1]
                            endfunction
                            
                            " takes suffix number. if no digits, returns -1
    1              0.000003 function fuf#suffixNumber(str)
                              let s = matchstr(a:str, '\d\+$')
                              return (len(s) ? str2nr(s) : -1)
                            endfunction
                            
                            " "foo/bar/buz/hoge" -> { head: "foo/bar/buz/", tail: "hoge" }
    1              0.000003 function fuf#splitPath(path)
                              let head = matchstr(a:path, '^.*[/\\]')
                              return  {
                                    \   'head' : head,
                                    \   'tail' : a:path[strlen(head):]
                                    \ }
                            endfunction
                            
                            " "foo/.../bar/...hoge" -> "foo/.../bar/../../hoge"
    1              0.000003 function fuf#expandTailDotSequenceToParentDir(pattern)
                              return substitute(a:pattern, '^\(.*[/\\]\)\?\zs\.\(\.\+\)\ze[^/\\]*$',
                                    \           '\=repeat(".." . l9#getPathSeparator(), len(submatch(2)))', '')
                            endfunction
                            
                            "
    1              0.000004 function fuf#formatPrompt(prompt, partialMatching, otherString)
                              let indicator = escape((a:partialMatching ? '!' : '') . a:otherString, '\')
                              return substitute(a:prompt, '[]', indicator, 'g')
                            endfunction
                            
                            "
    1              0.000002 function fuf#getFileLines(file)
                              let bufnr = (type(a:file) ==# type(0) ? a:file : bufnr('^' . a:file . '$'))
                              let lines = getbufline(bufnr, 1, '$')
                              if !empty(lines)
                                return lines
                              endif
                              return l9#readFile(a:file)
                            endfunction
                            
                            "
    1              0.000004 function fuf#makePreviewLinesAround(lines, indices, page, maxHeight)
                              let index = ((empty(a:indices) ? 0 : a:indices[0])
                                    \ + a:page * a:maxHeight) % len(a:lines)
                              if empty(a:lines) || a:maxHeight <= 0
                                return []
                              endif
                              let beg = max([0, index - a:maxHeight / 2])
                              let end = min([beg + a:maxHeight, len(a:lines)])
                              let beg = max([0, end - a:maxHeight])
                              let lines = []
                              for i in range(beg, end - 1)
                                let mark = (count(a:indices, i) ? '>' : ' ')
                                call add(lines, printf('%s%4d ', mark, i + 1) . a:lines[i])
                              endfor
                              return lines
                            endfunction
                            
                            " a:file: a path string or a buffer number
    1              0.000004 function fuf#makePreviewLinesForFile(file, count, maxHeight)
                              let lines = fuf#getFileLines(a:file)
                              if empty(lines)
                                return []
                              endif
                              let bufnr = (type(a:file) ==# type(0) ? a:file : bufnr('^' . a:file . '$'))
                              if exists('s:bufferCursorPosMap[bufnr]')
                                let indices = [s:bufferCursorPosMap[bufnr][1] - 1]
                              else
                                let indices = []
                              endif
                              return fuf#makePreviewLinesAround(
                                    \ lines, indices, a:count, a:maxHeight)
                            endfunction
                            
                            "
    1              0.000002 function fuf#echoWarning(msg)
                              call l9#echoHl('WarningMsg', a:msg, '[fuf] ', 1)
                            endfunction
                            
                            "
    1              0.000002 function fuf#echoError(msg)
                              call l9#echoHl('ErrorMsg', a:msg, '[fuf] ', 1)
                            endfunction
                            
                            "
    1              0.000002 function fuf#openBuffer(bufNr, mode, reuse)
                              if a:reuse && ((a:mode ==# s:OPEN_TYPE_SPLIT &&
                                    \         l9#moveToBufferWindowInCurrentTabpage(a:bufNr)) ||
                                    \        (a:mode ==# s:OPEN_TYPE_VSPLIT &&
                                    \         l9#moveToBufferWindowInCurrentTabpage(a:bufNr)) ||
                                    \        (a:mode ==# s:OPEN_TYPE_TAB &&
                                    \         l9#moveToBufferWindowInOtherTabpage(a:bufNr)))
                                return
                              endif
                              execute printf({
                                    \   s:OPEN_TYPE_CURRENT : '%sbuffer'          ,
                                    \   s:OPEN_TYPE_SPLIT   : '%ssbuffer'         ,
                                    \   s:OPEN_TYPE_VSPLIT  : 'vertical %ssbuffer',
                                    \   s:OPEN_TYPE_TAB     : 'tab %ssbuffer'     ,
                                    \ }[a:mode], a:bufNr)
                            endfunction
                            
                            "
    1              0.000003 function fuf#openFile(path, mode, reuse)
                              let bufNr = bufnr('^' . a:path . '$')
                              if bufNr > -1
                                call fuf#openBuffer(bufNr, a:mode, a:reuse)
                              else
                                execute {
                                      \   s:OPEN_TYPE_CURRENT : 'edit '   ,
                                      \   s:OPEN_TYPE_SPLIT   : 'split '  ,
                                      \   s:OPEN_TYPE_VSPLIT  : 'vsplit ' ,
                                      \   s:OPEN_TYPE_TAB     : 'tabedit ',
                                      \ }[a:mode] . fnameescape(fnamemodify(a:path, ':~:.'))
                              endif
                            endfunction
                            
                            "
    1              0.000003 function fuf#openTag(tag, mode)
                              execute {
                                    \   s:OPEN_TYPE_CURRENT : 'tjump '          ,
                                    \   s:OPEN_TYPE_SPLIT   : 'stjump '         ,
                                    \   s:OPEN_TYPE_VSPLIT  : 'vertical stjump ',
                                    \   s:OPEN_TYPE_TAB     : 'tab stjump '     ,
                                    \ }[a:mode] . a:tag
                            endfunction
                            
                            "
    1              0.000003 function fuf#openHelp(tag, mode)
                              execute {
                                    \   s:OPEN_TYPE_CURRENT : 'help '         ,
                                    \   s:OPEN_TYPE_SPLIT   : 'help '         ,
                                    \   s:OPEN_TYPE_VSPLIT  : 'vertical help ',
                                    \   s:OPEN_TYPE_TAB     : 'tab help '   ,
                                    \ }[a:mode] . a:tag
                            endfunction
                            
                            "
    1              0.000002 function fuf#prejump(mode)
                              execute {
                                    \   s:OPEN_TYPE_CURRENT : ''         ,
                                    \   s:OPEN_TYPE_SPLIT   : 'split'    ,
                                    \   s:OPEN_TYPE_VSPLIT  : 'vsplit'   ,
                                    \   s:OPEN_TYPE_TAB     : 'tab split',
                                    \ }[a:mode] 
                            endfunction
                            
                            "
    1              0.000003 function fuf#compareRanks(i1, i2)
                              if exists('a:i1.ranks') && exists('a:i2.ranks')
                                for i in range(min([len(a:i1.ranks), len(a:i2.ranks)]))
                                  if     a:i1.ranks[i] > a:i2.ranks[i]
                                    return +1
                                  elseif a:i1.ranks[i] < a:i2.ranks[i]
                                    return -1
                                  endif
                                endfor
                              endif
                              return 0
                            endfunction
                            
                            "
    1              0.000004 function fuf#makePathItem(fname, menu, appendsDirSuffix)
                              let pathPair = fuf#splitPath(a:fname)
                              let dirSuffix = (a:appendsDirSuffix && isdirectory(expand(a:fname))
                                    \          ? l9#getPathSeparator()
                                    \          : '')
                              return {
                                    \   'word'              : a:fname . dirSuffix,
                                    \   'wordForPrimaryHead': s:toLowerForIgnoringCase(pathPair.head),
                                    \   'wordForPrimaryTail': s:toLowerForIgnoringCase(pathPair.tail),
                                    \   'wordForBoundary'   : s:toLowerForIgnoringCase(s:getWordBoundaries(pathPair.tail)),
                                    \   'wordForRefining'   : s:toLowerForIgnoringCase(a:fname . dirSuffix),
                                    \   'wordForRank'       : s:toLowerForIgnoringCase(pathPair.tail),
                                    \   'menu'              : a:menu,
                                    \ }
                            endfunction
                            
                            "
    1              0.000003 function fuf#makeNonPathItem(word, menu)
                              let wordL = s:toLowerForIgnoringCase(a:word)
                              return {
                                    \   'word'           : a:word,
                                    \   'wordForPrimary' : wordL,
                                    \   'wordForBoundary': s:toLowerForIgnoringCase(s:getWordBoundaries(a:word)),
                                    \   'wordForRefining': wordL,
                                    \   'wordForRank'    : wordL,
                                    \   'menu'           : a:menu,
                                    \ }
                            endfunction
                            
                            "
    1              0.000003 function fuf#makePatternSet(patternBase, interpreter, partialMatching)
                              let MakeMatchingExpr = function(a:partialMatching
                                    \                         ? 's:makePartialMatchingExpr'
                                    \                         : 's:makeFuzzyMatchingExpr')
                              let [primary; refinings] = split(a:patternBase, g:fuf_patternSeparator, 1)
                              let elements = call(a:interpreter, [primary])
                              let primaryExprs  = map(elements.matchingPairs, 'MakeMatchingExpr(v:val[0], v:val[1])')
                              let refiningExprs = map(refinings, 's:makeRefiningExpr(v:val)')
                              return  {
                                    \   'primary'       : elements.primary,
                                    \   'primaryForRank': elements.primaryForRank,
                                    \   'filteringExpr' : join(primaryExprs + refiningExprs, ' && '),
                                    \ }
                            endfunction
                            
                            "
    1              0.000006 function fuf#enumExpandedDirsEntries(dir, exclude)
                              let entries = fuf#glob(a:dir . '*') + fuf#glob(a:dir . '.*')
                              " removes "*/." and "*/.."
                              call filter(entries, 'v:val !~ ''\v(^|[/\\])\.\.?$''')
                              call map(entries, 'fuf#makePathItem(v:val, "", 1)')
                              if len(a:exclude)
                                call filter(entries, 'v:val.word !~ a:exclude')
                              endif
                              return entries
                            endfunction
                            
                            "
    1              0.000004 function fuf#mapToSetAbbrWithSnippedWordAsPath(items)
                              let maxLenStats = {}
                              call map(a:items, 's:makeFileAbbrInfo(v:val, maxLenStats)')
                              let snippedHeads =
                                    \ map(maxLenStats, 's:getSnippedHead(v:key[: -2], v:val)')
                              return map(a:items, 's:setAbbrWithFileAbbrData(v:val, snippedHeads)')
                            endfunction
                            
                            "
    1              0.000004 function fuf#setAbbrWithFormattedWord(item, abbrIndex)
                              let lenMenu = (exists('a:item.menu') ? len(a:item.menu) + 2 : 0)
                              let abbrPrefix = (exists('a:item.abbrPrefix') ? a:item.abbrPrefix : '')
                              let a:item.abbr = abbrPrefix . a:item.word
                              if a:abbrIndex
                                let a:item.abbr = printf('%4d: ', a:item.index) . a:item.abbr
                              endif
                              let a:item.abbr = l9#snipTail(a:item.abbr, g:fuf_maxMenuWidth - lenMenu, s:ABBR_SNIP_MASK)
                              return a:item
                            endfunction
                            
                            "
    1              0.000003 function s:onCommandPre()
                              for m in filter(copy(fuf#getModeNames()), 'fuf#{v:val}#requiresOnCommandPre()')
                                  call fuf#{m}#onCommandPre(getcmdtype() . getcmdline())
                              endfor
                              " lets last entry become the newest in the history
                              call histadd(getcmdtype(), getcmdline())
                              " this is not mapped again (:help recursive_mapping)
                              return "\<CR>"
                            endfunction
                            
                            "
    1              0.000003 let s:modeNames = []
                            
                            "
    1              0.000003 function fuf#addMode(modeName)
                              if count(g:fuf_modesDisable, a:modeName) > 0
                                return
                              endif
                              call add(s:modeNames, a:modeName)
                              call fuf#{a:modeName}#renewCache()
                              call fuf#{a:modeName}#onInit()
                              if fuf#{a:modeName}#requiresOnCommandPre()
                                " cnoremap has a problem, which doesn't expand cabbrev.
                                cmap <silent> <expr> <CR> <SID>onCommandPre()
                              endif
                            endfunction
                            
                            "
    1              0.000002 function fuf#getModeNames()
                              return s:modeNames
                            endfunction
                            
                            "
    1              0.000004 function fuf#defineLaunchCommand(CmdName, modeName, prefixInitialPattern, tempVars)
                              if empty(a:tempVars)
                                let preCmd = ''
                              else
                                let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',
                                      \             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
                              endif
                              execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',
                                    \        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)
                            endfunction
                            
                            "
    1              0.000003 function fuf#defineKeyMappingInHandler(key, func)
                              " hacks to be able to use feedkeys().
                              execute printf(
                                    \ 'inoremap <buffer> <silent> %s <C-r>=fuf#getRunningHandler().%s ? "" : ""<CR>',
                                    \ a:key, a:func)
                            endfunction
                            
                            "
    1              0.000003 let s:oneTimeVariables = []
                            
                            " 
    1              0.000003 function fuf#setOneTimeVariables(...)
                              let s:oneTimeVariables += a:000
                            endfunction
                            
                            "
    1              0.000003 function fuf#launch(modeName, initialPattern, partialMatching)
                              if exists('s:runningHandler')
                                call fuf#echoWarning('FuzzyFinder is running.')
                              endif
                              if count(fuf#getModeNames(), a:modeName) == 0
                                echoerr 'This mode is not available: ' . a:modeName
                                return
                              endif
                              let s:runningHandler = fuf#{a:modeName}#createHandler(copy(s:handlerBase))
                              let s:runningHandler.stats = fuf#loadDataFile(s:runningHandler.getModeName(), 'stats')
                              let s:runningHandler.partialMatching = a:partialMatching
                              let s:runningHandler.bufNrPrev = bufnr('%')
                              let s:runningHandler.lastCol = -1
                              let s:runningHandler.windowRestoringCommand = winrestcmd()
                              call s:runningHandler.onModeEnterPre()
                              " NOTE: updatetime is set, because in Buffer-Tag mode on Vim 7.3 on Windows,
                              " Vim keeps from triggering CursorMovedI for updatetime after system() is
                              " called. I don't know why.
                              call fuf#setOneTimeVariables(
                                    \  ['&completeopt', 'menuone'],
                                    \  ['&ignorecase', 0],
                                    \  ['&updatetime', 10],
                                    \ )
                              if s:runningHandler.getPreviewHeight() > 0
                                call fuf#setOneTimeVariables(
                                      \ ['&cmdheight', s:runningHandler.getPreviewHeight() + 1])
                              endif
                              call l9#tempvariables#setList(s:TEMP_VARIABLES_GROUP, s:oneTimeVariables)
                              let s:oneTimeVariables = []
                              call s:activateFufBuffer()
                              augroup FufLocal
                                autocmd!
                                autocmd CursorMovedI <buffer>        call s:runningHandler.onCursorMovedI()
                                autocmd InsertLeave  <buffer> nested call s:runningHandler.onInsertLeave()
                              augroup END
                              for [key, func] in [
                                    \   [ g:fuf_keyOpen          , 'onCr(' . s:OPEN_TYPE_CURRENT . ')' ],
                                    \   [ g:fuf_keyOpenSplit     , 'onCr(' . s:OPEN_TYPE_SPLIT   . ')' ],
                                    \   [ g:fuf_keyOpenVsplit    , 'onCr(' . s:OPEN_TYPE_VSPLIT  . ')' ],
                                    \   [ g:fuf_keyOpenTabpage   , 'onCr(' . s:OPEN_TYPE_TAB     . ')' ],
                                    \   [ '<BS>'                 , 'onBs()'                            ],
                                    \   [ '<C-h>'                , 'onBs()'                            ],
                                    \   [ '<C-w>'                , 'onDeleteWord()'                    ],
                                    \   [ g:fuf_keyPreview       , 'onPreviewBase(1)'                  ],
                                    \   [ g:fuf_keyNextMode      , 'onSwitchMode(+1)'                  ],
                                    \   [ g:fuf_keyPrevMode      , 'onSwitchMode(-1)'                  ],
                                    \   [ g:fuf_keySwitchMatching, 'onSwitchMatching()'                ],
                                    \   [ g:fuf_keyPrevPattern   , 'onRecallPattern(+1)'               ],
                                    \   [ g:fuf_keyNextPattern   , 'onRecallPattern(-1)'               ],
                                    \ ]
                                call fuf#defineKeyMappingInHandler(key, func)
                              endfor
                              " Starts Insert mode and makes CursorMovedI event now. Command prompt is
                              " needed to forces a completion menu to update every typing.
                              call setline(1, s:runningHandler.getPrompt() . a:initialPattern)
                              call s:runningHandler.onModeEnterPost()
                              call feedkeys("A", 'n') " startinsert! does not work in InsertLeave event handler
                              redraw
                            endfunction
                            
                            "
    1              0.000004 function fuf#loadDataFile(modeName, dataName)
                              if !s:dataFileAvailable
                                return []
                              endif
                              let lines = l9#readFile(l9#concatPaths([g:fuf_dataDir, a:modeName, a:dataName]))
                              return map(lines, 'eval(v:val)')
                            endfunction
                            
                            " 
    1              0.000003 function fuf#saveDataFile(modeName, dataName, items)
                              if !s:dataFileAvailable
                                return -1
                              endif
                              let lines = map(copy(a:items), 'string(v:val)')
                              return l9#writeFile(lines, l9#concatPaths([g:fuf_dataDir, a:modeName, a:dataName]))
                            endfunction
                            
                            " 
    1              0.000003 function fuf#getDataFileTime(modeName, dataName)
                              if !s:dataFileAvailable
                                return -1
                              endif
                              return getftime(expand(l9#concatPaths([g:fuf_dataDir, a:modeName, a:dataName])))
                            endfunction
                            
                            "
    1              0.000003 function s:createDataBufferListener(dataFile)
                              let listener = { 'dataFile': a:dataFile }
                            
                              function listener.onWrite(lines)
                                let [modeName, dataName] = split(self.dataFile, l9#getPathSeparator())
                                let items = map(filter(a:lines, '!empty(v:val)'), 'eval(v:val)')
                                call fuf#saveDataFile(modeName, dataName, items)
                                echo "Data files updated"
                                return 1
                              endfunction
                            
                              return listener
                            endfunction
                            
                            "
    1              0.000003 function s:createEditDataListener()
                              let listener = {}
                            
                              function listener.onComplete(dataFile, method)
                                let bufName = '[fuf-info]'
                                let lines = l9#readFile(l9#concatPaths([g:fuf_dataDir, a:dataFile]))
                                call l9#tempbuffer#openWritable(bufName, 'vim', lines, 0, 0, 0,
                                      \                         s:createDataBufferListener(a:dataFile))
                              endfunction
                            
                              return listener
                            endfunction
                            
                            "
    1              0.000003 function s:getEditableDataFiles(modeName)
                              let dataFiles = fuf#{a:modeName}#getEditableDataNames()
                              call filter(dataFiles, 'fuf#getDataFileTime(a:modeName, v:val) != -1')
                              return map(dataFiles, 'l9#concatPaths([a:modeName, v:val])')
                            endfunction
                            
                            "
    1              0.000003 function fuf#editDataFile()
                              let dataFiles = map(copy(fuf#getModeNames()), 's:getEditableDataFiles(v:val)')
                              let dataFiles = l9#concat(dataFiles)
                              call fuf#callbackitem#launch('', 0, '>Mode>', s:createEditDataListener(), dataFiles, 0)
                            endfunction
                            
                            " 
    1              0.000002 function fuf#getRunningHandler()
                              return s:runningHandler
                            endfunction
                            
                            " 
    1              0.000002 function fuf#onComplete(findstart, base)
                              return s:runningHandler.onComplete(a:findstart, a:base)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " LOCAL FUNCTIONS/VARIABLES {{{1
                            
    1              0.000010 let s:TEMP_VARIABLES_GROUP = expand('<sfile>:p')
    1              0.000004 let s:ABBR_SNIP_MASK = '...'
    1              0.000002 let s:OPEN_TYPE_CURRENT = 1
    1              0.000002 let s:OPEN_TYPE_SPLIT   = 2
    1              0.000006 let s:OPEN_TYPE_VSPLIT  = 3
    1              0.000003 let s:OPEN_TYPE_TAB     = 4
                            
                            " a:pattern: 'str' -> '\V\.\*s\.\*t\.\*r\.\*'
    1              0.000004 function s:makeFuzzyMatchingExpr(target, pattern)
                              let wi = ''
                              for c in split(a:pattern, '\zs')
                                if wi =~# '[^*?]$' && c !~ '[*?]'
                                  let wi .= '*'
                                endif
                                let wi .= c
                              endfor
                              return s:makePartialMatchingExpr(a:target, wi)
                            endfunction
                            
                            " a:pattern: 'str' -> '\Vstr'
                            "            'st*r' -> '\Vst\.\*r'
    1              0.000003 function s:makePartialMatchingExpr(target, pattern)
                              let patternMigemo = s:makeAdditionalMigemoPattern(a:pattern)
                              if a:pattern !~ '[*?]' && empty(patternMigemo)
                                " NOTE: stridx is faster than regexp matching
                                return 'stridx(' . a:target . ', ' . string(a:pattern) . ') >= 0'
                              endif
                              return a:target . ' =~# ' .
                                    \ string(l9#convertWildcardToRegexp(a:pattern)) . patternMigemo
                            endfunction
                            
                            " 
    1              0.000003 function s:makeRefiningExpr(pattern)
                              if g:fuf_fuzzyRefining
                                let expr = s:makeFuzzyMatchingExpr('v:val.wordForRefining', a:pattern)
                              else
                                let expr = s:makePartialMatchingExpr('v:val.wordForRefining', a:pattern)
                              endif
                              if a:pattern =~# '\D'
                                return expr
                              else
                                return '(' . expr . ' || v:val.index == ' . string(a:pattern) . ')'
                              endif
                            endfunction
                            
                            " 
    1              0.000003 function s:makeAdditionalMigemoPattern(pattern)
                              if !g:fuf_useMigemo || a:pattern =~# '[^\x01-\x7e]'
                                return ''
                              endif
                              return '\|\m' . substitute(migemo(a:pattern), '\\_s\*', '.*', 'g')
                            endfunction
                            
                            "
    1              0.000003 function s:interpretPrimaryPatternForPathTail(pattern)
                              let pattern = fuf#expandTailDotSequenceToParentDir(a:pattern)
                              let pairL = fuf#splitPath(s:toLowerForIgnoringCase(pattern))
                              return {
                                    \   'primary'       : pattern,
                                    \   'primaryForRank': pairL.tail,
                                    \   'matchingPairs' : [['v:val.wordForPrimaryTail', pairL.tail],],
                                    \ }
                            endfunction
                            
                            "
    1              0.000003 function s:interpretPrimaryPatternForPath(pattern)
                              let pattern = fuf#expandTailDotSequenceToParentDir(a:pattern)
                              let patternL = s:toLowerForIgnoringCase(pattern)
                              let pairL = fuf#splitPath(patternL)
                              if g:fuf_splitPathMatching
                                let matches = [
                                      \     ['v:val.wordForPrimaryHead', pairL.head],
                                      \     ['v:val.wordForPrimaryTail', pairL.tail],
                                      \   ]
                              else
                                let matches = [
                                      \     ['v:val.wordForPrimaryHead . v:val.wordForPrimaryTail', patternL],
                                      \   ]
                              endif
                              return {
                                    \   'primary'       : pattern,
                                    \   'primaryForRank': pairL.tail,
                                    \   'matchingPairs' : matches,
                                    \ }
                            endfunction
                            
                            "
    1              0.000003 function s:interpretPrimaryPatternForNonPath(pattern)
                              let patternL = s:toLowerForIgnoringCase(a:pattern)
                              return {
                                    \   'primary'       : a:pattern,
                                    \   'primaryForRank': patternL,
                                    \   'matchingPairs' : [['v:val.wordForPrimary', patternL],],
                                    \ }
                            endfunction
                            
                            "
    1              0.000003 function s:getWordBoundaries(word)
                              return substitute(a:word, '\a\zs\l\+\|\zs\A', '', 'g')
                            endfunction
                            
                            "
    1              0.000003 function s:toLowerForIgnoringCase(str)
                              return (g:fuf_ignoreCase ? tolower(a:str) : a:str)
                            endfunction
                            
                            "
    1              0.000003 function s:setRanks(item, pattern, exprBoundary, stats)
                              "let word2 = substitute(a:eval_word, '\a\zs\l\+\|\zs\A', '', 'g')
                              let a:item.ranks = [
                                    \   s:evaluateLearningRank(a:item.word, a:stats),
                                    \   -s:scoreSequentialMatching(a:item.wordForRank, a:pattern),
                                    \   -s:scoreBoundaryMatching(a:item.wordForBoundary, 
                                    \                            a:pattern, a:exprBoundary),
                                    \   a:item.index,
                                    \ ]
                              return a:item
                            endfunction
                            
                            " 
    1              0.000003 function s:evaluateLearningRank(word, stats)
                              for i in range(len(a:stats))
                                if a:stats[i].word ==# a:word
                                  return i
                                endif
                              endfor
                              return len(a:stats)
                            endfunction
                            
                            " range of return value is [0.0, 1.0]
    1              0.000003 function s:scoreSequentialMatching(word, pattern)
                              if empty(a:pattern)
                                return str2float('0.0')
                              endif
                              let pos = stridx(a:word, a:pattern)
                              if pos < 0
                                return str2float('0.0')
                              endif
                              let lenRest = len(a:word) - len(a:pattern) - pos
                              return str2float(pos == 0 ? '0.5' : '0.0') + str2float('0.5') / (lenRest + 1)
                            endfunction
                            
                            " range of return value is [0.0, 1.0]
    1              0.000003 function s:scoreBoundaryMatching(wordForBoundary, pattern, exprBoundary)
                              if empty(a:pattern)
                                return str2float('0.0')
                              endif
                              if !eval(a:exprBoundary)
                                return 0
                              endif
                              return (s:scoreSequentialMatching(a:wordForBoundary, a:pattern) + 1) / 2
                            endfunction
                            
                            "
    1              0.000003 function s:highlightPrompt(prompt)
                              syntax clear
                              execute printf('syntax match %s /^\V%s/', g:fuf_promptHighlight, escape(a:prompt, '\/'))
                            endfunction
                            
                            "
    1              0.000002 function s:highlightError()
                              syntax clear
                              syntax match Error  /^.*$/
                            endfunction
                            
                            "
    1              0.000003 function s:expandAbbrevMap(pattern, abbrevMap)
                              let result = [a:pattern]
                              for [pattern, subs] in items(a:abbrevMap)
                                let exprs = result
                                let result = []
                                for expr in exprs
                                  let result += map(copy(subs), 'substitute(expr, pattern, escape(v:val, ''\''), "g")')
                                endfor
                              endfor
                              return l9#unique(result)
                            endfunction
                            
                            "
    1              0.000003 function s:makeFileAbbrInfo(item, maxLenStats)
                              let head = matchstr(a:item.word, '^.*[/\\]\ze.')
                              let a:item.abbr = { 'head' : head,
                                    \             'tail' : a:item.word[strlen(head):],
                                    \             'key' : head . '.',
                                    \             'prefix' : printf('%4d: ', a:item.index), }
                              if exists('a:item.abbrPrefix')
                                let a:item.abbr.prefix .= a:item.abbrPrefix
                              endif
                              let len = len(a:item.abbr.prefix) + len(a:item.word) +
                                    \   (exists('a:item.menu') ? len(a:item.menu) + 2 : 0)
                              if !exists('a:maxLenStats[a:item.abbr.key]') || len > a:maxLenStats[a:item.abbr.key]
                                let a:maxLenStats[a:item.abbr.key] = len
                              endif
                              return a:item
                            endfunction
                            
                            "
    1              0.000003 function s:getSnippedHead(head, baseLen)
                              return l9#snipMid(a:head, len(a:head) + g:fuf_maxMenuWidth - a:baseLen, s:ABBR_SNIP_MASK)
                            endfunction
                            
                            "
    1              0.000003 function s:setAbbrWithFileAbbrData(item, snippedHeads)
                              let lenMenu = (exists('a:item.menu') ? len(a:item.menu) + 2 : 0)
                              let abbr = a:item.abbr.prefix . a:snippedHeads[a:item.abbr.key] . a:item.abbr.tail
                              let a:item.abbr = l9#snipTail(abbr, g:fuf_maxMenuWidth - lenMenu, s:ABBR_SNIP_MASK)
                              return a:item
                            endfunction
                            
                            "
    1              0.000004 let s:FUF_BUF_NAME = '[fuf]'
                            
                            "
    1              0.000002 function s:activateFufBuffer()
                              " lcd . : To avoid the strange behavior that unnamed buffer changes its cwd
                              "         if 'autochdir' was set on.
                              lcd .
                              let cwd = getcwd()
                              call l9#tempbuffer#openScratch(s:FUF_BUF_NAME, 'fuf', [], 1, 0, 1, {})
                              resize 1 " for issue #21 
                              " lcd ... : countermeasure against auto-cd script
                              lcd `=cwd`
                              setlocal nocursorline   " for highlighting
                              setlocal nocursorcolumn " for highlighting
                              setlocal omnifunc=fuf#onComplete
                              redraw " for 'lazyredraw'
                              if exists(':AcpLock')
                                AcpLock
                              elseif exists(':AutoComplPopLock')
                                AutoComplPopLock
                              endif
                            endfunction
                            
                            "
    1              0.000002 function s:deactivateFufBuffer()
                              if exists(':AcpUnlock')
                                AcpUnlock
                              elseif exists(':AutoComplPopUnlock')
                                AutoComplPopUnlock
                              endif
                              call l9#tempbuffer#close(s:FUF_BUF_NAME)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " s:handlerBase {{{1
                            
    1              0.000003 let s:handlerBase = {}
                            
                            "-----------------------------------------------------------------------------
                            " PURE VIRTUAL FUNCTIONS {{{2
                            "
                            " "
                            " s:handler.getModeName()
                            " 
                            " "
                            " s:handler.getPrompt()
                            " 
                            " "
                            " s:handler.getCompleteItems(patternSet)
                            " 
                            " "
                            " s:handler.onOpen(word, mode)
                            " 
                            " " Before entering FuzzyFinder buffer. This function should return in a short time.
                            " s:handler.onModeEnterPre()
                            "
                            " " After entering FuzzyFinder buffer.
                            " s:handler.onModeEnterPost()
                            "
                            " " After leaving FuzzyFinder buffer.
                            " s:handler.onModeLeavePost(opened)
                            "
                            " }}}2
                            "-----------------------------------------------------------------------------
                            
                            "
    1              0.000003 function s:handlerBase.concretize(deriv)
                              call extend(self, a:deriv, 'error')
                              return self
                            endfunction
                            
                            "
    1              0.000003 function s:handlerBase.addStat(pattern, word)
                              let stat = { 'pattern' : a:pattern, 'word' : a:word }
                              call filter(self.stats, 'v:val !=# stat')
                              call insert(self.stats, stat)
                              let self.stats = self.stats[0 : g:fuf_learningLimit - 1]
                            endfunction
                            
                            "
    1              0.000003 function s:handlerBase.getMatchingCompleteItems(patternBase)
                              let MakeMatchingExpr = function(self.partialMatching
                                    \                         ? 's:makePartialMatchingExpr'
                                    \                         : 's:makeFuzzyMatchingExpr')
                              let patternSet = self.makePatternSet(a:patternBase)
                              let exprBoundary = s:makeFuzzyMatchingExpr('a:wordForBoundary', patternSet.primaryForRank)
                              let stats = filter(
                                    \ copy(self.stats), 'v:val.pattern ==# patternSet.primaryForRank')
                              let items = self.getCompleteItems(patternSet.primary)
                              " NOTE: In order to know an excess, plus 1 to limit number
                              let items = l9#filterWithLimit(
                                    \ items, patternSet.filteringExpr, g:fuf_enumeratingLimit + 1)
                              return map(items,
                                    \ 's:setRanks(v:val, patternSet.primaryForRank, exprBoundary, stats)')
                            endfunction
                            
                            "
    1              0.000003 function s:handlerBase.onComplete(findstart, base)
                              if a:findstart
                                return 0
                              elseif  !self.existsPrompt(a:base)
                                return []
                              endif
                              call s:highlightPrompt(self.getPrompt())
                              let items = []
                              for patternBase in s:expandAbbrevMap(self.removePrompt(a:base), g:fuf_abbrevMap)
                                let items += self.getMatchingCompleteItems(patternBase)
                                if len(items) > g:fuf_enumeratingLimit
                                  let items = items[ : g:fuf_enumeratingLimit - 1]
                                  call s:highlightError()
                                  break
                                endif
                              endfor
                              if empty(items)
                                call s:highlightError()
                              else
                                call sort(items, 'fuf#compareRanks')
                                if g:fuf_autoPreview
                                  call feedkeys("\<C-p>\<Down>\<C-r>=fuf#getRunningHandler().onPreviewBase(0) ? '' : ''\<CR>", 'n')
                                else
                                  call feedkeys("\<C-p>\<Down>", 'n')
                                endif
                                let self.lastFirstWord = items[0].word
                              endif
                              return items
                            endfunction
                            
                            "
    1              0.000003 function s:handlerBase.existsPrompt(line)
                              return  strlen(a:line) >= strlen(self.getPrompt()) &&
                                    \ a:line[:strlen(self.getPrompt()) -1] ==# self.getPrompt()
                            endfunction
                            
                            "
    1              0.000002 function s:handlerBase.removePrompt(line)
                              return a:line[(self.existsPrompt(a:line) ? strlen(self.getPrompt()) : 0):]
                            endfunction
                            
                            "
    1              0.000002 function s:handlerBase.restorePrompt(line)
                              let i = 0
                              while i < len(self.getPrompt()) && i < len(a:line) && self.getPrompt()[i] ==# a:line[i]
                                let i += 1
                              endwhile
                              return self.getPrompt() . a:line[i : ]
                            endfunction
                            
                            "
    1              0.000002 function s:handlerBase.onCursorMovedI()
                              if !self.existsPrompt(getline('.'))
                                call setline('.', self.restorePrompt(getline('.')))
                                call feedkeys("\<End>", 'n')
                              elseif col('.') <= len(self.getPrompt())
                                " if the cursor is moved before command prompt
                                call feedkeys(repeat("\<Right>", len(self.getPrompt()) - col('.') + 1), 'n')
                              elseif col('.') > strlen(getline('.')) && col('.') != self.lastCol
                                " if the cursor is placed on the end of the line and has been actually moved.
                                let self.lastCol = col('.')
                                let self.lastPattern = self.removePrompt(getline('.'))
                                call feedkeys("\<C-x>\<C-o>", 'n')
                              endif
                            endfunction
                            
                            "
    1              0.000002 function s:handlerBase.onInsertLeave()
                              unlet s:runningHandler
                              let tempVars = l9#tempvariables#getList(s:TEMP_VARIABLES_GROUP)
                              call l9#tempvariables#end(s:TEMP_VARIABLES_GROUP)
                              call s:deactivateFufBuffer()
                              call fuf#saveDataFile(self.getModeName(), 'stats', self.stats)
                              execute self.windowRestoringCommand
                              let fOpen = exists('s:reservedCommand')
                              if fOpen
                                call self.onOpen(s:reservedCommand[0], s:reservedCommand[1])
                                unlet s:reservedCommand
                              endif
                              call self.onModeLeavePost(fOpen)
                              if exists('self.reservedMode')
                                call l9#tempvariables#setList(s:TEMP_VARIABLES_GROUP, tempVars)
                                call fuf#launch(self.reservedMode, self.lastPattern, self.partialMatching)
                              endif
                            endfunction
                            
                            "
    1              0.000002 function s:handlerBase.onCr(openType)
                              if pumvisible()
                                call feedkeys(printf("\<C-y>\<C-r>=fuf#getRunningHandler().onCr(%d) ? '' : ''\<CR>",
                                      \              a:openType), 'n')
                                return
                              endif
                              if !empty(self.lastPattern)
                                call self.addStat(self.lastPattern, self.removePrompt(getline('.')))
                              endif
                              if !self.isOpenable(getline('.'))
                                " To clear i_<C-r> expression (fuf#getRunningHandler().onCr...)
                                echo ''
                                return
                              endif
                              let s:reservedCommand = [self.removePrompt(getline('.')), a:openType]
                              call feedkeys("\<Esc>", 'n') " stopinsert behavior is strange...
                            endfunction
                            
                            "
    1              0.000002 function s:handlerBase.onBs()
                              call feedkeys((pumvisible() ? "\<C-e>\<BS>" : "\<BS>"), 'n')
                            endfunction
                            
                            "
    1              0.000003 function s:getLastBlockLength(pattern, patternIsPath)
                              let separatorPos = strridx(a:pattern, g:fuf_patternSeparator)
                              if separatorPos >= 0
                                return len(a:pattern) - separatorPos
                              endif
                              if a:patternIsPath && a:pattern =~# '[/\\].'
                                return len(matchstr(a:pattern, '[^/\\]*.$'))
                              endif
                              return len(a:pattern)
                            endfunction
                            
                            "
    1              0.000002 function s:handlerBase.onDeleteWord()
                              let pattern = self.removePrompt(getline('.')[ : col('.') - 2])
                              let numBs = s:getLastBlockLength(pattern, 1)
                              call feedkeys((pumvisible() ? "\<C-e>" : "") . repeat("\<BS>", numBs), 'n')
                            endfunction
                            
                            "
    1              0.000003 function s:handlerBase.onPreviewBase(repeatable)
                              if self.getPreviewHeight() <= 0
                                return
                              elseif !pumvisible()
                                return
                              elseif !self.existsPrompt(getline('.'))
                                let word = self.removePrompt(getline('.'))
                              elseif !exists('self.lastFirstWord')
                                return
                              else
                                let word = self.lastFirstWord
                              endif
                              redraw
                              if a:repeatable && exists('self.lastPreviewInfo') && self.lastPreviewInfo.word ==# word
                                let self.lastPreviewInfo.count += 1
                              else
                                let self.lastPreviewInfo = {'word': word, 'count': 0}
                              endif
                              let lines = self.makePreviewLines(word, self.lastPreviewInfo.count)
                              let lines = lines[: self.getPreviewHeight() - 1]
                              call map(lines, 'substitute(v:val, "\t", repeat(" ", &tabstop), "g")')
                              call map(lines, 'strtrans(v:val)')
                              call map(lines, 'l9#snipTail(v:val, &columns - 1, s:ABBR_SNIP_MASK)')
                              echo join(lines, "\n")
                            endfunction
                            
                            "
    1              0.000002 function s:handlerBase.onSwitchMode(shift)
                              let modes = copy(fuf#getModeNames())
                              call map(modes, '{ "ranks": [ fuf#{v:val}#getSwitchOrder(), v:val ] }')
                              call filter(modes, 'v:val.ranks[0] >= 0')
                              call sort(modes, 'fuf#compareRanks')
                              let self.reservedMode = self.getModeName()
                              for i in range(len(modes))
                                if modes[i].ranks[1] ==# self.getModeName()
                                  let self.reservedMode = modes[(i + a:shift) % len(modes)].ranks[1]
                                  break
                                endif
                              endfor
                              call feedkeys("\<Esc>", 'n') " stopinsert doesn't work.
                            endfunction
                            
                            "
    1              0.000002 function s:handlerBase.onSwitchMatching()
                              let self.partialMatching = !self.partialMatching
                              let self.lastCol = -1
                              call setline('.', self.restorePrompt(self.lastPattern))
                              call feedkeys("\<End>", 'n')
                              "call self.onCursorMovedI()
                            endfunction
                            
                            "
    1              0.000002 function s:handlerBase.onRecallPattern(shift)
                              let patterns = map(copy(self.stats), 'v:val.pattern')
                              if !exists('self.indexRecall')
                                let self.indexRecall = -1
                              endif
                              let self.indexRecall += a:shift
                              if self.indexRecall < 0
                                let self.indexRecall = -1
                              elseif self.indexRecall >= len(patterns)
                                let self.indexRecall = len(patterns) - 1
                              else
                                call setline('.', self.getPrompt() . patterns[self.indexRecall])
                                call feedkeys("\<End>", 'n')
                              endif
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " INITIALIZATION {{{1
                            
    1              0.000004 augroup FufGlobal
    1              0.000107   autocmd!
    1              0.000009   autocmd BufLeave * let s:bufferCursorPosMap[bufnr('')] = getpos('.')
    1              0.000001 augroup END
                            
    1              0.000004 let s:bufferCursorPosMap = {}
                            
                            "
    1              0.000003 let s:DATA_FILE_VERSION = 400
                            
                            "
    1              0.000003 function s:checkDataFileCompatibility()
                              if empty(g:fuf_dataDir)
                                let s:dataFileAvailable = 0
                                return
                              endif
                              let versionPath = l9#concatPaths([g:fuf_dataDir, 'VERSION'])
                              let lines = l9#readFile(versionPath)
                              if empty(lines)
                                call l9#writeFile([s:DATA_FILE_VERSION], versionPath)
                                let s:dataFileAvailable = 1
                              elseif str2nr(lines[0]) == s:DATA_FILE_VERSION
                                let s:dataFileAvailable = 1
                              else
                                call fuf#echoWarning(printf(
                                      \ "=======================================================\n" .
                                      \ "  Existing data files for FuzzyFinder is no longer     \n" .
                                      \ "  compatible with this version of FuzzyFinder. Remove  \n" .
                                      \ "  %-53s\n" .
                                      \ "=======================================================\n" ,
                                      \ string(g:fuf_dataDir)))
                                call l9#inputHl('Question', 'Press Enter')
                                let s:dataFileAvailable = 0
                              endif
                            endfunction
                            
    1   0.000238   0.000011 call s:checkDataFileCompatibility()
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:
                            

SCRIPT  /home/joshb/.vim/bundle/FuzzyFinder/autoload/fuf/buffer.vim
Sourced 1 time
Total time:   0.000269
 Self time:   0.000217

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (c) 2007-2010 Takeshi NISHIDA
                            "
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1   0.000064   0.000012 if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
                              finish
                            endif
                            
                            " }}}1
                            "=============================================================================
                            " GLOBAL FUNCTIONS {{{1
                            
                            "
    1              0.000004 function fuf#buffer#createHandler(base)
                              return a:base.concretize(copy(s:handler))
                            endfunction
                            
                            "
    1              0.000003 function fuf#buffer#getSwitchOrder()
                              return g:fuf_buffer_switchOrder
                            endfunction
                            
                            "
    1              0.000003 function fuf#buffer#getEditableDataNames()
                              return []
                            endfunction
                            
                            "
    1              0.000002 function fuf#buffer#renewCache()
                            endfunction
                            
                            "
    1              0.000003 function fuf#buffer#requiresOnCommandPre()
                              return 0
                            endfunction
                            
                            "
    1              0.000002 function fuf#buffer#onInit()
                              call fuf#defineLaunchCommand('FufBuffer', s:MODE_NAME, '""', [])
                              augroup fuf#buffer
                                autocmd!
                                autocmd BufEnter     * call s:updateBufTimes()
                                autocmd BufWritePost * call s:updateBufTimes()
                              augroup END
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " LOCAL FUNCTIONS/VARIABLES {{{1
                            
    1              0.000005 let s:MODE_NAME = expand('<sfile>:t:r')
    1              0.000003 let s:OPEN_TYPE_DELETE = -1
                            
    1              0.000003 let s:bufTimes = {}
                            
                            "
    1              0.000003 function s:updateBufTimes()
                              let s:bufTimes[bufnr('%')] = localtime()
                            endfunction
                            
                            "
    1              0.000003 function s:makeItem(nr)
                              let fname = (empty(bufname(a:nr))
                                    \      ? '[No Name]'
                                    \      : fnamemodify(bufname(a:nr), ':p:~:.'))
                              let time = (exists('s:bufTimes[a:nr]') ? s:bufTimes[a:nr] : 0)
                              let item = fuf#makePathItem(fname, strftime(g:fuf_timeFormat, time), 0)
                              let item.index = a:nr
                              let item.bufNr = a:nr
                              let item.time = time
                              let item.abbrPrefix = s:getBufIndicator(a:nr) . ' '
                              return item
                            endfunction
                            
                            "
    1              0.000003 function s:getBufIndicator(bufNr)
                              if !getbufvar(a:bufNr, '&modifiable')
                                return '[-]'
                              elseif getbufvar(a:bufNr, '&modified')
                                return '[+]'
                              elseif getbufvar(a:bufNr, '&readonly')
                                return '[R]'
                              else
                                return '   '
                              endif
                            endfunction
                            
                            "
    1              0.000002 function s:compareTimeDescending(i1, i2)
                              return a:i1.time == a:i2.time ? 0 : a:i1.time > a:i2.time ? -1 : +1
                            endfunction
                            
                            "
    1              0.000003 function s:findItem(items, word)
                              for item in a:items
                                if item.word ==# a:word
                                  return item
                                endif
                              endfor
                              return {}
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " s:handler {{{1
                            
    1              0.000003 let s:handler = {}
                            
                            "
    1              0.000002 function s:handler.getModeName()
                              return s:MODE_NAME
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPrompt()
                              return fuf#formatPrompt(g:fuf_buffer_prompt, self.partialMatching, '')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPreviewHeight()
                              return g:fuf_previewHeight
                            endfunction
                            
                            "
    1              0.000002 function s:handler.isOpenable(enteredPattern)
                              return 1
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePatternSet(patternBase)
                              return fuf#makePatternSet(a:patternBase, 's:interpretPrimaryPatternForPath',
                                    \                   self.partialMatching)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePreviewLines(word, count)
                              let item = s:findItem(self.items, a:word)
                              if empty(item)
                                return []
                              endif
                              return fuf#makePreviewLinesForFile(item.bufNr, a:count, self.getPreviewHeight())
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getCompleteItems(patternPrimary)
                              return self.items
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onOpen(word, mode)
                              " not use bufnr(a:word) in order to handle unnamed buffer
                              let item = s:findItem(self.items, a:word)
                              if empty(item)
                                " do nothing
                              elseif a:mode ==# s:OPEN_TYPE_DELETE
                                execute item.bufNr . 'bdelete'
                                let self.reservedMode = self.getModeName()
                              else
                                call fuf#openBuffer(item.bufNr, a:mode, g:fuf_reuseWindow)
                              endif
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPre()
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPost()
                              call fuf#defineKeyMappingInHandler(g:fuf_buffer_keyDelete,
                                    \                            'onCr(' . s:OPEN_TYPE_DELETE . ')')
                              let self.items = range(1, bufnr('$'))
                              call filter(self.items, 'buflisted(v:val) && v:val != self.bufNrPrev && v:val != bufnr("%")')
                              call map(self.items, 's:makeItem(v:val)')
                              if g:fuf_buffer_mruOrder
                                call sort(self.items, 's:compareTimeDescending')
                                call fuf#mapToSetSerialIndex(self.items, 1)
                              endif
                              let self.items = fuf#mapToSetAbbrWithSnippedWordAsPath(self.items)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeLeavePost(opened)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/FuzzyFinder/autoload/fuf/file.vim
Sourced 1 time
Total time:   0.000222
 Self time:   0.000169

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (c) 2007-2010 Takeshi NISHIDA
                            "
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1   0.000066   0.000013 if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
                              finish
                            endif
                            
                            " }}}1
                            "=============================================================================
                            " GLOBAL FUNCTIONS {{{1
                            
                            "
    1              0.000004 function fuf#file#createHandler(base)
                              return a:base.concretize(copy(s:handler))
                            endfunction
                            
                            "
    1              0.000003 function fuf#file#getSwitchOrder()
                              return g:fuf_file_switchOrder
                            endfunction
                            
                            "
    1              0.000003 function fuf#file#getEditableDataNames()
                              return []
                            endfunction
                            
                            "
    1              0.000002 function fuf#file#renewCache()
                              let s:cache = {}
                            endfunction
                            
                            "
    1              0.000002 function fuf#file#requiresOnCommandPre()
                              return 0
                            endfunction
                            
                            "
    1              0.000002 function fuf#file#onInit()
                              call fuf#defineLaunchCommand('FufFile'                    , s:MODE_NAME, '""', [])
                              call fuf#defineLaunchCommand('FufFileWithFullCwd'         , s:MODE_NAME, 'fnamemodify(getcwd(), '':p'')', [])
                              call fuf#defineLaunchCommand('FufFileWithCurrentBufferDir', s:MODE_NAME, 'expand(''%:~:.'')[:-1-len(expand(''%:~:.:t''))]', [])
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " LOCAL FUNCTIONS/VARIABLES {{{1
                            
    1              0.000005 let s:MODE_NAME = expand('<sfile>:t:r')
                            
                            "
    1              0.000003 function s:enumItems(dir)
                              let key = join([getcwd(), g:fuf_ignoreCase, g:fuf_file_exclude, a:dir], "\n")
                              if !exists('s:cache[key]')
                                let s:cache[key] = fuf#enumExpandedDirsEntries(a:dir, g:fuf_file_exclude)
                                call fuf#mapToSetSerialIndex(s:cache[key], 1)
                                call fuf#mapToSetAbbrWithSnippedWordAsPath(s:cache[key])
                              endif
                              return s:cache[key]
                            endfunction
                            
                            "
    1              0.000003 function s:enumNonCurrentItems(dir, bufNrPrev, cache)
                              let key = a:dir . 'AVOIDING EMPTY KEY'
                              if !exists('a:cache[key]')
                                " NOTE: Comparing filenames is faster than bufnr('^' . fname . '$')
                                let bufNamePrev = bufname(a:bufNrPrev)
                                let a:cache[key] =
                                      \ filter(copy(s:enumItems(a:dir)), 'v:val.word !=# bufNamePrev')
                              endif
                              return a:cache[key]
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " s:handler {{{1
                            
    1              0.000003 let s:handler = {}
                            
                            "
    1              0.000002 function s:handler.getModeName()
                              return s:MODE_NAME
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPrompt()
                              return fuf#formatPrompt(g:fuf_file_prompt, self.partialMatching, '')
                            endfunction
                            
                            "
    1              0.000001 function s:handler.getPreviewHeight()
                              return g:fuf_previewHeight
                            endfunction
                            
                            "
    1              0.000002 function s:handler.isOpenable(enteredPattern)
                              return a:enteredPattern =~# '[^/\\]$'
                            endfunction
                            
                            "
    1              0.000003 function s:handler.makePatternSet(patternBase)
                              return fuf#makePatternSet(a:patternBase, 's:interpretPrimaryPatternForPathTail',
                                    \                   self.partialMatching)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePreviewLines(word, count)
                              return fuf#makePreviewLinesForFile(a:word, a:count, self.getPreviewHeight())
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getCompleteItems(patternPrimary)
                              return s:enumNonCurrentItems(
                                    \ fuf#splitPath(a:patternPrimary).head, self.bufNrPrev, self.cache)
                            endfunction
                            
                            "
    1              0.000003 function s:handler.onOpen(word, mode)
                              call fuf#openFile(a:word, a:mode, g:fuf_reuseWindow)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPre()
                            endfunction
                            
                            "
    1              0.000001 function s:handler.onModeEnterPost()
                              let self.cache = {}
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeLeavePost(opened)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/FuzzyFinder/autoload/fuf/coveragefile.vim
Sourced 1 time
Total time:   0.000280
 Self time:   0.000228

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (c) 2007-2010 Takeshi NISHIDA
                            "
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1   0.000064   0.000012 if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
                              finish
                            endif
                            
                            " }}}1
                            "=============================================================================
                            " GLOBAL FUNCTIONS {{{1
                            
                            "
    1              0.000004 function fuf#coveragefile#createHandler(base)
                              return a:base.concretize(copy(s:handler))
                            endfunction
                            
                            "
    1              0.000003 function fuf#coveragefile#getSwitchOrder()
                              return g:fuf_coveragefile_switchOrder
                            endfunction
                            
                            "
    1              0.000003 function fuf#coveragefile#getEditableDataNames()
                              return ['coverages']
                            endfunction
                            
                            "
    1              0.000002 function fuf#coveragefile#renewCache()
                              let s:cache = {}
                            endfunction
                            
                            "
    1              0.000003 function fuf#coveragefile#requiresOnCommandPre()
                              return 0
                            endfunction
                            
                            "
    1              0.000002 function fuf#coveragefile#onInit()
                              call fuf#defineLaunchCommand('FufCoverageFile', s:MODE_NAME, '""', [])
                              call l9#defineVariableDefault('g:fuf_coveragefile_name', '') " private option
                              command! -bang -narg=0        FufCoverageFileRegister call s:registerCoverage()
                              command! -bang -narg=?        FufCoverageFileChange call s:changeCoverage(<q-args>)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " LOCAL FUNCTIONS/VARIABLES {{{1
                            
    1              0.000005 let s:MODE_NAME = expand('<sfile>:t:r')
                            
                            "
    1              0.000003 function s:enumItems()
                              let key = join([getcwd(), g:fuf_ignoreCase, g:fuf_coveragefile_exclude,
                                    \         g:fuf_coveragefile_globPatterns], "\n")
                              if !exists('s:cache[key]')
                                let s:cache[key] = l9#concat(map(copy(g:fuf_coveragefile_globPatterns),
                                      \                          'fuf#glob(v:val)'))
                                call filter(s:cache[key], 'filereadable(v:val)') " filter out directories
                                call map(s:cache[key], 'fuf#makePathItem(fnamemodify(v:val, ":~:."), "", 0)')
                                if len(g:fuf_coveragefile_exclude)
                                  call filter(s:cache[key], 'v:val.word !~ g:fuf_coveragefile_exclude')
                                endif
                                call fuf#mapToSetSerialIndex(s:cache[key], 1)
                                call fuf#mapToSetAbbrWithSnippedWordAsPath(s:cache[key])
                              endif
                              return s:cache[key]
                            endfunction
                            
                            "
    1              0.000003 function s:registerCoverage()
                              let patterns = []
                              while 1
                                let pattern = l9#inputHl('Question', '[fuf] Glob pattern for coverage (<Esc> and end):',
                                      \                  '', 'file')
                                if pattern !~ '\S'
                                  break
                                endif
                                call add(patterns, pattern)
                              endwhile
                              if empty(patterns)
                                call fuf#echoWarning('Canceled')
                                return
                              endif
                              echo '[fuf] patterns: ' . string(patterns)
                              let name = l9#inputHl('Question', '[fuf] Coverage name:')
                              if name !~ '\S'
                                call fuf#echoWarning('Canceled')
                                return
                              endif
                              let coverages = fuf#loadDataFile(s:MODE_NAME, 'coverages')
                              call insert(coverages, {'name': name, 'patterns': patterns})
                              call fuf#saveDataFile(s:MODE_NAME, 'coverages', coverages)
                            endfunction
                            
                            "
    1              0.000002 function s:createChangeCoverageListener()
                              let listener = {}
                            
                              function listener.onComplete(name, method)
                                call s:changeCoverage(a:name)
                              endfunction
                            
                              return listener
                            endfunction
                            
                            "
    1              0.000003 function s:changeCoverage(name)
                              let coverages = fuf#loadDataFile(s:MODE_NAME, 'coverages')
                              if a:name !~ '\S'
                                let names = map(copy(coverages), 'v:val.name')
                                call fuf#callbackitem#launch('', 0, '>Coverage>', s:createChangeCoverageListener(), names, 0)
                                return
                              else
                                let name = a:name
                              endif
                              call filter(coverages, 'v:val.name ==# name')
                              if empty(coverages)
                                  call fuf#echoError('Coverage not found: ' . name)
                                return
                              endif
                              call fuf#setOneTimeVariables(
                                    \   ['g:fuf_coveragefile_globPatterns', coverages[0].patterns],
                                    \   ['g:fuf_coveragefile_name'        , a:name]
                                    \ )
                              FufCoverageFile
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " s:handler {{{1
                            
    1              0.000003 let s:handler = {}
                            
                            "
    1              0.000002 function s:handler.getModeName()
                              return s:MODE_NAME
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPrompt()
                              let nameString = (empty(g:fuf_coveragefile_name) ? ''
                                    \           : '[' . g:fuf_coveragefile_name . ']')
                              return fuf#formatPrompt(g:fuf_coveragefile_prompt, self.partialMatching,
                                    \                 nameString)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPreviewHeight()
                              return g:fuf_previewHeight
                            endfunction
                            
                            "
    1              0.000002 function s:handler.isOpenable(enteredPattern)
                              return 1
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePatternSet(patternBase)
                              return fuf#makePatternSet(a:patternBase, 's:interpretPrimaryPatternForPath',
                                    \                   self.partialMatching)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePreviewLines(word, count)
                              return fuf#makePreviewLinesForFile(a:word, a:count, self.getPreviewHeight())
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getCompleteItems(patternPrimary)
                              return self.items
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onOpen(word, mode)
                              call fuf#openFile(a:word, a:mode, g:fuf_reuseWindow)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPre()
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPost()
                              " NOTE: Comparing filenames is faster than bufnr('^' . fname . '$')
                              let bufNamePrev = fnamemodify(bufname(self.bufNrPrev), ':~:.')
                              let self.items = copy(s:enumItems())
                              call filter(self.items, 'v:val.word !=# bufNamePrev')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeLeavePost(opened)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/FuzzyFinder/autoload/fuf/dir.vim
Sourced 1 time
Total time:   0.000210
 Self time:   0.000158

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (c) 2007-2010 Takeshi NISHIDA
                            "
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1   0.000063   0.000011 if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
                              finish
                            endif
                            
                            " }}}1
                            "=============================================================================
                            " GLOBAL FUNCTIONS {{{1
                            
                            "
    1              0.000004 function fuf#dir#createHandler(base)
                              return a:base.concretize(copy(s:handler))
                            endfunction
                            
                            "
    1              0.000003 function fuf#dir#getSwitchOrder()
                              return g:fuf_dir_switchOrder
                            endfunction
                            
                            "
    1              0.000003 function fuf#dir#getEditableDataNames()
                              return []
                            endfunction
                            
                            "
    1              0.000003 function fuf#dir#renewCache()
                              let s:cache = {}
                            endfunction
                            
                            "
    1              0.000003 function fuf#dir#requiresOnCommandPre()
                              return 0
                            endfunction
                            
                            "
    1              0.000002 function fuf#dir#onInit()
                              call fuf#defineLaunchCommand('FufDir'                    , s:MODE_NAME, '""', [])
                              call fuf#defineLaunchCommand('FufDirWithFullCwd'         , s:MODE_NAME, 'fnamemodify(getcwd(), '':p'')', [])
                              call fuf#defineLaunchCommand('FufDirWithCurrentBufferDir', s:MODE_NAME, 'expand(''%:~:.'')[:-1-len(expand(''%:~:.:t''))]', [])
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " LOCAL FUNCTIONS/VARIABLES {{{1
                            
    1              0.000005 let s:MODE_NAME = expand('<sfile>:t:r')
                            
                            "
    1              0.000004 function s:enumItems(dir)
                              let key = getcwd() . g:fuf_ignoreCase . g:fuf_dir_exclude . "\n" . a:dir
                              if !exists('s:cache[key]')
                                let s:cache[key] = fuf#enumExpandedDirsEntries(a:dir, g:fuf_dir_exclude)
                                call filter(s:cache[key], 'v:val.word =~# ''[/\\]$''')
                                if isdirectory(a:dir)
                                  call insert(s:cache[key], fuf#makePathItem(a:dir . '.', '', 0))
                                endif
                                call fuf#mapToSetSerialIndex(s:cache[key], 1)
                                call fuf#mapToSetAbbrWithSnippedWordAsPath(s:cache[key])
                              endif
                              return s:cache[key]
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " s:handler {{{1
                            
    1              0.000003 let s:handler = {}
                            
                            "
    1              0.000002 function s:handler.getModeName()
                              return s:MODE_NAME
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPrompt()
                              return fuf#formatPrompt(g:fuf_dir_prompt, self.partialMatching, '')
                            endfunction
                            
                            "
    1              0.000001 function s:handler.getPreviewHeight()
                              return g:fuf_previewHeight
                            endfunction
                            
                            "
    1              0.000002 function s:handler.isOpenable(enteredPattern)
                              return a:enteredPattern =~# '[^/\\]$'
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePatternSet(patternBase)
                              return fuf#makePatternSet(a:patternBase, 's:interpretPrimaryPatternForPathTail',
                                    \                   self.partialMatching)
                            endfunction
                            
                            "
    1              0.000003 function s:handler.makePreviewLines(word, count)
                              return fuf#makePreviewLinesAround(
                                    \ fuf#glob(fnamemodify(a:word, ':p') . '*'),
                                    \ [], a:count, self.getPreviewHeight())
                              return 
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getCompleteItems(patternPrimary)
                              return s:enumItems(fuf#splitPath(a:patternPrimary).head)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onOpen(word, mode)
                              execute ':cd ' . fnameescape(a:word)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPre()
                            endfunction
                            
                            "
    1              0.000001 function s:handler.onModeEnterPost()
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeLeavePost(opened)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/FuzzyFinder/autoload/fuf/bookmarkfile.vim
Sourced 1 time
Total time:   0.000301
 Self time:   0.000251

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (c) 2010 Takeshi NISHIDA
                            "
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1   0.000063   0.000013 if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
                              finish
                            endif
                            
                            " }}}1
                            "=============================================================================
                            " GLOBAL FUNCTIONS {{{1
                            
                            "
    1              0.000003 function fuf#bookmarkfile#createHandler(base)
                              return a:base.concretize(copy(s:handler))
                            endfunction
                            
                            "
    1              0.000003 function fuf#bookmarkfile#getSwitchOrder()
                              return g:fuf_bookmarkfile_switchOrder
                            endfunction
                            
                            "
    1              0.000003 function fuf#bookmarkfile#getEditableDataNames()
                              return ['items']
                            endfunction
                            
                            "
    1              0.000003 function fuf#bookmarkfile#renewCache()
                            endfunction
                            
                            "
    1              0.000003 function fuf#bookmarkfile#requiresOnCommandPre()
                              return 0
                            endfunction
                            
                            "
    1              0.000003 function fuf#bookmarkfile#onInit()
                              call fuf#defineLaunchCommand('FufBookmarkFile', s:MODE_NAME, '""', [])
                              command! -bang -narg=?        FufBookmarkFileAdd               call s:bookmarkHere(<q-args>)
                              command! -bang -narg=0 -range FufBookmarkFileAddAsSelectedText call s:bookmarkHere(l9#getSelectedText())
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " LOCAL FUNCTIONS/VARIABLES {{{1
                            
    1              0.000005 let s:MODE_NAME = expand('<sfile>:t:r')
    1              0.000003 let s:OPEN_TYPE_DELETE = -1
                            
                            " opens a:path and jumps to the line matching to a:pattern from a:lnum within
                            " a:range. if not found, jumps to a:lnum.
    1              0.000004 function s:jumpToBookmark(path, mode, pattern, lnum)
                              call fuf#openFile(a:path, a:mode, g:fuf_reuseWindow)
                              call cursor(s:getMatchingLineNumber(getline(1, '$'), a:pattern, a:lnum), 0)
                              normal! zvzz
                            endfunction
                            
                            "
    1              0.000003 function s:getMatchingLineNumber(lines, pattern, lnumBegin)
                              let l = min([a:lnumBegin, len(a:lines)])
                              for [l0, l1] in map(range(0, g:fuf_bookmarkfile_searchRange),
                                    \             '[l + v:val, l - v:val]')
                                if l0 <= len(a:lines) && a:lines[l0 - 1] =~# a:pattern
                                  return l0
                                elseif l1 >= 0 && a:lines[l1 - 1] =~# a:pattern
                                  return l1
                                endif
                              endfor
                              return l
                            endfunction
                            
                            "
    1              0.000003 function s:getLinePattern(lnum)
                              return '\C\V\^' . escape(getline(a:lnum), '\') . '\$'
                            endfunction
                            
                            "
    1              0.000002 function s:bookmarkHere(word)
                              if !empty(&buftype) || expand('%') !~ '\S'
                                call fuf#echoWarning('Can''t bookmark this buffer.')
                                return
                              endif
                              let item = {
                                    \   'word' : (a:word =~# '\S' ? substitute(a:word, '\n', ' ', 'g')
                                    \                             : pathshorten(expand('%:p:~')) . '|' . line('.') . '| ' . getline('.')),
                                    \   'path' : expand('%:p'),
                                    \   'lnum' : line('.'),
                                    \   'pattern' : s:getLinePattern(line('.')),
                                    \   'time' : localtime(),
                                    \ }
                              let item.word = l9#inputHl('Question', '[fuf] Bookmark as:', item.word)
                              if item.word !~ '\S'
                                call fuf#echoWarning('Canceled')
                                return
                              endif
                              let items = fuf#loadDataFile(s:MODE_NAME, 'items')
                              call insert(items, item)
                              call fuf#saveDataFile(s:MODE_NAME, 'items', items)
                            endfunction
                            
                            "
    1              0.000003 function s:findItem(items, word)
                              for item in a:items
                                if item.word ==# a:word
                                  return item
                                endif
                              endfor
                              return {}
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " s:handler {{{1
                            
    1              0.000003 let s:handler = {}
                            
                            "
    1              0.000002 function s:handler.getModeName()
                              return s:MODE_NAME
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPrompt()
                              return fuf#formatPrompt(g:fuf_bookmarkfile_prompt, self.partialMatching, '')
                            endfunction
                            
                            "
    1              0.000001 function s:handler.getPreviewHeight()
                              return g:fuf_previewHeight
                            endfunction
                            
                            "
    1              0.000002 function s:handler.isOpenable(enteredPattern)
                              return 1
                            endfunction
                            
                            "
    1              0.000003 function s:handler.makePatternSet(patternBase)
                              return fuf#makePatternSet(a:patternBase, 's:interpretPrimaryPatternForNonPath',
                                    \                   self.partialMatching)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePreviewLines(word, count)
                              let item = s:findItem(fuf#loadDataFile(s:MODE_NAME, 'items'), a:word)
                              let lines = fuf#getFileLines(item.path)
                              if empty(lines)
                                return []
                              endif
                              let index = s:getMatchingLineNumber(lines, item.pattern, item.lnum) - 1
                              return fuf#makePreviewLinesAround(
                                    \ lines, [index], a:count, self.getPreviewHeight())
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getCompleteItems(patternPrimary)
                              return self.items
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onOpen(word, mode)
                              if a:mode ==# s:OPEN_TYPE_DELETE
                                let items = fuf#loadDataFile(s:MODE_NAME, 'items')
                                call filter(items, 'v:val.word !=# a:word')
                                call fuf#saveDataFile(s:MODE_NAME, 'items', items)
                                let self.reservedMode = self.getModeName()
                                return
                              else
                                let item = s:findItem(fuf#loadDataFile(s:MODE_NAME, 'items'), a:word)
                                if !empty(item)
                                    call s:jumpToBookmark(item.path, a:mode, item.pattern, item.lnum)
                                endif
                              endif
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPre()
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPost()
                              call fuf#defineKeyMappingInHandler(g:fuf_bookmarkfile_keyDelete,
                                    \                            'onCr(' . s:OPEN_TYPE_DELETE . ')')
                              let self.items = fuf#loadDataFile(s:MODE_NAME, 'items')
                              call map(self.items, 'fuf#makeNonPathItem(v:val.word, strftime(g:fuf_timeFormat, v:val.time))')
                              call fuf#mapToSetSerialIndex(self.items, 1)
                              call map(self.items, 'fuf#setAbbrWithFormattedWord(v:val, 1)')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeLeavePost(opened)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/FuzzyFinder/autoload/fuf/bookmarkdir.vim
Sourced 1 time
Total time:   0.000246
 Self time:   0.000195

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (c) 2010 Takeshi NISHIDA
                            "
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1   0.000063   0.000012 if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
                              finish
                            endif
                            
                            " }}}1
                            "=============================================================================
                            " GLOBAL FUNCTIONS {{{1
                            
                            "
    1              0.000004 function fuf#bookmarkdir#createHandler(base)
                              return a:base.concretize(copy(s:handler))
                            endfunction
                            
                            "
    1              0.000003 function fuf#bookmarkdir#getSwitchOrder()
                              return g:fuf_bookmarkdir_switchOrder
                            endfunction
                            
                            "
    1              0.000003 function fuf#bookmarkdir#getEditableDataNames()
                              return ['items']
                            endfunction
                            
                            "
    1              0.000002 function fuf#bookmarkdir#renewCache()
                            endfunction
                            
                            "
    1              0.000003 function fuf#bookmarkdir#requiresOnCommandPre()
                              return 0
                            endfunction
                            
                            "
    1              0.000003 function fuf#bookmarkdir#onInit()
                              call fuf#defineLaunchCommand('FufBookmarkDir', s:MODE_NAME, '""', [])
                              command! -bang -narg=?        FufBookmarkDirAdd call s:bookmark(<q-args>)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " LOCAL FUNCTIONS/VARIABLES {{{1
                            
    1              0.000005 let s:MODE_NAME = expand('<sfile>:t:r')
    1              0.000003 let s:OPEN_TYPE_DELETE = -1
                            
                            "
    1              0.000003 function s:bookmark(word)
                              let item = {
                                    \   'time' : localtime(),
                                    \ }
                            
                              let item.path = l9#inputHl('Question', '[fuf] Directory to bookmark:',
                                    \              fnamemodify(getcwd(), ':p:~'), 'dir')
                              if item.path !~ '\S'
                                call fuf#echoWarning('Canceled')
                                return
                              endif
                              let item.word = l9#inputHl('Question', '[fuf] Bookmark as:',
                                    \               fnamemodify(getcwd(), ':p:~'))
                              if item.word !~ '\S'
                                call fuf#echoWarning('Canceled')
                                return
                              endif
                              let items = fuf#loadDataFile(s:MODE_NAME, 'items')
                              call insert(items, item)
                              call fuf#saveDataFile(s:MODE_NAME, 'items', items)
                            endfunction
                            
                            "
    1              0.000002 function s:findItem(items, word)
                              for item in a:items
                                if item.word ==# a:word
                                  return item
                                endif
                              endfor
                              return {}
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " s:handler {{{1
                            
    1              0.000003 let s:handler = {}
                            
                            "
    1              0.000002 function s:handler.getModeName()
                              return s:MODE_NAME
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPrompt()
                              return fuf#formatPrompt(g:fuf_bookmarkdir_prompt, self.partialMatching, '')
                            endfunction
                            
                            "
    1              0.000003 function s:handler.getPreviewHeight()
                              return 0
                            endfunction
                            
                            "
    1              0.000002 function s:handler.isOpenable(enteredPattern)
                              return 1
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePatternSet(patternBase)
                              return fuf#makePatternSet(a:patternBase, 's:interpretPrimaryPatternForNonPath',
                                    \                   self.partialMatching)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePreviewLines(word, count)
                              return []
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getCompleteItems(patternPrimary)
                              return self.items
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onOpen(word, mode)
                              if a:mode ==# s:OPEN_TYPE_DELETE
                                let items = fuf#loadDataFile(s:MODE_NAME, 'items')
                                call filter(items, 'v:val.word !=# a:word')
                                call fuf#saveDataFile(s:MODE_NAME, 'items', items)
                                let self.reservedMode = self.getModeName()
                                return
                              else
                                let item = s:findItem(fuf#loadDataFile(s:MODE_NAME, 'items'), a:word)
                                if !empty(item)
                                    execute ':cd ' . fnameescape(item.path)
                                endif
                              endif
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPre()
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPost()
                              call fuf#defineKeyMappingInHandler(g:fuf_bookmarkdir_keyDelete,
                                    \                            'onCr(' . s:OPEN_TYPE_DELETE . ')')
                              let self.items = fuf#loadDataFile(s:MODE_NAME, 'items')
                              call map(self.items, 'fuf#makeNonPathItem(v:val.word, strftime(g:fuf_timeFormat, v:val.time))')
                              call fuf#mapToSetSerialIndex(self.items, 1)
                              call map(self.items, 'fuf#setAbbrWithFormattedWord(v:val, 1)')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeLeavePost(opened)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/FuzzyFinder/autoload/fuf/tag.vim
Sourced 1 time
Total time:   0.000257
 Self time:   0.000205

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (c) 2007-2010 Takeshi NISHIDA
                            "
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1   0.000063   0.000011 if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
                              finish
                            endif
                            
                            " }}}1
                            "=============================================================================
                            " GLOBAL FUNCTIONS {{{1
                            
                            "
    1              0.000004 function fuf#tag#createHandler(base)
                              return a:base.concretize(copy(s:handler))
                            endfunction
                            
                            "
    1              0.000003 function fuf#tag#getSwitchOrder()
                              return g:fuf_tag_switchOrder
                            endfunction
                            
                            "
    1              0.000002 function fuf#tag#getEditableDataNames()
                              return []
                            endfunction
                            
                            "
    1              0.000003 function fuf#tag#renewCache()
                              let s:cache = {}
                            endfunction
                            
                            "
    1              0.000003 function fuf#tag#requiresOnCommandPre()
                              return 0
                            endfunction
                            
                            "
    1              0.000002 function fuf#tag#onInit()
                              call fuf#defineLaunchCommand('FufTag'              , s:MODE_NAME, '""', [])
                              call fuf#defineLaunchCommand('FufTagWithCursorWord', s:MODE_NAME, 'expand(''<cword>'')', [])
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " LOCAL FUNCTIONS/VARIABLES {{{1
                            
    1              0.000006 let s:MODE_NAME = expand('<sfile>:t:r')
                            
                            "
    1              0.000003 function s:getTagNames(tagFile)
                              let names = map(l9#readFile(a:tagFile), 'matchstr(v:val, ''^[^!\t][^\t]*'')')
                              return filter(names, 'v:val =~# ''\S''')
                            endfunction
                            
                            "
    1              0.000003 function s:parseTagFiles(tagFiles, key)
                              let cacheName = 'cache-' . l9#hash224(a:key)
                              let cacheTime = fuf#getDataFileTime(s:MODE_NAME, cacheName)
                              if cacheTime != -1 && fuf#countModifiedFiles(a:tagFiles, cacheTime) == 0
                                return fuf#loadDataFile(s:MODE_NAME, cacheName)
                              endif
                              let items = l9#unique(l9#concat(map(copy(a:tagFiles), 's:getTagNames(v:val)')))
                              let items = map(items, 'fuf#makeNonPathItem(v:val, "")')
                              call fuf#mapToSetSerialIndex(items, 1)
                              let items = map(items, 'fuf#setAbbrWithFormattedWord(v:val, 1)')
                              call fuf#saveDataFile(s:MODE_NAME, cacheName, items)
                              return items
                            endfunction
                            
                            "
    1              0.000002 function s:enumTags(tagFiles)
                              if !len(a:tagFiles)
                                return []
                              endif
                              let key = join([g:fuf_ignoreCase] + a:tagFiles, "\n")
                              if !exists('s:cache[key]') || fuf#countModifiedFiles(a:tagFiles, s:cache[key].time)
                                let s:cache[key] = {
                                      \   'time'  : localtime(),
                                      \   'items' : s:parseTagFiles(a:tagFiles, key)
                                      \ }
                              endif
                              return s:cache[key].items
                            endfunction
                            
                            "
    1              0.000003 function s:getMatchingIndex(lines, cmd)
                              if a:cmd !~# '\D'
                                return str2nr(a:cmd)
                              endif
                              let pattern = matchstr(a:cmd, '^\/\^\zs.*\ze\$\/$')
                              if empty(pattern)
                                return -1
                              endif
                              for i in range(len(a:lines))
                                if a:lines[i] ==# pattern
                                  return i
                                endif
                              endfor
                              return -1
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " s:handler {{{1
                            
    1              0.000003 let s:handler = {}
                            
                            "
    1              0.000003 function s:handler.getModeName()
                              return s:MODE_NAME
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPrompt()
                              return fuf#formatPrompt(g:fuf_tag_prompt, self.partialMatching, '')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPreviewHeight()
                              return g:fuf_previewHeight
                            endfunction
                            
                            "
    1              0.000003 function s:handler.isOpenable(enteredPattern)
                              return 1
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePatternSet(patternBase)
                              return fuf#makePatternSet(a:patternBase, 's:interpretPrimaryPatternForNonPath',
                                    \                   self.partialMatching)
                            endfunction
                            
                            " 'cmd' is '/^hoge hoge$/' or line number
    1              0.000002 function s:handler.makePreviewLines(word, count)
                              let tags = taglist('^' . a:word . '$')
                              if empty(tags)
                                return []
                              endif
                              let i = a:count % len(tags)
                              let title = printf('(%d/%d) %s', i + 1, len(tags), tags[i].filename)
                              let lines = fuf#getFileLines(tags[i].filename)
                              let index = s:getMatchingIndex(lines, tags[i].cmd)
                              return [title] + fuf#makePreviewLinesAround(
                                    \ lines, (index < 0 ? [] : [index]), 0, self.getPreviewHeight() - 1)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getCompleteItems(patternPrimary)
                              return s:enumTags(self.tagFiles)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onOpen(word, mode)
                              call fuf#openTag(a:word, a:mode)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPre()
                              let self.tagFiles = fuf#getCurrentTagFiles()
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPost()
                              let &l:tags = join(self.tagFiles, ',')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeLeavePost(opened)
                              let &l:tags = ''
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/FuzzyFinder/autoload/fuf/buffertag.vim
Sourced 1 time
Total time:   0.000458
 Self time:   0.000407

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (c) 2010 Takeshi NISHIDA
                            "
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1   0.000062   0.000011 if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
                              finish
                            endif
                            
                            " }}}1
                            "=============================================================================
                            " GLOBAL FUNCTIONS {{{1
                            
                            "
    1              0.000004 function fuf#buffertag#createHandler(base)
                              return a:base.concretize(copy(s:handler))
                            endfunction
                            
                            "
    1              0.000003 function fuf#buffertag#getSwitchOrder()
                              return g:fuf_buffertag_switchOrder
                            endfunction
                            
                            "
    1              0.000003 function fuf#buffertag#getEditableDataNames()
                              return []
                            endfunction
                            
                            "
    1              0.000002 function fuf#buffertag#renewCache()
                              let s:tagItemsCache = {}
                              let s:tagDataCache = {}
                            endfunction
                            
                            "
    1              0.000004 function fuf#buffertag#requiresOnCommandPre()
                              return 0
                            endfunction
                            
                            "
    1              0.000002 function fuf#buffertag#onInit()
                              call fuf#defineLaunchCommand('FufBufferTag', s:MODE_NAME, '""',
                                    \                      [['g:fuf_buffertag_forAll', 0]])
                              call fuf#defineLaunchCommand('FufBufferTagAll', s:MODE_NAME, '""',
                                    \                      [['g:fuf_buffertag_forAll', 1]])
                              call fuf#defineLaunchCommand('FufBufferTagWithCursorWord', s:MODE_NAME,
                                    \                      'expand(''<cword>'')', [['g:fuf_buffertag_forAll', 0]])
                              call fuf#defineLaunchCommand('FufBufferTagAllWithCursorWord', s:MODE_NAME,
                                    \                      'expand(''<cword>'')', [['g:fuf_buffertag_forAll', 1]])
                              call fuf#defineLaunchCommand('FufBufferTagWithSelectedText', s:MODE_NAME,
                                    \                      'l9#getSelectedText()', [['g:fuf_buffertag_forAll', 0]])
                              call fuf#defineLaunchCommand('FufBufferTagAllWithSelectedText', s:MODE_NAME,
                                    \                      'l9#getSelectedText()', [['g:fuf_buffertag_forAll', 1]])
                              call l9#defineVariableDefault('g:fuf_buffertag_forAll', 0) " private option
                              " the following settings originate from taglist.vim
                              call l9#defineVariableDefault('g:fuf_buffertag__asm'       , '--language-force=asm --asm-types=dlmt')
                              call l9#defineVariableDefault('g:fuf_buffertag__aspperl'   , '--language-force=asp --asp-types=fsv')
                              call l9#defineVariableDefault('g:fuf_buffertag__aspvbs'    , '--language-force=asp --asp-types=fsv')
                              call l9#defineVariableDefault('g:fuf_buffertag__awk'       , '--language-force=awk --awk-types=f')
                              call l9#defineVariableDefault('g:fuf_buffertag__beta'      , '--language-force=beta --beta-types=fsv')
                              call l9#defineVariableDefault('g:fuf_buffertag__c'         , '--language-force=c --c-types=dgsutvf')
                              call l9#defineVariableDefault('g:fuf_buffertag__cpp'       , '--language-force=c++ --c++-types=nvdtcgsuf')
                              call l9#defineVariableDefault('g:fuf_buffertag__cs'        , '--language-force=c# --c#-types=dtncEgsipm')
                              call l9#defineVariableDefault('g:fuf_buffertag__cobol'     , '--language-force=cobol --cobol-types=dfgpPs')
                              call l9#defineVariableDefault('g:fuf_buffertag__eiffel'    , '--language-force=eiffel --eiffel-types=cf')
                              call l9#defineVariableDefault('g:fuf_buffertag__erlang'    , '--language-force=erlang --erlang-types=drmf')
                              call l9#defineVariableDefault('g:fuf_buffertag__expect'    , '--language-force=tcl --tcl-types=cfp')
                              call l9#defineVariableDefault('g:fuf_buffertag__fortran'   , '--language-force=fortran --fortran-types=pbceiklmntvfs')
                              call l9#defineVariableDefault('g:fuf_buffertag__html'      , '--language-force=html --html-types=af')
                              call l9#defineVariableDefault('g:fuf_buffertag__java'      , '--language-force=java --java-types=pcifm')
                              call l9#defineVariableDefault('g:fuf_buffertag__javascript', '--language-force=javascript --javascript-types=f')
                              call l9#defineVariableDefault('g:fuf_buffertag__lisp'      , '--language-force=lisp --lisp-types=f')
                              call l9#defineVariableDefault('g:fuf_buffertag__lua'       , '--language-force=lua --lua-types=f')
                              call l9#defineVariableDefault('g:fuf_buffertag__make'      , '--language-force=make --make-types=m')
                              call l9#defineVariableDefault('g:fuf_buffertag__pascal'    , '--language-force=pascal --pascal-types=fp')
                              call l9#defineVariableDefault('g:fuf_buffertag__perl'      , '--language-force=perl --perl-types=clps')
                              call l9#defineVariableDefault('g:fuf_buffertag__php'       , '--language-force=php --php-types=cdvf')
                              call l9#defineVariableDefault('g:fuf_buffertag__python'    , '--language-force=python --python-types=cmf')
                              call l9#defineVariableDefault('g:fuf_buffertag__rexx'      , '--language-force=rexx --rexx-types=s')
                              call l9#defineVariableDefault('g:fuf_buffertag__ruby'      , '--language-force=ruby --ruby-types=cfFm')
                              call l9#defineVariableDefault('g:fuf_buffertag__scheme'    , '--language-force=scheme --scheme-types=sf')
                              call l9#defineVariableDefault('g:fuf_buffertag__sh'        , '--language-force=sh --sh-types=f')
                              call l9#defineVariableDefault('g:fuf_buffertag__csh'       , '--language-force=sh --sh-types=f')
                              call l9#defineVariableDefault('g:fuf_buffertag__zsh'       , '--language-force=sh --sh-types=f')
                              call l9#defineVariableDefault('g:fuf_buffertag__slang'     , '--language-force=slang --slang-types=nf')
                              call l9#defineVariableDefault('g:fuf_buffertag__sml'       , '--language-force=sml --sml-types=ecsrtvf')
                              call l9#defineVariableDefault('g:fuf_buffertag__sql'       , '--language-force=sql --sql-types=cFPrstTvfp')
                              call l9#defineVariableDefault('g:fuf_buffertag__tcl'       , '--language-force=tcl --tcl-types=cfmp')
                              call l9#defineVariableDefault('g:fuf_buffertag__vera'      , '--language-force=vera --vera-types=cdefgmpPtTvx')
                              call l9#defineVariableDefault('g:fuf_buffertag__verilog'   , '--language-force=verilog --verilog-types=mcPertwpvf')
                              call l9#defineVariableDefault('g:fuf_buffertag__vim'       , '--language-force=vim --vim-types=avf')
                              call l9#defineVariableDefault('g:fuf_buffertag__yacc'      , '--language-force=yacc --yacc-types=l')
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " LOCAL FUNCTIONS/VARIABLES {{{1
                            
    1              0.000006 let s:MODE_NAME = expand('<sfile>:t:r')
                            
                            "
    1              0.000003 function s:parseTagLine(line)
                              " tag	W:\Win32\SRC7\NCSIM\NCVW32\CUBEFACE.H	/^#define CUBEFACE_H$/;"	macro	line:4
                              let fields = matchlist(a:line, '\v^([^\t]+)\t(.+)\t\/\^(.+)\$\/\;\"\t(.+)\tline\:(\d+)')
                              if empty(fields)
                                return {}
                              endif
                              return {
                                    \   'tag'    : fields[1],
                                    \   'fname'  : fields[2],
                                    \   'pattern': fields[3],
                                    \   'kind'   : fields[4],
                                    \   'lnum'   : str2nr(fields[5]),
                                    \ }
                            endfunction
                            
                            "
    1              0.000010 let s:TEMP_VARIABLES_GROUP = expand('<sfile>:p')
                            
                            "
    1              0.000003 function s:getFileType(bufNr)
                              let ft = getbufvar(a:bufNr, '&filetype')
                              if !empty(ft) || bufloaded(a:bufNr)
                                return ft
                              endif
                              let ft = getbufvar(a:bufNr, 'fuf_buffertag_filetype')
                              if !empty(ft)
                                return ft
                              endif
                              call l9#tempvariables#set(s:TEMP_VARIABLES_GROUP, '&eventignore', 'FileType')
                              call l9#tempvariables#set(s:TEMP_VARIABLES_GROUP, '&filetype', &filetype)
                              " from taglist.vim
                              execute 'doautocmd filetypedetect BufRead ' . bufname(a:bufNr)
                              let ft = &filetype
                              call l9#tempvariables#end(s:TEMP_VARIABLES_GROUP)
                              call setbufvar(a:bufNr, 'fuf_buffertag_filetype', ft)
                              return ft
                            endfunction
                            
                            "
    1              0.000002 function s:makeCtagsCmd(bufNr)
                              let ft = s:getFileType(a:bufNr)
                              if !exists('g:fuf_buffertag__{ft}')
                                return ''
                              endif
                              "
                              let cmd = join([g:fuf_buffertag_ctagsPath,
                                    \         '-f - --sort=no --excmd=pattern --fields=nKs',
                                    \         g:fuf_buffertag__{ft},
                                    \         shellescape(fnamemodify(bufname(a:bufNr), ':p'))])
                              return cmd
                            endfunction
                            
                            "
    1              0.000002 function s:getTagItems(bufNr)
                              let cmd = s:makeCtagsCmd(a:bufNr)
                              if empty(cmd)
                                return []
                              elseif !exists('s:tagItemsCache[cmd]') ||
                                    \ s:tagItemsCache[cmd].time < getftime(expand(bufname(a:bufNr)))
                                let items = split(system(cmd), "\n")
                                if v:shell_error
                                  call fuf#echoError([cmd] + items)
                                  throw "Command error"
                                endif
                                call map(items, 's:parseTagLine(v:val)')
                                call filter(items, '!empty(v:val)')
                                let s:tagItemsCache[cmd] = {
                                      \   'time'  : localtime(),
                                      \   'items' : items,
                                      \ }
                              endif
                              return s:tagItemsCache[cmd].items
                            endfunction
                            
                            "
    1              0.000003 function s:makeItem(tag, itemMap)
                              let menu = fnamemodify(a:itemMap[a:tag][0].fname, ':t')
                                    \ . ' [' . a:itemMap[a:tag][0].kind . ']'
                              if len(a:itemMap[a:tag]) > 1
                                let menu .= ' (' . len(a:itemMap[a:tag]) . ')'
                              endif
                              let item = fuf#makeNonPathItem(a:tag, menu)
                              return item
                            endfunction
                            
                            "
    1              0.000002 function s:getTagData(bufNrs)
                              let key = join([0] + sort(copy(a:bufNrs)), "\n")
                              let bufNames = map(copy(a:bufNrs), 'bufname(v:val)')
                              if !exists('s:tagDataCache[key]') ||
                                    \ fuf#countModifiedFiles(bufNames, s:tagDataCache[key].time) > 0
                                let itemMap = {}
                                for item in l9#concat(map(copy(a:bufNrs), 's:getTagItems(v:val)'))
                                  if !exists('itemMap[item.tag]')
                                    let itemMap[item.tag] = []
                                  endif
                                  call add(itemMap[item.tag], item)
                                endfor
                                let items = sort(keys(itemMap))
                                call map(items, 's:makeItem(v:val, itemMap)')
                                call fuf#mapToSetSerialIndex(items, 1)
                                call map(items, 'fuf#setAbbrWithFormattedWord(v:val, 1)')
                                let s:tagDataCache[key] = {
                                      \   'time'   : localtime(),
                                      \   'itemMap': itemMap,
                                      \   'items'  : items,
                                      \ }
                              endif
                              return [s:tagDataCache[key].items, s:tagDataCache[key].itemMap]
                            endfunction
                            
                            "
    1              0.000003 function s:jumpToTag(item, mode)
                              call fuf#openFile(a:item.fname, a:mode, g:fuf_reuseWindow)
                              call cursor(a:item.lnum, 1)
                              normal! zvzz
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " s:handler {{{1
                            
    1              0.000003 let s:handler = {}
                            
                            "
    1              0.000002 function s:handler.getModeName()
                              return s:MODE_NAME
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPrompt()
                              return fuf#formatPrompt(g:fuf_buffertag_prompt, self.partialMatching, '')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPreviewHeight()
                              return 0
                            endfunction
                            
                            "
    1              0.000002 function s:handler.isOpenable(enteredPattern)
                              return 1
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePatternSet(patternBase)
                              return fuf#makePatternSet(a:patternBase, 's:interpretPrimaryPatternForNonPath',
                                    \                   self.partialMatching)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePreviewLines(word, count)
                              return []
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getCompleteItems(patternPrimary)
                              return self.items
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onOpen(word, mode)
                              if !exists('self.itemMap[a:word][0]')
                                call fuf#echoError('Definition not found:' . a:word)
                                return
                              elseif len(self.itemMap[a:word]) == 1
                                let i = 0
                              else
                                let list = map(fuf#mapToSetSerialIndex(copy(self.itemMap[a:word]), 1),
                                      \        'printf(" %2d: %s|%d| [%s] %s",v:val.index, fnamemodify(v:val.fname, ":~:."), v:val.lnum, v:val.kind, v:val.pattern)')
                                let i = inputlist(['Select a definition of "' . a:word . '":'] + list) - 1
                              endif
                              if 0 <= i && i < len(self.itemMap[a:word])
                                call s:jumpToTag(self.itemMap[a:word][i], a:mode)
                              endif
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPre()
                            endfunction
                            
                            "
    1              0.000001 function s:handler.onModeEnterPost()
                              if g:fuf_buffertag_forAll
                                let bufNrs = filter(range(1, bufnr('$')), 'buflisted(v:val)')
                              else
                                let bufNrs = [self.bufNrPrev]
                              endif
                              let [self.items, self.itemMap] = s:getTagData(bufNrs)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeLeavePost(opened)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/FuzzyFinder/autoload/fuf/taggedfile.vim
Sourced 1 time
Total time:   0.000245
 Self time:   0.000192

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (c) 2007-2010 Takeshi NISHIDA
                            "
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1   0.000066   0.000013 if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
                              finish
                            endif
                            
                            " }}}1
                            "=============================================================================
                            " GLOBAL FUNCTIONS {{{1
                            
                            "
    1              0.000005 function fuf#taggedfile#createHandler(base)
                              return a:base.concretize(copy(s:handler))
                            endfunction
                            
                            "
    1              0.000003 function fuf#taggedfile#getSwitchOrder()
                              return g:fuf_taggedfile_switchOrder
                            endfunction
                            
                            "
    1              0.000003 function fuf#taggedfile#getEditableDataNames()
                              return []
                            endfunction
                            
                            "
    1              0.000003 function fuf#taggedfile#renewCache()
                              let s:cache = {}
                            endfunction
                            
                            "
    1              0.000003 function fuf#taggedfile#requiresOnCommandPre()
                              return 0
                            endfunction
                            
                            "
    1              0.000002 function fuf#taggedfile#onInit()
                              call fuf#defineLaunchCommand('FufTaggedFile', s:MODE_NAME, '""', [])
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " LOCAL FUNCTIONS/VARIABLES {{{1
                            
    1              0.000006 let s:MODE_NAME = expand('<sfile>:t:r')
                            
                            "
    1              0.000003 function s:getTaggedFileList(tagfile)
                              execute 'cd ' . fnamemodify(a:tagfile, ':h')
                              let result = map(l9#readFile(a:tagfile), 'matchstr(v:val, ''^[^!\t][^\t]*\t\zs[^\t]\+'')')
                              call map(l9#readFile(a:tagfile), 'fnamemodify(v:val, ":p")')
                              cd -
                              call map(l9#readFile(a:tagfile), 'fnamemodify(v:val, ":~:.")')
                              return filter(result, 'v:val =~# ''[^/\\ ]$''')
                            endfunction
                            
                            "
    1              0.000003 function s:parseTagFiles(tagFiles, key)
                              let cacheName = 'cache-' . l9#hash224(a:key)
                              let cacheTime = fuf#getDataFileTime(s:MODE_NAME, cacheName)
                              if cacheTime != -1 && fuf#countModifiedFiles(a:tagFiles, cacheTime) == 0
                                return fuf#loadDataFile(s:MODE_NAME, cacheName)
                              endif
                              let items = l9#unique(l9#concat(map(copy(a:tagFiles), 's:getTaggedFileList(v:val)')))
                              call map(items, 'fuf#makePathItem(v:val, "", 0)')
                              call fuf#mapToSetSerialIndex(items, 1)
                              call fuf#mapToSetAbbrWithSnippedWordAsPath(items)
                              call fuf#saveDataFile(s:MODE_NAME, cacheName, items)
                              return items
                            endfunction
                            
                            "
    1              0.000003 function s:enumTaggedFiles(tagFiles)
                              if !len(a:tagFiles)
                                return []
                              endif
                              let key = join([getcwd(), g:fuf_ignoreCase] + a:tagFiles, "\n")
                              if !exists('s:cache[key]') || fuf#countModifiedFiles(a:tagFiles, s:cache[key].time)
                                let s:cache[key] = {
                                      \   'time'  : localtime(),
                                      \   'items' : s:parseTagFiles(a:tagFiles, key)
                                      \ }
                              endif
                              return s:cache[key].items
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " s:handler {{{1
                            
    1              0.000003 let s:handler = {}
                            
                            "
    1              0.000002 function s:handler.getModeName()
                              return s:MODE_NAME
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPrompt()
                              return fuf#formatPrompt(g:fuf_taggedfile_prompt, self.partialMatching, '')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPreviewHeight()
                              return g:fuf_previewHeight
                            endfunction
                            
                            "
    1              0.000002 function s:handler.isOpenable(enteredPattern)
                              return 1
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePatternSet(patternBase)
                              return fuf#makePatternSet(a:patternBase, 's:interpretPrimaryPatternForPath',
                                    \                   self.partialMatching)
                            endfunction
                            
                            "
    1              0.000003 function s:handler.makePreviewLines(word, count)
                              return fuf#makePreviewLinesForFile(a:word, a:count, self.getPreviewHeight())
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getCompleteItems(patternPrimary)
                              return self.items
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onOpen(word, mode)
                              call fuf#openFile(a:word, a:mode, g:fuf_reuseWindow)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPre()
                              let self.tagFiles = fuf#getCurrentTagFiles()
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPost()
                              " NOTE: Comparing filenames is faster than bufnr('^' . fname . '$')
                              let bufNamePrev = fnamemodify(bufname(self.bufNrPrev), ':p:~:.')
                              " NOTE: Don't do this in onModeEnterPre()
                              "       because that should return in a short time.
                              let self.items = copy(s:enumTaggedFiles(self.tagFiles))
                              call filter(self.items, 'v:val.word !=# bufNamePrev')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeLeavePost(opened)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/FuzzyFinder/autoload/fuf/jumplist.vim
Sourced 1 time
Total time:   0.000256
 Self time:   0.000206

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (c) 2007-2010 Takeshi NISHIDA
                            "
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1   0.000063   0.000013 if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
                              finish
                            endif
                            
                            " }}}1
                            "=============================================================================
                            " GLOBAL FUNCTIONS {{{1
                            
                            "
    1              0.000004 function fuf#jumplist#createHandler(base)
                              return a:base.concretize(copy(s:handler))
                            endfunction
                            
                            "
    1              0.000003 function fuf#jumplist#getSwitchOrder()
                              return g:fuf_jumplist_switchOrder
                            endfunction
                            
                            "
    1              0.000003 function fuf#jumplist#getEditableDataNames()
                              return []
                            endfunction
                            
                            "
    1              0.000002 function fuf#jumplist#renewCache()
                            endfunction
                            
                            "
    1              0.000003 function fuf#jumplist#requiresOnCommandPre()
                              return 0
                            endfunction
                            
                            "
    1              0.000003 function fuf#jumplist#onInit()
                              call fuf#defineLaunchCommand('FufJumpList', s:MODE_NAME, '""', [])
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " LOCAL FUNCTIONS/VARIABLES {{{1
                            
    1              0.000005 let s:MODE_NAME = expand('<sfile>:t:r')
                            
                            "
    1              0.000003 function s:getJumpsLines()
                              redir => result
                              :silent jumps
                              redir END
                              return split(result, "\n")
                            endfunction
                            
                            "
    1              0.000003 function s:parseJumpsLine(line, bufnrPrev)
                              "return matchlist(a:line, '^\(.\)\s\+\(\d\+\)\s\(.*\)$')
                              let elements = matchlist(a:line, '\v^(.)\s*(\d+)\s+(\d+)\s+(\d+)\s*(.*)$')
                              if empty(elements)
                                return {}
                              endif
                              let linePrevBuffer = join(getbufline(a:bufnrPrev, elements[3]))
                              if stridx(linePrevBuffer, elements[5]) >= 0
                                let fname = bufname(a:bufnrPrev)
                                let text  = elements[5]
                              else
                                let fname = elements[5]
                                let text  = join(getbufline('^' . elements[5] . '$', elements[3]))
                              endif
                              return  {
                                    \   'prefix': elements[1],
                                    \   'count' : elements[2],
                                    \   'lnum'  : elements[3],
                                    \   'fname' : fname,
                                    \   'text'  : printf('%s|%d:%d|%s', fname, elements[3], elements[4], text),
                                    \ }
                            endfunction
                            
                            "
    1              0.000003 function s:makeItem(line, bufnrPrev)
                              let parsed = s:parseJumpsLine(a:line, a:bufnrPrev)
                              if empty(parsed)
                                return {}
                              endif
                              let item = fuf#makeNonPathItem(parsed.text, '')
                              let item.abbrPrefix = parsed.prefix
                              let item.lnum = parsed.lnum
                              let item.fname = parsed.fname
                              return item
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " s:handler {{{1
                            
    1              0.000003 let s:handler = {}
                            
                            "
    1              0.000002 function s:handler.getModeName()
                              return s:MODE_NAME
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPrompt()
                              return fuf#formatPrompt(g:fuf_jumplist_prompt, self.partialMatching, '')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPreviewHeight()
                              return g:fuf_previewHeight
                            endfunction
                            
                            "
    1              0.000002 function s:handler.isOpenable(enteredPattern)
                              return 1
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePatternSet(patternBase)
                              return fuf#makePatternSet(a:patternBase, 's:interpretPrimaryPatternForNonPath',
                                    \                   self.partialMatching)
                            endfunction
                            
                            "
    1              0.000003 function s:handler.makePreviewLines(word, count)
                              let items = filter(copy(self.items), 'v:val.word ==# a:word')
                              if empty(items)
                                return []
                              endif
                              let lines = fuf#getFileLines(items[0].fname)
                              return fuf#makePreviewLinesAround(
                                    \ lines, [items[0].lnum - 1], a:count, self.getPreviewHeight())
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getCompleteItems(patternPrimary)
                              return self.items
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onOpen(word, mode)
                              call fuf#prejump(a:mode)
                              let older = 0
                              for line in reverse(s:getJumpsLines())
                                if stridx(line, '>') == 0
                                  let older = 1
                                endif
                                let parsed = s:parseJumpsLine(line, self.bufNrPrev)
                                if !empty(parsed) && parsed.text ==# a:word
                                  if parsed.count != 0
                                    execute 'normal! ' . parsed.count . (older ? "\<C-o>" : "\<C-i>") . 'zvzz'
                                  endif
                                  break
                                endif
                              endfor
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPre()
                              let self.items = s:getJumpsLines()
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPost()
                              call map(self.items, 's:makeItem(v:val, self.bufNrPrev)')
                              call filter(self.items, '!empty(v:val)')
                              call reverse(self.items)
                              call fuf#mapToSetSerialIndex(self.items, 1)
                              call map(self.items, 'fuf#setAbbrWithFormattedWord(v:val, 1)')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeLeavePost(opened)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:
                            

SCRIPT  /home/joshb/.vim/bundle/FuzzyFinder/autoload/fuf/changelist.vim
Sourced 1 time
Total time:   0.000252
 Self time:   0.000200

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (c) 2007-2010 Takeshi NISHIDA
                            "
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1   0.000064   0.000012 if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
                              finish
                            endif
                            
                            " }}}1
                            "=============================================================================
                            " GLOBAL FUNCTIONS {{{1
                            
                            "
    1              0.000004 function fuf#changelist#createHandler(base)
                              return a:base.concretize(copy(s:handler))
                            endfunction
                            
                            "
    1              0.000003 function fuf#changelist#getSwitchOrder()
                              return g:fuf_changelist_switchOrder
                            endfunction
                            
                            "
    1              0.000003 function fuf#changelist#getEditableDataNames()
                              return []
                            endfunction
                            
                            "
    1              0.000003 function fuf#changelist#renewCache()
                            endfunction
                            
                            "
    1              0.000003 function fuf#changelist#requiresOnCommandPre()
                              return 0
                            endfunction
                            
                            "
    1              0.000002 function fuf#changelist#onInit()
                              call fuf#defineLaunchCommand('FufChangeList', s:MODE_NAME, '""', [])
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " LOCAL FUNCTIONS/VARIABLES {{{1
                            
    1              0.000006 let s:MODE_NAME = expand('<sfile>:t:r')
                            
                            "
    1              0.000003 function s:getChangesLines()
                              redir => result
                              :silent changes
                              redir END
                              return split(result, "\n")
                            endfunction
                            
                            "
    1              0.000002 function s:parseChangesLine(line)
                              " return matchlist(a:line, '^\(.\)\s\+\(\d\+\)\s\(.*\)$')
                              let elements = matchlist(a:line, '\v^(.)\s*(\d+)\s+(\d+)\s+(\d+)\s*(.*)$')
                              if empty(elements)
                                return {}
                              endif
                              return  {
                                    \   'prefix': elements[1],
                                    \   'count' : elements[2],
                                    \   'lnum'  : elements[3],
                                    \   'text'  : printf('|%d:%d|%s', elements[3], elements[4], elements[5]),
                                    \ }
                            endfunction
                            
                            "
    1              0.000003 function s:makeItem(line)
                              let parsed = s:parseChangesLine(a:line)
                              if empty(parsed)
                                return {}
                              endif
                              let item = fuf#makeNonPathItem(parsed.text, '')
                              let item.abbrPrefix = parsed.prefix
                              let item.lnum = parsed.lnum
                              return item
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " s:handler {{{1
                            
    1              0.000003 let s:handler = {}
                            
                            "
    1              0.000002 function s:handler.getModeName()
                              return s:MODE_NAME
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPrompt()
                              return fuf#formatPrompt(g:fuf_changelist_prompt, self.partialMatching, '')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPreviewHeight()
                              return g:fuf_previewHeight
                            endfunction
                            
                            "
    1              0.000002 function s:handler.isOpenable(enteredPattern)
                              return 1
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePatternSet(patternBase)
                              return fuf#makePatternSet(a:patternBase, 's:interpretPrimaryPatternForNonPath',
                                    \                   self.partialMatching)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePreviewLines(word, count)
                              let items = filter(copy(self.items), 'v:val.word ==# a:word')
                              if empty(items)
                                return []
                              endif
                              let lines = fuf#getFileLines(self.bufNrPrev)
                              return fuf#makePreviewLinesAround(
                                    \ lines, [items[0].lnum - 1], a:count, self.getPreviewHeight())
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getCompleteItems(patternPrimary)
                              return self.items
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onOpen(word, mode)
                              call fuf#prejump(a:mode)
                              let older = 0
                              for line in reverse(s:getChangesLines())
                                if stridx(line, '>') == 0
                                  let older = 1
                                endif
                                let parsed = s:parseChangesLine(line)
                                if !empty(parsed) && parsed.text ==# a:word
                                  if parsed.count != 0
                                    execute 'normal! ' . parsed.count . (older ? 'g;' : 'g,') . 'zvzz'
                                  endif
                                  break
                                endif
                              endfor
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPre()
                              let self.items = s:getChangesLines()
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPost()
                              call map(self.items, 's:makeItem(v:val)')
                              call filter(self.items, '!empty(v:val)')
                              call reverse(self.items)
                              call fuf#mapToSetSerialIndex(self.items, 1)
                              call map(self.items, 'fuf#setAbbrWithFormattedWord(v:val, 1)')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeLeavePost(opened)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:
                            

SCRIPT  /home/joshb/.vim/bundle/FuzzyFinder/autoload/fuf/quickfix.vim
Sourced 1 time
Total time:   0.000262
 Self time:   0.000209

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (c) 2007-2010 Takeshi NISHIDA
                            "
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1   0.000065   0.000012 if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
                              finish
                            endif
                            
                            " }}}1
                            "=============================================================================
                            " GLOBAL FUNCTIONS {{{1
                            
                            "
    1              0.000003 function fuf#quickfix#createHandler(base)
                              return a:base.concretize(copy(s:handler))
                            endfunction
                            
                            "
    1              0.000003 function fuf#quickfix#getSwitchOrder()
                              return g:fuf_quickfix_switchOrder
                            endfunction
                            
                            "
    1              0.000003 function fuf#quickfix#getEditableDataNames()
                              return []
                            endfunction
                            
                            "
    1              0.000002 function fuf#quickfix#renewCache()
                            endfunction
                            
                            "
    1              0.000003 function fuf#quickfix#requiresOnCommandPre()
                              return 0
                            endfunction
                            
                            "
    1              0.000004 function fuf#quickfix#onInit()
                              call fuf#defineLaunchCommand('FufQuickfix', s:MODE_NAME, '""', [])
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " LOCAL FUNCTIONS/VARIABLES {{{1
                            
    1              0.000006 let s:MODE_NAME = expand('<sfile>:t:r')
                            
                            "
    1              0.000003 function s:getJumpsLines()
                              redir => result
                              :silent jumps
                              redir END
                              return split(result, "\n")
                            endfunction
                            
                            "
    1              0.000003 function s:parseJumpsLine(line)
                              return matchlist(a:line, '^\(.\)\s\+\(\d\+\)\s\(.*\)$')
                            endfunction
                            
                            "
    1              0.000003 function s:makeItem(qfItem)
                              if !a:qfItem.valid
                                return {}
                              endif
                              let item = fuf#makeNonPathItem(
                                    \ printf('%s|%d:%d|%s', bufname(a:qfItem.bufnr), a:qfItem.lnum,
                                    \        a:qfItem.col, matchstr(a:qfItem.text, '\s*\zs.*\S'))
                                    \ , '')
                              let item.bufnr = a:qfItem.bufnr
                              let item.lnum = a:qfItem.lnum
                              return item
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " s:handler {{{1
                            
    1              0.000004 let s:handler = {}
                            
                            "
    1              0.000002 function s:handler.getModeName()
                              return s:MODE_NAME
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPrompt()
                              return fuf#formatPrompt(g:fuf_quickfix_prompt, self.partialMatching, '')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPreviewHeight()
                              return g:fuf_previewHeight
                            endfunction
                            
                            "
    1              0.000002 function s:handler.isOpenable(enteredPattern)
                              return 1
                            endfunction
                            
                            "
    1              0.000003 function s:handler.makePatternSet(patternBase)
                              return fuf#makePatternSet(a:patternBase, 's:interpretPrimaryPatternForNonPath',
                                    \                   self.partialMatching)
                            endfunction
                            
                            "
    1              0.000003 function s:handler.makePreviewLines(word, count)
                              let items = filter(copy(self.items), 'v:val.word ==# a:word')
                              if empty(items)
                                return []
                              endif
                              let lines = fuf#getFileLines(items[0].bufnr)
                              return fuf#makePreviewLinesAround(
                                    \ lines, [items[0].lnum - 1], a:count, self.getPreviewHeight())
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getCompleteItems(patternPrimary)
                              return self.items
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onOpen(word, mode)
                              call fuf#prejump(a:mode)
                              call filter(self.items, 'v:val.word ==# a:word')
                              if !empty(self.items)
                                execute 'cc ' . self.items[0].index
                              endif
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPre()
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPost()
                              let self.items = getqflist()
                              call map(self.items, 's:makeItem(v:val)')
                              call fuf#mapToSetSerialIndex(self.items, 1)
                              call filter(self.items, 'exists("v:val.word")')
                              call map(self.items, 'fuf#setAbbrWithFormattedWord(v:val, 1)')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeLeavePost(opened)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:
                            

SCRIPT  /home/joshb/.vim/bundle/FuzzyFinder/autoload/fuf/line.vim
Sourced 1 time
Total time:   0.000217
 Self time:   0.000166

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (c) 2007-2010 Takeshi NISHIDA
                            "
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1   0.000063   0.000012 if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
                              finish
                            endif
                            
                            " }}}1
                            "=============================================================================
                            " GLOBAL FUNCTIONS {{{1
                            
                            "
    1              0.000003 function fuf#line#createHandler(base)
                              return a:base.concretize(copy(s:handler))
                            endfunction
                            
                            "
    1              0.000003 function fuf#line#getSwitchOrder()
                              return g:fuf_line_switchOrder
                            endfunction
                            
                            "
    1              0.000003 function fuf#line#getEditableDataNames()
                              return []
                            endfunction
                            
                            "
    1              0.000003 function fuf#line#renewCache()
                            endfunction
                            
                            "
    1              0.000002 function fuf#line#requiresOnCommandPre()
                              return 0
                            endfunction
                            
                            "
    1              0.000002 function fuf#line#onInit()
                              call fuf#defineLaunchCommand('FufLine', s:MODE_NAME, '""', [])
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " LOCAL FUNCTIONS/VARIABLES {{{1
                            
    1              0.000005 let s:MODE_NAME = expand('<sfile>:t:r')
    1              0.000003 let s:OPEN_TYPE_DELETE = -1
                            
                            " }}}1
                            "=============================================================================
                            " s:handler {{{1
                            
    1              0.000002 let s:handler = {}
                            
                            "
    1              0.000002 function s:handler.getModeName()
                              return s:MODE_NAME
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPrompt()
                              return fuf#formatPrompt(g:fuf_line_prompt, self.partialMatching, '')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPreviewHeight()
                              return g:fuf_previewHeight
                            endfunction
                            
                            "
    1              0.000002 function s:handler.isOpenable(enteredPattern)
                              return 1
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePatternSet(patternBase)
                              return fuf#makePatternSet(a:patternBase, 's:interpretPrimaryPatternForNonPath',
                                    \                   self.partialMatching)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePreviewLines(word, count)
                              let items = filter(copy(self.items), 'v:val.word ==# a:word')
                              if empty(items)
                                return []
                              endif
                              let lines = fuf#getFileLines(self.bufNrPrev)
                              return fuf#makePreviewLinesAround(
                                    \ lines, [items[0].index - 1], a:count, self.getPreviewHeight())
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getCompleteItems(patternPrimary)
                              return self.items
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onOpen(word, mode)
                              call fuf#prejump(a:mode)
                              call filter(self.items, 'v:val.word ==# a:word')
                              if empty(self.items)
                                return
                                execute 'cc ' . self.items[0].index
                              endif
                              call cursor(self.items[0].index, 0)
                              normal! zvzz
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPre()
                            endfunction
                            
                            "
    1              0.000001 function s:handler.onModeEnterPost()
                              let tab = repeat(' ', getbufvar(self.bufNrPrev, '&tabstop'))
                              let self.items = getbufline(self.bufNrPrev, 1, '$')
                              let lnumFormat = '%' . len(string(len(self.items) + 1)) . 'd|'
                              for i in range(len(self.items))
                                let self.items[i] = printf(lnumFormat, i + 1)
                                      \ . substitute(self.items[i], "\t", tab, 'g')
                              endfor
                              call map(self.items, 'fuf#makeNonPathItem(v:val, "")')
                              call fuf#mapToSetSerialIndex(self.items, 1)
                              call map(self.items, 'fuf#setAbbrWithFormattedWord(v:val, 0)')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeLeavePost(opened)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/FuzzyFinder/autoload/fuf/help.vim
Sourced 1 time
Total time:   0.000279
 Self time:   0.000228

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (c) 2007-2010 Takeshi NISHIDA
                            "
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1   0.000063   0.000012 if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
                              finish
                            endif
                            
                            " }}}1
                            "=============================================================================
                            " GLOBAL FUNCTIONS {{{1
                            
                            "
    1              0.000004 function fuf#help#createHandler(base)
                              return a:base.concretize(copy(s:handler))
                            endfunction
                            
                            "
    1              0.000003 function fuf#help#getSwitchOrder()
                              return g:fuf_help_switchOrder
                            endfunction
                            
                            "
    1              0.000003 function fuf#help#getEditableDataNames()
                              return []
                            endfunction
                            
                            "
    1              0.000003 function fuf#help#renewCache()
                              let s:cache = {}
                            endfunction
                            
                            "
    1              0.000003 function fuf#help#requiresOnCommandPre()
                              return 0
                            endfunction
                            
                            "
    1              0.000002 function fuf#help#onInit()
                              call fuf#defineLaunchCommand('FufHelp'              , s:MODE_NAME, '""', [])
                              call fuf#defineLaunchCommand('FufHelpWithCursorWord', s:MODE_NAME, 'expand(''<cword>'')', [])
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " LOCAL FUNCTIONS/VARIABLES {{{1
                            
    1              0.000005 let s:MODE_NAME = expand('<sfile>:t:r')
                            
                            "
    1              0.000003 function s:getCurrentHelpTagFiles()
                              let prefix = 'doc' . l9#getPathSeparator()
                              let tagFiles = split(globpath(&runtimepath, prefix . 'tags'   ), "\n")
                                    \      + split(globpath(&runtimepath, prefix . 'tags-??'), "\n")
                              return sort(map(tagFiles, 'fnamemodify(v:val, ":p")'))
                            endfunction
                            
                            "
    1              0.000003 function s:parseHelpTagEntry(line, tagFile)
                              let elements = split(a:line, "\t")
                              if len(elements) != 3 || elements[0][0] ==# '!'
                                return {}
                              endif
                              let suffix = matchstr(a:tagFile, '-\zs..$')
                              if empty(suffix) 
                                let suffix = '@en'
                              else
                                let suffix = '@' . suffix
                              endif
                              let dir = fnamemodify(a:tagFile, ':h') . l9#getPathSeparator()
                              return {
                                    \   'word'   : elements[0] . suffix,
                                    \   'path'   : dir . elements[1],
                                    \   'pattern': elements[2][1:],
                                    \ }
                            endfunction
                            
                            "
    1              0.000002 function s:getHelpTagEntries(tagFile)
                              let names = map(l9#readFile(a:tagFile), 's:parseHelpTagEntry(v:val, a:tagFile)')
                              return filter(names, '!empty(v:val)')
                            endfunction
                            
                            "
    1              0.000003 function s:parseHelpTagFiles(tagFiles, key)
                              let cacheName = 'cache-' . l9#hash224(a:key)
                              let cacheTime = fuf#getDataFileTime(s:MODE_NAME, cacheName)
                              if cacheTime != -1 && fuf#countModifiedFiles(a:tagFiles, cacheTime) == 0
                                return fuf#loadDataFile(s:MODE_NAME, cacheName)
                              endif
                              let items = l9#unique(l9#concat(map(copy(a:tagFiles), 's:getHelpTagEntries(v:val)')))
                              let items = map(items, 'extend(v:val, fuf#makeNonPathItem(v:val.word, ""))')
                              call fuf#mapToSetSerialIndex(items, 1)
                              let items = map(items, 'fuf#setAbbrWithFormattedWord(v:val, 1)')
                              call fuf#saveDataFile(s:MODE_NAME, cacheName, items)
                              return items
                            endfunction
                            
                            "
    1              0.000003 function s:enumHelpTags(tagFiles)
                              if !len(a:tagFiles)
                                return []
                              endif
                              let key = join([g:fuf_ignoreCase] + a:tagFiles, "\n")
                              if !exists('s:cache[key]') || fuf#countModifiedFiles(a:tagFiles, s:cache[key].time)
                                let s:cache[key] = {
                                      \   'time'  : localtime(),
                                      \   'items' : s:parseHelpTagFiles(a:tagFiles, key)
                                      \ }
                              endif
                              return s:cache[key].items
                            endfunction
                            
                            "
    1              0.000003 function s:getMatchingIndex(lines, pattern)
                              if empty(a:pattern)
                                return -1
                              endif
                              for i in range(len(a:lines))
                                if stridx(a:lines[i], a:pattern) >= 0
                                  return i
                                endif
                              endfor
                              return -1
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " s:handler {{{1
                            
    1              0.000002 let s:handler = {}
                            
                            "
    1              0.000002 function s:handler.getModeName()
                              return s:MODE_NAME
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPrompt()
                              return fuf#formatPrompt(g:fuf_help_prompt, self.partialMatching, '')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPreviewHeight()
                              return g:fuf_previewHeight
                            endfunction
                            
                            "
    1              0.000002 function s:handler.isOpenable(enteredPattern)
                              return 1
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePatternSet(patternBase)
                              return fuf#makePatternSet(a:patternBase, 's:interpretPrimaryPatternForNonPath',
                                    \                   self.partialMatching)
                            endfunction
                            
                            "
    1              0.000003 function s:handler.makePreviewLines(word, count)
                              let items = filter(copy(s:enumHelpTags(self.tagFiles)), 'v:val.word ==# a:word')
                              if empty(items)
                                return []
                              endif
                              let lines = fuf#getFileLines(items[0].path)
                              let index = s:getMatchingIndex(lines, items[0].pattern)
                              return [items[0].path . ':'] + fuf#makePreviewLinesAround(
                                    \ lines, (index < 0 ? [] : [index]), a:count, self.getPreviewHeight() - 1)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getCompleteItems(patternPrimary)
                              return s:enumHelpTags(self.tagFiles)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onOpen(word, mode)
                              call fuf#openHelp(a:word, a:mode)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPre()
                              let self.tagFiles = s:getCurrentHelpTagFiles()
                            endfunction
                            
                            "
    1              0.000001 function s:handler.onModeEnterPost()
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeLeavePost(opened)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/FuzzyFinder/autoload/fuf/givenfile.vim
Sourced 1 time
Total time:   0.000207
 Self time:   0.000156

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (c) 2007-2010 Takeshi NISHIDA
                            "
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1   0.000064   0.000013 if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
                              finish
                            endif
                            
                            " }}}1
                            "=============================================================================
                            " GLOBAL FUNCTIONS {{{1
                            
                            "
    1              0.000004 function fuf#givenfile#createHandler(base)
                              return a:base.concretize(copy(s:handler))
                            endfunction
                            
                            "
    1              0.000003 function fuf#givenfile#getSwitchOrder()
                              return -1
                            endfunction
                            
                            "
    1              0.000003 function fuf#givenfile#getEditableDataNames()
                              return []
                            endfunction
                            
                            "
    1              0.000003 function fuf#givenfile#renewCache()
                            endfunction
                            
                            "
    1              0.000003 function fuf#givenfile#requiresOnCommandPre()
                              return 0
                            endfunction
                            
                            "
    1              0.000002 function fuf#givenfile#onInit()
                            endfunction
                            
                            "
    1              0.000004 function fuf#givenfile#launch(initialPattern, partialMatching, prompt, items)
                              let s:prompt = (empty(a:prompt) ? '>' : a:prompt)
                              let s:items = map(copy(a:items), 'fuf#makePathItem(v:val, "", 0)')
                              call fuf#mapToSetSerialIndex(s:items, 1)
                              call map(s:items, 'fuf#setAbbrWithFormattedWord(v:val, 1)')
                              call fuf#launch(s:MODE_NAME, a:initialPattern, a:partialMatching)
                            endfunction
                            
                            
                            " }}}1
                            "=============================================================================
                            " LOCAL FUNCTIONS/VARIABLES {{{1
                            
    1              0.000005 let s:MODE_NAME = expand('<sfile>:t:r')
                            
                            " }}}1
                            "=============================================================================
                            " s:handler {{{1
                            
    1              0.000002 let s:handler = {}
                            
                            "
    1              0.000002 function s:handler.getModeName()
                              return s:MODE_NAME
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPrompt()
                              return fuf#formatPrompt(s:prompt, self.partialMatching, '')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPreviewHeight()
                              return g:fuf_previewHeight
                            endfunction
                            
                            "
    1              0.000002 function s:handler.isOpenable(enteredPattern)
                              return 1
                            endfunction
                            
                            "
    1              0.000003 function s:handler.makePatternSet(patternBase)
                              return fuf#makePatternSet(a:patternBase, 's:interpretPrimaryPatternForPath',
                                    \                   self.partialMatching)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePreviewLines(word, count)
                              return fuf#makePreviewLinesForFile(a:word, a:count, self.getPreviewHeight())
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getCompleteItems(patternPrimary)
                              return s:items
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onOpen(word, mode)
                              call fuf#openFile(a:word, a:mode, g:fuf_reuseWindow)
                            endfunction
                            
                            
                            "
    1              0.000001 function s:handler.onModeEnterPre()
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPost()
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeLeavePost(opened)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/FuzzyFinder/autoload/fuf/givendir.vim
Sourced 1 time
Total time:   0.000212
 Self time:   0.000161

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (c) 2007-2010 Takeshi NISHIDA
                            "
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1   0.000064   0.000013 if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
                              finish
                            endif
                            
                            " }}}1
                            "=============================================================================
                            " GLOBAL FUNCTIONS {{{1
                            
                            "
    1              0.000004 function fuf#givendir#createHandler(base)
                              return a:base.concretize(copy(s:handler))
                            endfunction
                            
                            "
    1              0.000003 function fuf#givendir#getSwitchOrder()
                              return -1
                            endfunction
                            
                            "
    1              0.000003 function fuf#givendir#getEditableDataNames()
                              return []
                            endfunction
                            
                            "
    1              0.000002 function fuf#givendir#renewCache()
                            endfunction
                            
                            "
    1              0.000003 function fuf#givendir#requiresOnCommandPre()
                              return 0
                            endfunction
                            
                            "
    1              0.000002 function fuf#givendir#onInit()
                            endfunction
                            
                            "
    1              0.000004 function fuf#givendir#launch(initialPattern, partialMatching, prompt, items)
                              let s:prompt = (empty(a:prompt) ? '>' : a:prompt)
                              let s:items = map(copy(a:items), 'substitute(v:val, ''[/\\]\?$'', "", "")')
                              let s:items = map(s:items, 'fuf#makePathItem(v:val, "", 0)')
                              call fuf#mapToSetSerialIndex(s:items, 1)
                              call fuf#mapToSetAbbrWithSnippedWordAsPath(s:items)
                              call fuf#launch(s:MODE_NAME, a:initialPattern, a:partialMatching)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " LOCAL FUNCTIONS/VARIABLES {{{1
                            
    1              0.000005 let s:MODE_NAME = expand('<sfile>:t:r')
                            
                            " }}}1
                            "=============================================================================
                            " s:handler {{{1
                            
    1              0.000002 let s:handler = {}
                            
                            "
    1              0.000002 function s:handler.getModeName()
                              return s:MODE_NAME
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPrompt()
                              return fuf#formatPrompt(s:prompt, self.partialMatching, '')
                            endfunction
                            
                            "
    1              0.000001 function s:handler.getPreviewHeight()
                              return g:fuf_previewHeight
                            endfunction
                            
                            "
    1              0.000002 function s:handler.isOpenable(enteredPattern)
                              return 1
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePatternSet(patternBase)
                              return fuf#makePatternSet(a:patternBase, 's:interpretPrimaryPatternForPath',
                                    \                   self.partialMatching)
                            endfunction
                            
                            "
    1              0.000003 function s:handler.makePreviewLines(word, count)
                              return fuf#makePreviewLinesAround(
                                    \ fuf#glob(fnamemodify(a:word, ':p') . '*'),
                                    \ [], a:count, self.getPreviewHeight())
                              return 
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getCompleteItems(patternPrimary)
                              return s:items
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onOpen(word, mode)
                              execute ':cd ' . fnameescape(a:word)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPre()
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPost()
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeLeavePost(opened)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/FuzzyFinder/autoload/fuf/givencmd.vim
Sourced 1 time
Total time:   0.000221
 Self time:   0.000159

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (c) 2007-2010 Takeshi NISHIDA
                            "
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1   0.000075   0.000013 if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
                              finish
                            endif
                            
                            " }}}1
                            "=============================================================================
                            " GLOBAL FUNCTIONS {{{1
                            
                            "
    1              0.000004 function fuf#givencmd#createHandler(base)
                              return a:base.concretize(copy(s:handler))
                            endfunction
                            
                            "
    1              0.000003 function fuf#givencmd#getSwitchOrder()
                              return -1
                            endfunction
                            
                            "
    1              0.000003 function fuf#givencmd#getEditableDataNames()
                              return []
                            endfunction
                            
                            "
    1              0.000003 function fuf#givencmd#renewCache()
                            endfunction
                            
                            "
    1              0.000003 function fuf#givencmd#requiresOnCommandPre()
                              return 0
                            endfunction
                            
                            "
    1              0.000002 function fuf#givencmd#onInit()
                            endfunction
                            
                            "
    1              0.000004 function fuf#givencmd#launch(initialPattern, partialMatching, prompt, items)
                              let s:prompt = (empty(a:prompt) ? '>' : a:prompt)
                              let s:items = copy(a:items)
                              call map(s:items, 'fuf#makeNonPathItem(v:val, "")')
                              call fuf#mapToSetSerialIndex(s:items, 1)
                              call map(s:items, 'fuf#setAbbrWithFormattedWord(v:val, 1)')
                              call fuf#launch(s:MODE_NAME, a:initialPattern, a:partialMatching)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " LOCAL FUNCTIONS/VARIABLES {{{1
                            
    1              0.000006 let s:MODE_NAME = expand('<sfile>:t:r')
                            
                            " }}}1
                            "=============================================================================
                            " s:handler {{{1
                            
    1              0.000003 let s:handler = {}
                            
                            "
    1              0.000002 function s:handler.getModeName()
                              return s:MODE_NAME
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPrompt()
                              return fuf#formatPrompt(s:prompt, self.partialMatching, '')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPreviewHeight()
                              return 0
                            endfunction
                            
                            "
    1              0.000002 function s:handler.isOpenable(enteredPattern)
                              return 1
                            endfunction
                            
                            "
    1              0.000003 function s:handler.makePatternSet(patternBase)
                              return fuf#makePatternSet(a:patternBase, 's:interpretPrimaryPatternForNonPath',
                                    \                   self.partialMatching)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePreviewLines(word, count)
                              return []
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getCompleteItems(patternPrimary)
                              return s:items
                            endfunction
                            
                            "
    1              0.000003 function s:handler.onOpen(word, mode)
                              if a:word[0] =~# '[:/?]'
                                call histadd(a:word[0], a:word[1:])
                              endif
                              call feedkeys(a:word . "\<CR>", 'n')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPre()
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPost()
                            endfunction
                            
                            "
    1              0.000001 function s:handler.onModeLeavePost(opened)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/FuzzyFinder/autoload/fuf/callbackfile.vim
Sourced 1 time
Total time:   0.000232
 Self time:   0.000167

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (c) 2007-2010 Takeshi NISHIDA
                            "
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1   0.000076   0.000011 if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
                              finish
                            endif
                            
                            " }}}1
                            "=============================================================================
                            " GLOBAL FUNCTIONS {{{1
                            
                            "
    1              0.000004 function fuf#callbackfile#createHandler(base)
                              return a:base.concretize(copy(s:handler))
                            endfunction
                            
                            "
    1              0.000003 function fuf#callbackfile#getSwitchOrder()
                              return -1
                            endfunction
                            
                            "
    1              0.000003 function fuf#callbackfile#getEditableDataNames()
                              return []
                            endfunction
                            
                            "
    1              0.000003 function fuf#callbackfile#renewCache()
                              let s:cache = {}
                            endfunction
                            
                            "
    1              0.000003 function fuf#callbackfile#requiresOnCommandPre()
                              return 0
                            endfunction
                            
                            "
    1              0.000002 function fuf#callbackfile#onInit()
                            endfunction
                            
                            "
    1              0.000004 function fuf#callbackfile#launch(initialPattern, partialMatching, prompt, exclude, listener)
                              let s:prompt = (empty(a:prompt) ? '>' : a:prompt)
                              let s:exclude = a:exclude
                              let s:listener = a:listener
                              call fuf#launch(s:MODE_NAME, a:initialPattern, a:partialMatching)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " LOCAL FUNCTIONS/VARIABLES {{{1
                            
    1              0.000006 let s:MODE_NAME = expand('<sfile>:t:r')
                            
                            "
    1              0.000003 function s:enumItems(dir)
                              let key = getcwd() . g:fuf_ignoreCase . s:exclude . "\n" . a:dir
                              if !exists('s:cache[key]')
                                let s:cache[key] = fuf#enumExpandedDirsEntries(a:dir, s:exclude)
                                if isdirectory(a:dir)
                                  call insert(s:cache[key], fuf#makePathItem(a:dir . '.', '', 0))
                                endif
                                call fuf#mapToSetSerialIndex(s:cache[key], 1)
                                call fuf#mapToSetAbbrWithSnippedWordAsPath(s:cache[key])
                              endif
                              return s:cache[key]
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " s:handler {{{1
                            
    1              0.000003 let s:handler = {}
                            
                            "
    1              0.000002 function s:handler.getModeName()
                              return s:MODE_NAME
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPrompt()
                              return fuf#formatPrompt(s:prompt, self.partialMatching, '')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPreviewHeight()
                              return g:fuf_previewHeight
                            endfunction
                            
                            "
    1              0.000002 function s:handler.isOpenable(enteredPattern)
                              return a:enteredPattern =~# '[^/\\]$'
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePatternSet(patternBase)
                              return fuf#makePatternSet(a:patternBase, 's:interpretPrimaryPatternForPathTail',
                                    \                   self.partialMatching)
                            endfunction
                            
                            "
    1              0.000003 function s:handler.makePreviewLines(word, count)
                              return fuf#makePreviewLinesForFile(a:word, a:count, self.getPreviewHeight())
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getCompleteItems(patternPrimary)
                              let items = copy(s:enumItems(fuf#splitPath(a:patternPrimary).head))
                              return filter(items, 'bufnr("^" . v:val.word . "$") != self.bufNrPrev')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onOpen(word, mode)
                              call s:listener.onComplete(a:word, a:mode)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPre()
                            endfunction
                            
                            "
    1              0.000001 function s:handler.onModeEnterPost()
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeLeavePost(opened)
                              if !a:opened && exists('s:listener.onAbort()')
                                call s:listener.onAbort()
                              endif
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/FuzzyFinder/autoload/fuf/callbackitem.vim
Sourced 1 time
Total time:   0.000231
 Self time:   0.000166

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (c) 2007-2010 Takeshi NISHIDA
                            "
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1   0.000076   0.000011 if !l9#guardScriptLoading(expand('<sfile>:p'), 0, 0, [])
                              finish
                            endif
                            
                            " }}}1
                            "=============================================================================
                            " GLOBAL FUNCTIONS {{{1
                            
                            "
    1              0.000004 function fuf#callbackitem#createHandler(base)
                              return a:base.concretize(copy(s:handler))
                            endfunction
                            
                            "
    1              0.000003 function fuf#callbackitem#getSwitchOrder()
                              return -1
                            endfunction
                            
                            "
    1              0.000004 function fuf#callbackitem#getEditableDataNames()
                              return []
                            endfunction
                            
                            "
    1              0.000003 function fuf#callbackitem#renewCache()
                            endfunction
                            
                            "
    1              0.000003 function fuf#callbackitem#requiresOnCommandPre()
                              return 0
                            endfunction
                            
                            "
    1              0.000002 function fuf#callbackitem#onInit()
                            endfunction
                            
                            "
    1              0.000005 function fuf#callbackitem#launch(initialPattern, partialMatching, prompt, listener, items, forPath)
                              let s:prompt = (empty(a:prompt) ? '>' : a:prompt)
                              let s:listener = a:listener
                              let s:forPath = a:forPath
                              let s:items = copy(a:items)
                              if s:forPath
                                call map(s:items, 'fuf#makePathItem(v:val, "", 1)')
                                call fuf#mapToSetSerialIndex(s:items, 1)
                                call fuf#mapToSetAbbrWithSnippedWordAsPath(s:items)
                              else
                                call map(s:items, 'fuf#makeNonPathItem(v:val, "")')
                                call fuf#mapToSetSerialIndex(s:items, 1)
                                call map(s:items, 'fuf#setAbbrWithFormattedWord(v:val, 1)')
                              endif
                              call fuf#launch(s:MODE_NAME, a:initialPattern, a:partialMatching)
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " LOCAL FUNCTIONS/VARIABLES {{{1
                            
    1              0.000005 let s:MODE_NAME = expand('<sfile>:t:r')
                            
                            " }}}1
                            "=============================================================================
                            " s:handler {{{1
                            
    1              0.000002 let s:handler = {}
                            
                            "
    1              0.000002 function s:handler.getModeName()
                              return s:MODE_NAME
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPrompt()
                              return fuf#formatPrompt(s:prompt, self.partialMatching, '')
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getPreviewHeight()
                              if s:forPath
                                return g:fuf_previewHeight
                              endif
                              return 0
                            endfunction
                            
                            "
    1              0.000002 function s:handler.isOpenable(enteredPattern)
                              return 1
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePatternSet(patternBase)
                              let parser = (s:forPath
                                    \       ? 's:interpretPrimaryPatternForPath'
                                    \       : 's:interpretPrimaryPatternForNonPath')
                              return fuf#makePatternSet(a:patternBase, parser, self.partialMatching)
                            endfunction
                            
                            "
    1              0.000002 function s:handler.makePreviewLines(word, count)
                              if s:forPath
                                return fuf#makePreviewLinesForFile(a:word, a:count, self.getPreviewHeight())
                              endif
                              return []
                            endfunction
                            
                            "
    1              0.000002 function s:handler.getCompleteItems(patternPrimary)
                              return s:items
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onOpen(word, mode)
                              call s:listener.onComplete(a:word, a:mode)
                            endfunction
                            
                            "
    1              0.000001 function s:handler.onModeEnterPre()
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeEnterPost()
                            endfunction
                            
                            "
    1              0.000002 function s:handler.onModeLeavePost(opened)
                              if !a:opened && exists('s:listener.onAbort()')
                                call s:listener.onAbort()
                              endif
                            endfunction
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/L9/plugin/l9.vim
Sourced 1 time
Total time:   0.000221
 Self time:   0.000141

count  total (s)   self (s)
                            "=============================================================================
                            " Copyright (C) 2009-2010 Takeshi NISHIDA
                            "
                            " GetLatestVimScripts: 3252 1 :AutoInstall: L9
                            "=============================================================================
                            " LOAD GUARD {{{1
                            
    1   0.000078   0.000013 if !l9#guardScriptLoading(expand('<sfile>:p'), 702, 0, [])
                              finish
                            endif
                            
                            " }}}1
                            "=============================================================================
                            " OPTIONS: {{{1
                            
    1   0.000022   0.000007 call l9#defineVariableDefault('g:l9_balloonly', 'balloonly.exe')
                            
                            " }}}1
                            "=============================================================================
                            " ASSERTION: {{{1
                            
                            " This command has effect only if $L9_DEBUG is non-zero.
                            " Used as follows:
                            "   L9Assert a:i > 0
                            " This command can't interpret script-local variables directly.
                            "   NG: L9Assert s:a == 1
                            "   OK: execute 'L9Assert ' . s:a . ' == 1'
                            "
    1              0.000003 if $L9_DEBUG
                              command -nargs=* L9Assert call eval((<args>) ? 0 : s:handleFailedAssersion(<q-args>))
                            
                              function s:handleFailedAssersion(expr)
                                echoerr '[L9Assert] Assersion failure: ' . a:expr
                                if input('[L9Assert] Continue? (Y/N) ', 'Y') !=? 'Y'
                                  throw 'L9Assert ' . a:expr
                                endif
                              endfunction
                            
                            else
    1              0.000007   command -nargs=* L9Assert :
    1              0.000001 endif
                            
                            " }}}1
                            "=============================================================================
                            " TIMER: {{{1
                            
                            " These commands have effect only if $L9_TIMER is non-zero.
                            " Used as follows:
                            "   L9Timer foo
                            "     ... (1)
                            "   L9Timer bar
                            "     ... (2)
                            "   L9TimerStop
                            "     ...
                            "   L9TimerDump  <- shows each elapsed time of (1) and (2)
                            "
    1              0.000002 if $L9_TIMER
                              command -nargs=1 L9Timer call s:timerBegin(<q-args>)
                              command -nargs=0 L9TimerStop call s:timerStop()
                              command -nargs=0 L9TimerDump call s:timerDump()
                            
                              let s:timerData = []
                              let s:timerTagMaxLen = 0
                            
                              function s:timerBegin(tag)
                                L9TimerStop
                                let s:timerCurrent = {'tag': strftime('%c ') . a:tag . ' ', 'time': reltime()}
                                let s:timerTagMaxLen = max([len(s:timerCurrent.tag), s:timerTagMaxLen])
                              endfunction
                            
                              function s:timerStop()
                                if !exists('s:timerCurrent')
                                  return
                                endif
                                let s:timerCurrent.time = reltimestr(reltime(s:timerCurrent.time))
                                call add(s:timerData, s:timerCurrent)
                                unlet s:timerCurrent
                              endfunction
                            
                              function s:timerDump()
                                L9TimerStop
                                let lines = map(s:timerData, 'v:val.tag . repeat(" ", s:timerTagMaxLen - len(v:val.tag)) . v:val.time')
                                call l9#tempbuffer#openReadOnly('[l9-timer]', '', lines, 0, 0, 0, {})
                                let s:timerData = []
                                let s:timerTagMaxLen = 0
                              endfunction
                            
                            else
    1              0.000004   command -nargs=1 L9Timer :
    1              0.000003   command -nargs=0 L9TimerStop :
    1              0.000002   command -nargs=0 L9TimerDump :
    1              0.000001 endif
                            
                            " }}}1
                            "=============================================================================
                            " GREP BUFFER: {{{1
                            
                            " Grep for current buffer by l9#grepBuffers()
                            " Used as :L9GrepBuffer/pattern
    1              0.000012 command -nargs=? L9GrepBuffer    call l9#grepBuffers(<q-args>, [bufnr('%')])
                            
                            " Grep for all buffers by l9#grepBuffers()
                            " Used as :L9GrepBufferAll/pattern
    1              0.000012 command -nargs=? L9GrepBufferAll call l9#grepBuffers(<q-args>, range(1, bufnr('$')))
                            
                            " }}}1
                            "=============================================================================
                            " vim: set fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/nerdtree/plugin/NERD_tree.vim
Sourced 1 time
Total time:   0.024668
 Self time:   0.001337

count  total (s)   self (s)
                            " ============================================================================
                            " File:        NERD_tree.vim
                            " Description: vim global plugin that provides a nice tree explorer
                            " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
                            " Last Change: 28 December, 2011
                            " License:     This program is free software. It comes without any warranty,
                            "              to the extent permitted by applicable law. You can redistribute
                            "              it and/or modify it under the terms of the Do What The Fuck You
                            "              Want To Public License, Version 2, as published by Sam Hocevar.
                            "              See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            " ============================================================================
                            "
                            " SECTION: Script init stuff {{{1
                            "============================================================
    1              0.000005 if exists("loaded_nerd_tree")
                                finish
                            endif
    1              0.000002 if v:version < 700
                                echoerr "NERDTree: this plugin requires vim >= 7. DOWNLOAD IT! You'll thank me later!"
                                finish
                            endif
    1              0.000014 let loaded_nerd_tree = 1
                            
                            "for line continuation - i.e dont want C in &cpo
    1              0.000015 let s:old_cpo = &cpo
    1              0.000013 set cpo&vim
                            
                            "Function: s:initVariable() function {{{2
                            "This function is used to initialise a given variable to a given value. The
                            "variable is only initialised if it does not exist prior
                            "
                            "Args:
                            "var: the name of the var to be initialised
                            "value: the value to initialise var to
                            "
                            "Returns:
                            "1 if the var is set, 0 otherwise
    1              0.000005 function! s:initVariable(var, value)
                                if !exists(a:var)
                                    exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
                                    return 1
                                endif
                                return 0
                            endfunction
                            
                            "SECTION: Init variable calls and other random constants {{{2
    1   0.000034   0.000008 call s:initVariable("g:NERDChristmasTree", 1)
    1   0.000029   0.000006 call s:initVariable("g:NERDTreeAutoCenter", 1)
    1   0.000030   0.000007 call s:initVariable("g:NERDTreeAutoCenterThreshold", 3)
    1   0.000029   0.000007 call s:initVariable("g:NERDTreeCaseSensitiveSort", 0)
    1   0.000028   0.000006 call s:initVariable("g:NERDTreeChDirMode", 0)
    1   0.000027   0.000006 call s:initVariable("g:NERDTreeMinimalUI", 0)
    1              0.000004 if !exists("g:NERDTreeIgnore")
                                let g:NERDTreeIgnore = ['\~$']
                            endif
    1   0.000053   0.000030 call s:initVariable("g:NERDTreeBookmarksFile", expand('$HOME') . '/.NERDTreeBookmarks')
    1   0.000029   0.000006 call s:initVariable("g:NERDTreeHighlightCursorline", 1)
    1   0.000028   0.000006 call s:initVariable("g:NERDTreeHijackNetrw", 1)
    1   0.000028   0.000007 call s:initVariable("g:NERDTreeMouseMode", 1)
    1   0.000029   0.000006 call s:initVariable("g:NERDTreeNotificationThreshold", 100)
    1   0.000027   0.000005 call s:initVariable("g:NERDTreeQuitOnOpen", 0)
    1   0.000028   0.000007 call s:initVariable("g:NERDTreeShowBookmarks", 0)
    1   0.000027   0.000006 call s:initVariable("g:NERDTreeShowFiles", 1)
    1   0.000027   0.000006 call s:initVariable("g:NERDTreeShowHidden", 0)
    1   0.000028   0.000007 call s:initVariable("g:NERDTreeShowLineNumbers", 0)
    1   0.000027   0.000006 call s:initVariable("g:NERDTreeSortDirs", 1)
    1              0.000043 call s:initVariable("g:NERDTreeDirArrows", !nerdtree#runningWindows())
    1   0.000031   0.000007 call s:initVariable("g:NERDTreeCasadeOpenSingleChildDir", 1)
                            
    1              0.000004 if !exists("g:NERDTreeSortOrder")
    1              0.000010     let g:NERDTreeSortOrder = ['\/$', '*', '\.swp$',  '\.bak$', '\~$']
    1              0.000001 else
                                "if there isnt a * in the sort sequence then add one
                                if count(g:NERDTreeSortOrder, '*') < 1
                                    call add(g:NERDTreeSortOrder, '*')
                                endif
                            endif
                            
    1              0.000003 if !exists('g:NERDTreeStatusline')
                            
                                "the exists() crap here is a hack to stop vim spazzing out when
                                "loading a session that was created with an open nerd tree. It spazzes
                                "because it doesnt store b:NERDTreeRoot (its a b: var, and its a hash)
    1              0.000009     let g:NERDTreeStatusline = "%{exists('b:NERDTreeRoot')?b:NERDTreeRoot.path.str():''}"
                            
    1              0.000001 endif
    1   0.000028   0.000006 call s:initVariable("g:NERDTreeWinPos", "left")
    1   0.000028   0.000006 call s:initVariable("g:NERDTreeWinSize", 31)
                            
                            "init the shell commands that will be used to copy nodes, and remove dir trees
                            "
                            "Note: the space after the command is important
    1   0.000016   0.000005 if nerdtree#runningWindows()
                                call s:initVariable("g:NERDTreeRemoveDirCmd", 'rmdir /s /q ')
                            else
    1   0.000028   0.000006     call s:initVariable("g:NERDTreeRemoveDirCmd", 'rm -rf ')
    1   0.000028   0.000007     call s:initVariable("g:NERDTreeCopyCmd", 'cp -r ')
    1              0.000001 endif
                            
                            
                            "SECTION: Init variable calls for key mappings {{{2
    1   0.000028   0.000006 call s:initVariable("g:NERDTreeMapActivateNode", "o")
    1   0.000027   0.000006 call s:initVariable("g:NERDTreeMapChangeRoot", "C")
    1   0.000026   0.000010 call s:initVariable("g:NERDTreeMapChdir", "cd")
    1   0.000022   0.000006 call s:initVariable("g:NERDTreeMapCloseChildren", "X")
    1   0.000022   0.000006 call s:initVariable("g:NERDTreeMapCloseDir", "x")
    1   0.000021   0.000005 call s:initVariable("g:NERDTreeMapDeleteBookmark", "D")
    1   0.000022   0.000007 call s:initVariable("g:NERDTreeMapMenu", "m")
    1   0.000021   0.000006 call s:initVariable("g:NERDTreeMapHelp", "?")
    1   0.000022   0.000006 call s:initVariable("g:NERDTreeMapJumpFirstChild", "K")
    1   0.000021   0.000005 call s:initVariable("g:NERDTreeMapJumpLastChild", "J")
    1   0.000022   0.000006 call s:initVariable("g:NERDTreeMapJumpNextSibling", "<C-j>")
    1   0.000021   0.000006 call s:initVariable("g:NERDTreeMapJumpParent", "p")
    1   0.000022   0.000007 call s:initVariable("g:NERDTreeMapJumpPrevSibling", "<C-k>")
    1   0.000021   0.000006 call s:initVariable("g:NERDTreeMapJumpRoot", "P")
    1   0.000021   0.000006 call s:initVariable("g:NERDTreeMapOpenExpl", "e")
    1   0.000021   0.000006 call s:initVariable("g:NERDTreeMapOpenInTab", "t")
    1   0.000022   0.000006 call s:initVariable("g:NERDTreeMapOpenInTabSilent", "T")
    1   0.000021   0.000006 call s:initVariable("g:NERDTreeMapOpenRecursively", "O")
    1   0.000021   0.000006 call s:initVariable("g:NERDTreeMapOpenSplit", "i")
    1   0.000021   0.000005 call s:initVariable("g:NERDTreeMapOpenVSplit", "s")
    1   0.000023   0.000008 call s:initVariable("g:NERDTreeMapPreview", "g" . NERDTreeMapActivateNode)
    1   0.000023   0.000007 call s:initVariable("g:NERDTreeMapPreviewSplit", "g" . NERDTreeMapOpenSplit)
    1   0.000023   0.000007 call s:initVariable("g:NERDTreeMapPreviewVSplit", "g" . NERDTreeMapOpenVSplit)
    1   0.000021   0.000006 call s:initVariable("g:NERDTreeMapQuit", "q")
    1   0.000022   0.000007 call s:initVariable("g:NERDTreeMapRefresh", "r")
    1   0.000022   0.000006 call s:initVariable("g:NERDTreeMapRefreshRoot", "R")
    1   0.000021   0.000006 call s:initVariable("g:NERDTreeMapToggleBookmarks", "B")
    1   0.000021   0.000006 call s:initVariable("g:NERDTreeMapToggleFiles", "F")
    1   0.000021   0.000006 call s:initVariable("g:NERDTreeMapToggleFilters", "f")
    1   0.000021   0.000006 call s:initVariable("g:NERDTreeMapToggleHidden", "I")
    1   0.000021   0.000006 call s:initVariable("g:NERDTreeMapToggleZoom", "A")
    1   0.000021   0.000006 call s:initVariable("g:NERDTreeMapUpdir", "u")
    1   0.000021   0.000005 call s:initVariable("g:NERDTreeMapUpdirKeepOpen", "U")
    1   0.000021   0.000006 call s:initVariable("g:NERDTreeMapCWD", "CD")
                            
                            "SECTION: Load class files{{{2
    1              0.000042 runtime plugin/nerdtree/path.vim
    1              0.000047 runtime plugin/nerdtree/menu_controller.vim
    1              0.000039 runtime plugin/nerdtree/menu_item.vim
    1              0.000039 runtime plugin/nerdtree/key_map.vim
    1              0.000038 runtime plugin/nerdtree/bookmark.vim
    1              0.000041 runtime plugin/nerdtree/tree_file_node.vim
    1              0.000041 runtime plugin/nerdtree/tree_dir_node.vim
    1              0.000039 runtime plugin/nerdtree/opener.vim
    1              0.000057 runtime plugin/nerdtree/creator.vim
                            
                            " SECTION: Commands {{{1
                            "============================================================
                            "init the command that users start the nerd tree with
    1              0.000023 command! -n=? -complete=dir -bar NERDTree :call g:NERDTreeCreator.CreatePrimary('<args>')
    1              0.000013 command! -n=? -complete=dir -bar NERDTreeToggle :call g:NERDTreeCreator.TogglePrimary('<args>')
    1              0.000010 command! -n=0 -bar NERDTreeClose :call nerdtree#closeTreeIfOpen()
    1              0.000013 command! -n=1 -complete=customlist,nerdtree#completeBookmarks -bar NERDTreeFromBookmark call g:NERDTreeCreator.CreatePrimary('<args>')
    1              0.000009 command! -n=0 -bar NERDTreeMirror call g:NERDTreeCreator.CreateMirror()
    1              0.000008 command! -n=0 -bar NERDTreeFind call nerdtree#findAndRevealPath()
    1              0.000008 command! -n=0 -bar NERDTreeFocus call NERDTreeFocus()
    1              0.000006 command! -n=0 -bar NERDTreeCWD call NERDTreeCWD()
                            " SECTION: Auto commands {{{1
                            "============================================================
    1              0.000003 augroup NERDTree
                                "Save the cursor position whenever we close the nerd tree
    1   0.000027   0.000023     exec "autocmd BufWinLeave ". g:NERDTreeCreator.BufNamePrefix() ."* call nerdtree#saveScreenState()"
                            
                                "disallow insert mode in the NERDTree
    1   0.000016   0.000014     exec "autocmd BufEnter ". g:NERDTreeCreator.BufNamePrefix() ."* stopinsert"
    1              0.000001 augroup END
                            
    1              0.000003 if g:NERDTreeHijackNetrw
    1              0.000002     augroup NERDTreeHijackNetrw
    1              0.000007         autocmd VimEnter * silent! autocmd! FileExplorer
    1              0.000006         au BufEnter,VimEnter * call nerdtree#checkForBrowse(expand("<amatch>"))
    1              0.000002     augroup END
    1              0.000001 endif
                            
                            " SECTION: Public API {{{1
                            "============================================================
    1              0.000003 function! NERDTreeAddMenuItem(options)
                                call g:NERDTreeMenuItem.Create(a:options)
                            endfunction
                            
    1              0.000003 function! NERDTreeAddMenuSeparator(...)
                                let opts = a:0 ? a:1 : {}
                                call g:NERDTreeMenuItem.CreateSeparator(opts)
                            endfunction
                            
    1              0.000002 function! NERDTreeAddSubmenu(options)
                                return g:NERDTreeMenuItem.Create(a:options)
                            endfunction
                            
    1              0.000002 function! NERDTreeAddKeyMap(options)
                                call g:NERDTreeKeyMap.Create(a:options)
                            endfunction
                            
    1              0.000002 function! NERDTreeRender()
                                call nerdtree#renderView()
                            endfunction
                            
    1              0.000002 function! NERDTreeFocus()
                                if nerdtree#isTreeOpen()
                                    call nerdtree#putCursorInTreeWin()
                                else
                                    call g:NERDTreeCreator.TogglePrimary("")
                                endif
                            endfunction
                            
    1              0.000003 function! NERDTreeCWD()
                                call NERDTreeFocus()
                                call nerdtree#chRootCwd()
                            endfunction
                            " SECTION: Post Source Actions {{{1
    1   0.015275   0.000011 call nerdtree#postSourceActions()
                            
                            "reset &cpo back to users setting
    1              0.000019 let &cpo = s:old_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/nerdtree/autoload/nerdtree.vim
Sourced 1 time
Total time:   0.001453
 Self time:   0.001453

count  total (s)   self (s)
                            if exists("g:loaded_nerdtree_autoload")
                                finish
                            endif
    1              0.000009 let g:loaded_nerdtree_autoload = 1
                            
    1              0.000003 function! nerdtree#version()
                                return '4.2.0'
                            endfunction
                            
                            " SECTION: General Functions {{{1
                            "============================================================
                            "FUNCTION: nerdtree#bufInWindows(bnum){{{2
                            "[[STOLEN FROM VTREEEXPLORER.VIM]]
                            "Determine the number of windows open to this buffer number.
                            "Care of Yegappan Lakshman.  Thanks!
                            "
                            "Args:
                            "bnum: the subject buffers buffer number
    1              0.000003 function! nerdtree#bufInWindows(bnum)
                                let cnt = 0
                                let winnum = 1
                                while 1
                                    let bufnum = winbufnr(winnum)
                                    if bufnum < 0
                                        break
                                    endif
                                    if bufnum ==# a:bnum
                                        let cnt = cnt + 1
                                    endif
                                    let winnum = winnum + 1
                                endwhile
                            
                                return cnt
                            endfunction
                            
                            "FUNCTION: nerdtree#checkForBrowse(dir) {{{2
                            "inits a secondary nerd tree in the current buffer if appropriate
    1              0.000003 function! nerdtree#checkForBrowse(dir)
                                if a:dir != '' && isdirectory(a:dir)
                                    call g:NERDTreeCreator.CreateSecondary(a:dir)
                                endif
                            endfunction
                            
                            " FUNCTION: nerdtree#completeBookmarks(A,L,P) {{{2
                            " completion function for the bookmark commands
    1              0.000004 function! nerdtree#completeBookmarks(A,L,P)
                                return filter(g:NERDTreeBookmark.BookmarkNames(), 'v:val =~# "^' . a:A . '"')
                            endfunction
                            
                            "FUNCTION: nerdtree#compareBookmarks(dir) {{{2
    1              0.000003 function! nerdtree#compareBookmarks(first, second)
                                return a:first.compareTo(a:second)
                            endfunction
                            
                            "FUNCTION: nerdtree#compareNodes(dir) {{{2
    1              0.000003 function! nerdtree#compareNodes(n1, n2)
                                return a:n1.path.compareTo(a:n2.path)
                            endfunction
                            
                            " FUNCTION: nerdtree#createDefaultBindings() {{{2
    1              0.000003 function! nerdtree#createDefaultBindings()
                                let s = '<SNR>' . s:SID() . '_'
                            
                                call NERDTreeAddKeyMap({ 'key': '<MiddleRelease>', 'scope': "all", 'callback': s."handleMiddleMouse" })
                                call NERDTreeAddKeyMap({ 'key': '<LeftRelease>', 'scope': "all", 'callback': s."handleLeftClick" })
                                call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "DirNode", 'callback': s."activateDirNode" })
                                call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "FileNode", 'callback': s."activateFileNode" })
                                call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "Bookmark", 'callback': s."activateBookmark" })
                                call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "all", 'callback': s."activateAll" })
                            
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "DirNode", 'callback': s."activateDirNode" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "FileNode", 'callback': s."activateFileNode" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "Bookmark", 'callback': s."activateBookmark" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "all", 'callback': s."activateAll" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': "Node", 'callback': s."openHSplit" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': "Node", 'callback': s."openVSplit" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': "Bookmark", 'callback': s."openHSplit" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': "Bookmark", 'callback': s."openVSplit" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': "Node", 'callback': s."previewNodeCurrent" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': "Node", 'callback': s."previewNodeVSplit" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': "Node", 'callback': s."previewNodeHSplit" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': "Bookmark", 'callback': s."previewNodeCurrent" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': "Bookmark", 'callback': s."previewNodeVSplit" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': "Bookmark", 'callback': s."previewNodeHSplit" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenRecursively, 'scope': "DirNode", 'callback': s."openNodeRecursively" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdir, 'scope': "all", 'callback': s."upDirCurrentRootClosed" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdirKeepOpen, 'scope': "all", 'callback': s."upDirCurrentRootOpen" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChangeRoot, 'scope': "Node", 'callback': s."chRoot" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChdir, 'scope': "Node", 'callback': s."chCwd" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapQuit, 'scope': "all", 'callback': s."closeTreeWindow" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCWD, 'scope': "all", 'callback': "nerdtree#chRootCwd" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefreshRoot, 'scope': "all", 'callback': s."refreshRoot" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefresh, 'scope': "Node", 'callback': s."refreshCurrent" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapHelp, 'scope': "all", 'callback': s."displayHelp" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleZoom, 'scope': "all", 'callback': s."toggleZoom" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleHidden, 'scope': "all", 'callback': s."toggleShowHidden" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFilters, 'scope': "all", 'callback': s."toggleIgnoreFilter" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFiles, 'scope': "all", 'callback': s."toggleShowFiles" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleBookmarks, 'scope': "all", 'callback': s."toggleShowBookmarks" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseDir, 'scope': "Node", 'callback': s."closeCurrentDir" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseChildren, 'scope': "DirNode", 'callback': s."closeChildren" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapMenu, 'scope': "Node", 'callback': s."showMenu" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpParent, 'scope': "Node", 'callback': s."jumpToParent" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpFirstChild, 'scope': "Node", 'callback': s."jumpToFirstChild" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpLastChild, 'scope': "Node", 'callback': s."jumpToLastChild" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpRoot, 'scope': "all", 'callback': s."jumpToRoot" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpNextSibling, 'scope': "Node", 'callback': s."jumpToNextSibling" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpPrevSibling, 'scope': "Node", 'callback': s."jumpToPrevSibling" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': "Node", 'callback': s."openInNewTab" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': "Node", 'callback': s."openInNewTabSilent" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': "Bookmark", 'callback': s."openInNewTab" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': "Bookmark", 'callback': s."openInNewTabSilent" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenExpl, 'scope': "DirNode", 'callback': s."openExplorer" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapDeleteBookmark, 'scope': "Bookmark", 'callback': s."deleteBookmark" })
                            endfunction
                            
                            " FUNCTION: nerdtree#deprecated(func, [msg]) {{{2
                            " Issue a deprecation warning for a:func. If a second arg is given, use this
                            " as the deprecation message
    1              0.000004 function! nerdtree#deprecated(func, ...)
                                let msg = a:0 ? a:func . ' ' . a:1 : a:func . ' is deprecated'
                            
                                if !exists('s:deprecationWarnings')
                                    let s:deprecationWarnings = {}
                                endif
                                if !has_key(s:deprecationWarnings, a:func)
                                    let s:deprecationWarnings[a:func] = 1
                                    echomsg msg
                                endif
                            endfunction
                            
                            "FUNCTION: nerdtree#escChars(dir) {{{2
    1              0.000003 function! nerdtree#escChars()
                                if nerdtree#runningWindows()
                                    return " `\|\"#%&,?()\*^<>"
                                endif
                            
                                return " \\`\|\"#%&,?()\*^<>[]"
                            endfunction
                            
                            " FUNCTION: nerdtree#exec(cmd) {{{2
                            " same as :exec cmd  but eventignore=all is set for the duration
    1              0.000003 function! nerdtree#exec(cmd)
                                let old_ei = &ei
                                set ei=all
                                exec a:cmd
                                let &ei = old_ei
                            endfunction
                            
                            " FUNCTION: nerdtree#findAndRevealPath() {{{2
    1              0.000002 function! nerdtree#findAndRevealPath()
                                try
                                    let p = g:NERDTreePath.New(expand("%:p"))
                                catch /^NERDTree.InvalidArgumentsError/
                                    call nerdtree#echo("no file for the current buffer")
                                    return
                                endtry
                            
                                if p.isUnixHiddenPath()
                                    let showhidden=g:NERDTreeShowHidden
                                    let g:NERDTreeShowHidden = 1
                                endif
                            
                                if !nerdtree#treeExistsForTab()
                                    try
                                        let cwd = g:NERDTreePath.New(getcwd())
                                    catch /^NERDTree.InvalidArgumentsError/
                                        call nerdtree#echo("current directory does not exist.")
                                        let cwd = p.getParent()
                                    endtry
                            
                                    if p.isUnder(cwd)
                                        call g:NERDTreeCreator.CreatePrimary(cwd.str())
                                    else
                                        call g:NERDTreeCreator.CreatePrimary(p.getParent().str())
                                    endif
                                else
                                    if !p.isUnder(g:NERDTreeFileNode.GetRootForTab().path)
                                        if !nerdtree#isTreeOpen()
                                            call g:NERDTreeCreator.TogglePrimary('')
                                        else
                                            call nerdtree#putCursorInTreeWin()
                                        endif
                                        let b:NERDTreeShowHidden = g:NERDTreeShowHidden
                                        call nerdtree#chRoot(g:NERDTreeDirNode.New(p.getParent()))
                                    else
                                        if !nerdtree#isTreeOpen()
                                            call g:NERDTreeCreator.TogglePrimary("")
                                        endif
                                    endif
                                endif
                                call nerdtree#putCursorInTreeWin()
                                call b:NERDTreeRoot.reveal(p)
                            
                                if p.isUnixHiddenFile()
                                    let g:NERDTreeShowHidden = showhidden
                                endif
                            endfunction
                            
                            " FUNCTION: nerdtree#has_opt(options, name) {{{2
    1              0.000003 function! nerdtree#has_opt(options, name)
                                return has_key(a:options, a:name) && a:options[a:name] == 1
                            endfunction
                            
                            " FUNCTION: nerdtree#invokeKeyMap(key) {{{2
                            "this is needed since I cant figure out how to invoke dict functions from a
                            "key map
    1              0.000003 function! nerdtree#invokeKeyMap(key)
                                call g:NERDTreeKeyMap.Invoke(a:key)
                            endfunction
                            
                            " FUNCTION: nerdtree#postSourceActions() {{{2
    1              0.000003 function! nerdtree#postSourceActions()
                                call g:NERDTreeBookmark.CacheBookmarks(0)
                                call nerdtree#createDefaultBindings()
                            
                                "load all nerdtree plugins
                                runtime! nerdtree_plugin/**/*.vim
                            endfunction
                            
                            "FUNCTION: nerdtree#runningWindows(dir) {{{2
    1              0.000003 function! nerdtree#runningWindows()
                                return has("win16") || has("win32") || has("win64")
                            endfunction
                            
                            " Function: s:SID()   {{{2
    1              0.000002 function s:SID()
                                if !exists("s:sid")
                                    let s:sid = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
                                endif
                                return s:sid
                            endfun
                            
                            " FUNCTION: nerdtree#tabpagevar(tabnr, var) {{{2
    1              0.000004 function! nerdtree#tabpagevar(tabnr, var)
                                let currentTab = tabpagenr()
                                let old_ei = &ei
                                set ei=all
                            
                                exec "tabnext " . a:tabnr
                                let v = -1
                                if exists('t:' . a:var)
                                    exec 'let v = t:' . a:var
                                endif
                                exec "tabnext " . currentTab
                            
                                let &ei = old_ei
                            
                                return v
                            endfunction
                            
                            " Function: nerdtree#treeExistsForBuffer()   {{{2
                            " Returns 1 if a nerd tree root exists in the current buffer
    1              0.000003 function! nerdtree#treeExistsForBuf()
                                return exists("b:NERDTreeRoot")
                            endfunction
                            
                            " Function: nerdtree#treeExistsForTab()   {{{2
                            " Returns 1 if a nerd tree root exists in the current tab
    1              0.000003 function! nerdtree#treeExistsForTab()
                                return exists("t:NERDTreeBufName")
                            endfunction
                            
                            "FUNCTION: nerdtree#treeMarkupReg(dir) {{{2
    1              0.000003 function! nerdtree#treeMarkupReg()
                                if g:NERDTreeDirArrows
                                    return '^\([▾▸] \| \+[▾▸] \| \+\)'
                                endif
                            
                                return '^[ `|]*[\-+~]'
                            endfunction
                            
                            "FUNCTION: nerdtree#treeUpDirLine(dir) {{{2
    1              0.000002 function! nerdtree#treeUpDirLine()
                                return '.. (up a dir)'
                            endfunction
                            
                            "FUNCTION: nerdtree#treeWid(dir) {{{2
    1              0.000002 function! nerdtree#treeWid()
                                return 2
                            endfunction
                            
                            "FUNCTION: nerdtree#upDir(keepState) {{{2
                            "moves the tree up a level
                            "
                            "Args:
                            "keepState: 1 if the current root should be left open when the tree is
                            "re-rendered
    1              0.000003 function! nerdtree#upDir(keepState)
                                let cwd = b:NERDTreeRoot.path.str({'format': 'UI'})
                                if cwd ==# "/" || cwd =~# '^[^/]..$'
                                    call nerdtree#echo("already at top dir")
                                else
                                    if !a:keepState
                                        call b:NERDTreeRoot.close()
                                    endif
                            
                                    let oldRoot = b:NERDTreeRoot
                            
                                    if empty(b:NERDTreeRoot.parent)
                                        let path = b:NERDTreeRoot.path.getParent()
                                        let newRoot = g:NERDTreeDirNode.New(path)
                                        call newRoot.open()
                                        call newRoot.transplantChild(b:NERDTreeRoot)
                                        let b:NERDTreeRoot = newRoot
                                    else
                                        let b:NERDTreeRoot = b:NERDTreeRoot.parent
                                    endif
                            
                                    if g:NERDTreeChDirMode ==# 2
                                        call b:NERDTreeRoot.path.changeToDir()
                                    endif
                            
                                    call nerdtree#renderView()
                                    call oldRoot.putCursorHere(0, 0)
                                endif
                            endfunction
                            
                            " Function: nerdtree#unique(list)   {{{2
                            " returns a:list without duplicates
    1              0.000003 function! nerdtree#unique(list)
                              let uniqlist = []
                              for elem in a:list
                                if index(uniqlist, elem) ==# -1
                                  let uniqlist += [elem]
                                endif
                              endfor
                              return uniqlist
                            endfunction
                            
                            " SECTION: View Functions {{{1
                            "============================================================
                            "
                            "FUNCTION: nerdtree#centerView() {{{2
                            "centers the nerd tree window around the cursor (provided the nerd tree
                            "options permit)
    1              0.000003 function! nerdtree#centerView()
                                if g:NERDTreeAutoCenter
                                    let current_line = winline()
                                    let lines_to_top = current_line
                                    let lines_to_bottom = winheight(nerdtree#getTreeWinNum()) - current_line
                                    if lines_to_top < g:NERDTreeAutoCenterThreshold || lines_to_bottom < g:NERDTreeAutoCenterThreshold
                                        normal! zz
                                    endif
                                endif
                            endfunction
                            
                            " FUNCTION: nerdtree#chRoot(node) {{{2
                            " changes the current root to the selected one
    1              0.000003 function! nerdtree#chRoot(node)
                                call s:chRoot(a:node)
                            endfunction
                            "FUNCTION: nerdtree#closeTree() {{{2
                            "Closes the primary NERD tree window for this tab
    1              0.000003 function! nerdtree#closeTree()
                                if !nerdtree#isTreeOpen()
                                    throw "NERDTree.NoTreeFoundError: no NERDTree is open"
                                endif
                            
                                if winnr("$") != 1
                                    if winnr() == nerdtree#getTreeWinNum()
                                        call nerdtree#exec("wincmd p")
                                        let bufnr = bufnr("")
                                        call nerdtree#exec("wincmd p")
                                    else
                                        let bufnr = bufnr("")
                                    endif
                            
                                    call nerdtree#exec(nerdtree#getTreeWinNum() . " wincmd w")
                                    close
                                    call nerdtree#exec(bufwinnr(bufnr) . " wincmd w")
                                else
                                    close
                                endif
                            endfunction
                            
                            "FUNCTION: nerdtree#closeTreeIfOpen() {{{2
                            "Closes the NERD tree window if it is open
    1              0.000003 function! nerdtree#closeTreeIfOpen()
                               if nerdtree#isTreeOpen()
                                  call nerdtree#closeTree()
                               endif
                            endfunction
                            
                            "FUNCTION: nerdtree#closeTreeIfQuitOnOpen() {{{2
                            "Closes the NERD tree window if the close on open option is set
    1              0.000004 function! nerdtree#closeTreeIfQuitOnOpen()
                                if g:NERDTreeQuitOnOpen && nerdtree#isTreeOpen()
                                    call nerdtree#closeTree()
                                endif
                            endfunction
                            
                            "FUNCTION: nerdtree#dumpHelp  {{{2
                            "prints out the quick help
    1              0.000003 function! nerdtree#dumpHelp()
                                let old_h = @h
                                if b:treeShowHelp ==# 1
                                    let @h=   "\" NERD tree (" . nerdtree#version() . ") quickhelp~\n"
                                    let @h=@h."\" ============================\n"
                                    let @h=@h."\" File node mappings~\n"
                                    let @h=@h."\" ". (g:NERDTreeMouseMode ==# 3 ? "single" : "double") ."-click,\n"
                                    let @h=@h."\" <CR>,\n"
                                    if b:NERDTreeType ==# "primary"
                                        let @h=@h."\" ". g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let @h=@h."\" ". g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if b:NERDTreeType ==# "primary"
                                        let @h=@h."\" ". g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let @h=@h."\" middle-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenSplit .": open split\n"
                                    let @h=@h."\" ". g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let @h=@h."\" ". g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Directory node mappings~\n"
                                    let @h=@h."\" ". (g:NERDTreeMouseMode ==# 1 ? "double" : "single") ."-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapActivateNode .": open & close node\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let @h=@h."\" ". g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let @h=@h."\" ". g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let @h=@h."\"    current node recursively\n"
                                    let @h=@h."\" middle-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Bookmark table mappings~\n"
                                    let @h=@h."\" double-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let @h=@h."\" ". g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Tree navigation mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpRoot .": go to root\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpParent .": go to parent\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Filesystem mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let @h=@h."\"    selected dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let @h=@h."\"    but leave old root open\n"
                                    let @h=@h."\" ". g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let @h=@h."\" ". g:NERDTreeMapMenu .": Show menu\n"
                                    let @h=@h."\" ". g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let @h=@h."\"    selected dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Tree filtering mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleHidden .": hidden files (" . (b:NERDTreeShowHidden ? "on" : "off") . ")\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleFilters .": file filters (" . (b:NERDTreeIgnoreEnabled ? "on" : "off") . ")\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleFiles .": files (" . (b:NERDTreeShowFiles ? "on" : "off") . ")\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleBookmarks .": bookmarks (" . (b:NERDTreeShowBookmarks ? "on" : "off") . ")\n"
                            
                                    "add quickhelp entries for each custom key map
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let @h=@h."\" ". i.key .": ". i.quickhelpText ."\n"
                                        endif
                                    endfor
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Other mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let @h=@h."\"    the NERDTree window\n"
                                    let @h=@h."\" ". g:NERDTreeMapHelp .": toggle help\n"
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Bookmark commands~\n"
                                    let @h=@h."\" :Bookmark <name>\n"
                                    let @h=@h."\" :BookmarkToRoot <name>\n"
                                    let @h=@h."\" :RevealBookmark <name>\n"
                                    let @h=@h."\" :OpenBookmark <name>\n"
                                    let @h=@h."\" :ClearBookmarks [<names>]\n"
                                    let @h=@h."\" :ClearAllBookmarks\n"
                                    silent! put h
                                elseif g:NERDTreeMinimalUI == 0
                                    let @h="\" Press ". g:NERDTreeMapHelp ." for help\n"
                                    silent! put h
                                endif
                            
                                let @h = old_h
                            endfunction
                            
                            "FUNCTION: nerdtree#echo  {{{2
                            "A wrapper for :echo. Appends 'NERDTree:' on the front of all messages
                            "
                            "Args:
                            "msg: the message to echo
    1              0.000004 function! nerdtree#echo(msg)
                                redraw
                                echomsg "NERDTree: " . a:msg
                            endfunction
                            
                            "FUNCTION: nerdtree#echoError {{{2
                            "Wrapper for nerdtree#echo, sets the message type to errormsg for this message
                            "Args:
                            "msg: the message to echo
    1              0.000003 function! nerdtree#echoError(msg)
                                echohl errormsg
                                call nerdtree#echo(a:msg)
                                echohl normal
                            endfunction
                            
                            "FUNCTION: nerdtree#echoWarning {{{2
                            "Wrapper for nerdtree#echo, sets the message type to warningmsg for this message
                            "Args:
                            "msg: the message to echo
    1              0.000003 function! nerdtree#echoWarning(msg)
                                echohl warningmsg
                                call nerdtree#echo(a:msg)
                                echohl normal
                            endfunction
                            
                            "FUNCTION: nerdtree#firstUsableWindow(){{{2
                            "find the window number of the first normal window
    1              0.000003 function! nerdtree#firstUsableWindow()
                                let i = 1
                                while i <= winnr("$")
                                    let bnum = winbufnr(i)
                                    if bnum != -1 && getbufvar(bnum, '&buftype') ==# ''
                                                \ && !getwinvar(i, '&previewwindow')
                                                \ && (!getbufvar(bnum, '&modified') || &hidden)
                                        return i
                                    endif
                            
                                    let i += 1
                                endwhile
                                return -1
                            endfunction
                            
                            "FUNCTION: nerdtree#getPath(ln) {{{2
                            "Gets the full path to the node that is rendered on the given line number
                            "
                            "Args:
                            "ln: the line number to get the path for
                            "
                            "Return:
                            "A path if a node was selected, {} if nothing is selected.
                            "If the 'up a dir' line was selected then the path to the parent of the
                            "current root is returned
    1              0.000002 function! nerdtree#getPath(ln)
                                let line = getline(a:ln)
                            
                                let rootLine = g:NERDTreeFileNode.GetRootLineNum()
                            
                                "check to see if we have the root node
                                if a:ln == rootLine
                                    return b:NERDTreeRoot.path
                                endif
                            
                                if !g:NERDTreeDirArrows
                                    " in case called from outside the tree
                                    if line !~# '^ *[|`▸▾ ]' || line =~# '^$'
                                        return {}
                                    endif
                                endif
                            
                                if line ==# nerdtree#treeUpDirLine()
                                    return b:NERDTreeRoot.path.getParent()
                                endif
                            
                                let indent = nerdtree#indentLevelFor(line)
                            
                                "remove the tree parts and the leading space
                                let curFile = nerdtree#stripMarkupFromLine(line, 0)
                            
                                let wasdir = 0
                                if curFile =~# '/$'
                                    let wasdir = 1
                                    let curFile = substitute(curFile, '/\?$', '/', "")
                                endif
                            
                                let dir = ""
                                let lnum = a:ln
                                while lnum > 0
                                    let lnum = lnum - 1
                                    let curLine = getline(lnum)
                                    let curLineStripped = nerdtree#stripMarkupFromLine(curLine, 1)
                            
                                    "have we reached the top of the tree?
                                    if lnum == rootLine
                                        let dir = b:NERDTreeRoot.path.str({'format': 'UI'}) . dir
                                        break
                                    endif
                                    if curLineStripped =~# '/$'
                                        let lpindent = nerdtree#indentLevelFor(curLine)
                                        if lpindent < indent
                                            let indent = indent - 1
                            
                                            let dir = substitute (curLineStripped,'^\\', "", "") . dir
                                            continue
                                        endif
                                    endif
                                endwhile
                                let curFile = b:NERDTreeRoot.path.drive . dir . curFile
                                let toReturn = g:NERDTreePath.New(curFile)
                                return toReturn
                            endfunction
                            
                            "FUNCTION: nerdtree#getTreeWinNum() {{{2
                            "gets the nerd tree window number for this tab
    1              0.000003 function! nerdtree#getTreeWinNum()
                                if exists("t:NERDTreeBufName")
                                    return bufwinnr(t:NERDTreeBufName)
                                else
                                    return -1
                                endif
                            endfunction
                            
                            "FUNCTION: nerdtree#indentLevelFor(line) {{{2
    1              0.000003 function! nerdtree#indentLevelFor(line)
                                let level = match(a:line, '[^ \-+~▸▾`|]') / nerdtree#treeWid()
                                " check if line includes arrows
                                if match(a:line, '[▸▾]') > -1
                                    " decrement level as arrow uses 3 ascii chars
                                    let level = level - 1
                                endif
                                return level
                            endfunction
                            
                            "FUNCTION: nerdtree#isTreeOpen() {{{2
    1              0.000003 function! nerdtree#isTreeOpen()
                                return nerdtree#getTreeWinNum() != -1
                            endfunction
                            
                            "FUNCTION: nerdtree#isWindowUsable(winnumber) {{{2
                            "Returns 0 if opening a file from the tree in the given window requires it to
                            "be split, 1 otherwise
                            "
                            "Args:
                            "winnumber: the number of the window in question
    1              0.000003 function! nerdtree#isWindowUsable(winnumber)
                                "gotta split if theres only one window (i.e. the NERD tree)
                                if winnr("$") ==# 1
                                    return 0
                                endif
                            
                                let oldwinnr = winnr()
                                call nerdtree#exec(a:winnumber . "wincmd p")
                                let specialWindow = getbufvar("%", '&buftype') != '' || getwinvar('%', '&previewwindow')
                                let modified = &modified
                                call nerdtree#exec(oldwinnr . "wincmd p")
                            
                                "if its a special window e.g. quickfix or another explorer plugin then we
                                "have to split
                                if specialWindow
                                    return 0
                                endif
                            
                                if &hidden
                                    return 1
                                endif
                            
                                return !modified || nerdtree#bufInWindows(winbufnr(a:winnumber)) >= 2
                            endfunction
                            
                            " FUNCTION: nerdtree#jumpToChild(direction) {{{2
                            " Args:
                            " direction: 0 if going to first child, 1 if going to last
    1              0.000004 function! nerdtree#jumpToChild(currentNode, direction)
                                if a:currentNode.isRoot()
                                    return nerdtree#echo("cannot jump to " . (a:direction ? "last" : "first") .  " child")
                                end
                                let dirNode = a:currentNode.parent
                                let childNodes = dirNode.getVisibleChildren()
                            
                                let targetNode = childNodes[0]
                                if a:direction
                                    let targetNode = childNodes[len(childNodes) - 1]
                                endif
                            
                                if targetNode.equals(a:currentNode)
                                    let siblingDir = a:currentNode.parent.findOpenDirSiblingWithVisibleChildren(a:direction)
                                    if siblingDir != {}
                                        let indx = a:direction ? siblingDir.getVisibleChildCount()-1 : 0
                                        let targetNode = siblingDir.getChildByIndex(indx, 1)
                                    endif
                                endif
                            
                                call targetNode.putCursorHere(1, 0)
                            
                                call nerdtree#centerView()
                            endfunction
                            
                            " FUNCTION: nerdtree#jumpToSibling(currentNode, forward) {{{2
                            " moves the cursor to the sibling of the current node in the given direction
                            "
                            " Args:
                            " forward: 1 if the cursor should move to the next sibling, 0 if it should
                            " move back to the previous sibling
    1              0.000004 function! nerdtree#jumpToSibling(currentNode, forward)
                                let sibling = a:currentNode.findSibling(a:forward)
                            
                                if !empty(sibling)
                                    call sibling.putCursorHere(1, 0)
                                    call nerdtree#centerView()
                                endif
                            endfunction
                            
                            "FUNCTION: nerdtree#promptToDelBuffer(bufnum, msg){{{2
                            "prints out the given msg and, if the user responds by pushing 'y' then the
                            "buffer with the given bufnum is deleted
                            "
                            "Args:
                            "bufnum: the buffer that may be deleted
                            "msg: a message that will be echoed to the user asking them if they wish to
                            "     del the buffer
    1              0.000004 function! nerdtree#promptToDelBuffer(bufnum, msg)
                                echo a:msg
                                if nr2char(getchar()) ==# 'y'
                                    exec "silent bdelete! " . a:bufnum
                                endif
                            endfunction
                            
                            "FUNCTION: nerdtree#putCursorOnBookmarkTable(){{{2
                            "Places the cursor at the top of the bookmarks table
    1              0.000003 function! nerdtree#putCursorOnBookmarkTable()
                                if !b:NERDTreeShowBookmarks
                                    throw "NERDTree.IllegalOperationError: cant find bookmark table, bookmarks arent active"
                                endif
                            
                                if g:NERDTreeMinimalUI
                                    return cursor(1, 2)
                                endif
                            
                                let rootNodeLine = g:NERDTreeFileNode.GetRootLineNum()
                            
                                let line = 1
                                while getline(line) !~# '^>-\+Bookmarks-\+$'
                                    let line = line + 1
                                    if line >= rootNodeLine
                                        throw "NERDTree.BookmarkTableNotFoundError: didnt find the bookmarks table"
                                    endif
                                endwhile
                                call cursor(line, 2)
                            endfunction
                            
                            "FUNCTION: nerdtree#putCursorInTreeWin(){{{2
                            "Places the cursor in the nerd tree window
    1              0.000003 function! nerdtree#putCursorInTreeWin()
                                if !nerdtree#isTreeOpen()
                                    throw "NERDTree.InvalidOperationError: cant put cursor in NERD tree window, no window exists"
                                endif
                            
                                call nerdtree#exec(nerdtree#getTreeWinNum() . "wincmd w")
                            endfunction
                            
                            "FUNCTION: nerdtree#renderBookmarks {{{2
    1              0.000002 function! nerdtree#renderBookmarks()
                            
                                if g:NERDTreeMinimalUI == 0
                                    call setline(line(".")+1, ">----------Bookmarks----------")
                                    call cursor(line(".")+1, col("."))
                                endif
                            
                                for i in g:NERDTreeBookmark.Bookmarks()
                                    call setline(line(".")+1, i.str())
                                    call cursor(line(".")+1, col("."))
                                endfor
                            
                                call setline(line(".")+1, '')
                                call cursor(line(".")+1, col("."))
                            endfunction
                            
                            "FUNCTION: nerdtree#renderView {{{2
                            "The entry function for rendering the tree
    1              0.000004 function! nerdtree#renderView()
                                setlocal modifiable
                            
                                "remember the top line of the buffer and the current line so we can
                                "restore the view exactly how it was
                                let curLine = line(".")
                                let curCol = col(".")
                                let topLine = line("w0")
                            
                                "delete all lines in the buffer (being careful not to clobber a register)
                                silent 1,$delete _
                            
                                call nerdtree#dumpHelp()
                            
                                "delete the blank line before the help and add one after it
                                if g:NERDTreeMinimalUI == 0
                                    call setline(line(".")+1, "")
                                    call cursor(line(".")+1, col("."))
                                endif
                            
                                if b:NERDTreeShowBookmarks
                                    call nerdtree#renderBookmarks()
                                endif
                            
                                "add the 'up a dir' line
                                if !g:NERDTreeMinimalUI
                                    call setline(line(".")+1, nerdtree#treeUpDirLine())
                                    call cursor(line(".")+1, col("."))
                                endif
                            
                                "draw the header line
                                let header = b:NERDTreeRoot.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
                                call setline(line(".")+1, header)
                                call cursor(line(".")+1, col("."))
                            
                                "draw the tree
                                let old_o = @o
                                let @o = b:NERDTreeRoot.renderToString()
                                silent put o
                                let @o = old_o
                            
                                "delete the blank line at the top of the buffer
                                silent 1,1delete _
                            
                                "restore the view
                                let old_scrolloff=&scrolloff
                                let &scrolloff=0
                                call cursor(topLine, 1)
                                normal! zt
                                call cursor(curLine, curCol)
                                let &scrolloff = old_scrolloff
                            
                                setlocal nomodifiable
                            endfunction
                            
                            "FUNCTION: nerdtree#renderViewSavingPosition {{{2
                            "Renders the tree and ensures the cursor stays on the current node or the
                            "current nodes parent if it is no longer available upon re-rendering
    1              0.000004 function! nerdtree#renderViewSavingPosition()
                                let currentNode = g:NERDTreeFileNode.GetSelected()
                            
                                "go up the tree till we find a node that will be visible or till we run
                                "out of nodes
                                while currentNode != {} && !currentNode.isVisible() && !currentNode.isRoot()
                                    let currentNode = currentNode.parent
                                endwhile
                            
                                call nerdtree#renderView()
                            
                                if currentNode != {}
                                    call currentNode.putCursorHere(0, 0)
                                endif
                            endfunction
                            "
                            "FUNCTION: nerdtree#restoreScreenState() {{{2
                            "
                            "Sets the screen state back to what it was when nerdtree#saveScreenState was last
                            "called.
                            "
                            "Assumes the cursor is in the NERDTree window
    1              0.000003 function! nerdtree#restoreScreenState()
                                if !exists("b:NERDTreeOldTopLine") || !exists("b:NERDTreeOldPos") || !exists("b:NERDTreeOldWindowSize")
                                    return
                                endif
                                exec("silent vertical resize ".b:NERDTreeOldWindowSize)
                            
                                let old_scrolloff=&scrolloff
                                let &scrolloff=0
                                call cursor(b:NERDTreeOldTopLine, 0)
                                normal! zt
                                call setpos(".", b:NERDTreeOldPos)
                                let &scrolloff=old_scrolloff
                            endfunction
                            
                            "FUNCTION: nerdtree#saveScreenState() {{{2
                            "Saves the current cursor position in the current buffer and the window
                            "scroll position
    1              0.000002 function! nerdtree#saveScreenState()
                                let win = winnr()
                                try
                                    call nerdtree#putCursorInTreeWin()
                                    let b:NERDTreeOldPos = getpos(".")
                                    let b:NERDTreeOldTopLine = line("w0")
                                    let b:NERDTreeOldWindowSize = winwidth("")
                                    call nerdtree#exec(win . "wincmd w")
                                catch /^NERDTree.InvalidOperationError/
                                endtry
                            endfunction
                            
                            "FUNCTION: nerdtree#stripMarkupFromLine(line, removeLeadingSpaces){{{2
                            "returns the given line with all the tree parts stripped off
                            "
                            "Args:
                            "line: the subject line
                            "removeLeadingSpaces: 1 if leading spaces are to be removed (leading spaces =
                            "any spaces before the actual text of the node)
    1              0.000003 function! nerdtree#stripMarkupFromLine(line, removeLeadingSpaces)
                                let line = a:line
                                "remove the tree parts and the leading space
                                let line = substitute (line, nerdtree#treeMarkupReg(),"","")
                            
                                "strip off any read only flag
                                let line = substitute (line, ' \[RO\]', "","")
                            
                                "strip off any bookmark flags
                                let line = substitute (line, ' {[^}]*}', "","")
                            
                                "strip off any executable flags
                                let line = substitute (line, '*\ze\($\| \)', "","")
                            
                                let wasdir = 0
                                if line =~# '/$'
                                    let wasdir = 1
                                endif
                                let line = substitute (line,' -> .*',"","") " remove link to
                                if wasdir ==# 1
                                    let line = substitute (line, '/\?$', '/', "")
                                endif
                            
                                if a:removeLeadingSpaces
                                    let line = substitute (line, '^ *', '', '')
                                endif
                            
                                return line
                            endfunction
                            
                            "SECTION: Interface bindings {{{1
                            "============================================================
                            
                            "FUNCTION: s:activateAll() {{{2
                            "handle the user activating the updir line
    1              0.000003 function! s:activateAll()
                                if getline(".") ==# nerdtree#treeUpDirLine()
                                    return nerdtree#upDir(0)
                                endif
                            endfunction
                            "FUNCTION: s:activateDirNode() {{{2
                            "handle the user activating a tree node
    1              0.000002 function! s:activateDirNode(node)
                                call a:node.activate({'reuse': 1})
                            endfunction
                            
                            "FUNCTION: s:activateFileNode() {{{2
                            "handle the user activating a tree node
    1              0.000002 function! s:activateFileNode(node)
                                call a:node.activate({'reuse': 1, 'where': 'p'})
                            endfunction
                            
                            "FUNCTION: s:activateBookmark() {{{2
                            "handle the user activating a bookmark
    1              0.000002 function! s:activateBookmark(bm)
                                call a:bm.activate(!a:bm.path.isDirectory ? {'where': 'p'} : {})
                            endfunction
                            
                            " FUNCTION: nerdtree#bookmarkNode(name) {{{2
                            " Associate the current node with the given name
    1              0.000003 function! nerdtree#bookmarkNode(...)
                                let currentNode = g:NERDTreeFileNode.GetSelected()
                                if currentNode != {}
                                    let name = a:1
                                    if empty(name)
                                        let name = currentNode.path.getLastPathComponent(0)
                                    endif
                                    try
                                        call currentNode.bookmark(name)
                                        call nerdtree#renderView()
                                    catch /^NERDTree.IllegalBookmarkNameError/
                                        call nerdtree#echo("bookmark names must not contain spaces")
                                    endtry
                                else
                                    call nerdtree#echo("select a node first")
                                endif
                            endfunction
                            
                            " FUNCTION: s:chCwd(node) {{{2
    1              0.000002 function! s:chCwd(node)
                                try
                                    call a:node.path.changeToDir()
                                catch /^NERDTree.PathChangeError/
                                    call nerdtree#echoWarning("could not change cwd")
                                endtry
                            endfunction
                            
                            " FUNCTION: s:chRoot(node) {{{2
                            " changes the current root to the selected one
    1              0.000002 function! s:chRoot(node)
                                call a:node.makeRoot()
                                call nerdtree#renderView()
                                call b:NERDTreeRoot.putCursorHere(0, 0)
                            endfunction
                            
                            " FUNCTION: s:chRootCwd() {{{2
                            " changes the current root to CWD
    1              0.000003 function! nerdtree#chRootCwd()
                                try
                                    let cwd = g:NERDTreePath.New(getcwd())
                                catch /^NERDTree.InvalidArgumentsError/
                                    call nerdtree#echo("current directory does not exist.")
                                    return
                                endtry
                                if cwd.str() == g:NERDTreeFileNode.GetRootForTab().path.str()
                                   return
                                endif
                                call nerdtree#chRoot(g:NERDTreeDirNode.New(cwd))
                            endfunction
                            
                            " FUNCTION: nerdtree#clearBookmarks(bookmarks) {{{2
    1              0.000003 function! nerdtree#clearBookmarks(bookmarks)
                                if a:bookmarks ==# ''
                                    let currentNode = g:NERDTreeFileNode.GetSelected()
                                    if currentNode != {}
                                        call currentNode.clearBookmarks()
                                    endif
                                else
                                    for name in split(a:bookmarks, ' ')
                                        let bookmark = g:NERDTreeBookmark.BookmarkFor(name)
                                        call bookmark.delete()
                                    endfor
                                endif
                                call nerdtree#renderView()
                            endfunction
                            
                            " FUNCTION: s:closeChildren(node) {{{2
                            " closes all childnodes of the current node
    1              0.000002 function! s:closeChildren(node)
                                call a:node.closeChildren()
                                call nerdtree#renderView()
                                call a:node.putCursorHere(0, 0)
                            endfunction
                            
                            " FUNCTION: s:closeCurrentDir(node) {{{2
                            " closes the parent dir of the current node
    1              0.000003 function! s:closeCurrentDir(node)
                                let parent = a:node.parent
                                if parent ==# {} || parent.isRoot()
                                    call nerdtree#echo("cannot close tree root")
                                else
                                    call a:node.parent.close()
                                    call nerdtree#renderView()
                                    call a:node.parent.putCursorHere(0, 0)
                                endif
                            endfunction
                            
                            " FUNCTION: s:closeTreeWindow() {{{2
                            " close the tree window
    1              0.000003 function! s:closeTreeWindow()
                                if b:NERDTreeType ==# "secondary" && b:NERDTreePreviousBuf != -1
                                    exec "buffer " . b:NERDTreePreviousBuf
                                else
                                    if winnr("$") > 1
                                        call nerdtree#closeTree()
                                    else
                                        call nerdtree#echo("Cannot close last window")
                                    endif
                                endif
                            endfunction
                            
                            " FUNCTION: s:deleteBookmark(bm) {{{2
                            " if the cursor is on a bookmark, prompt to delete
    1              0.000003 function! s:deleteBookmark(bm)
                                echo  "Are you sure you wish to delete the bookmark:\n\"" . a:bm.name . "\" (yN):"
                            
                                if  nr2char(getchar()) ==# 'y'
                                    try
                                        call a:bm.delete()
                                        call nerdtree#renderView()
                                        redraw
                                    catch /^NERDTree/
                                        call nerdtree#echoWarning("Could not remove bookmark")
                                    endtry
                                else
                                    call nerdtree#echo("delete aborted" )
                                endif
                            
                            endfunction
                            
                            " FUNCTION: s:displayHelp() {{{2
                            " toggles the help display
    1              0.000002 function! s:displayHelp()
                                let b:treeShowHelp = b:treeShowHelp ? 0 : 1
                                call nerdtree#renderView()
                                call nerdtree#centerView()
                            endfunction
                            
                            "FUNCTION: s:handleLeftClick() {{{2
                            "Checks if the click should open the current node
    1              0.000003 function! s:handleLeftClick()
                                let currentNode = g:NERDTreeFileNode.GetSelected()
                                if currentNode != {}
                            
                                    "the dir arrows are multibyte chars, and vim's string functions only
                                    "deal with single bytes - so split the line up with the hack below and
                                    "take the line substring manually
                                    let line = split(getline(line(".")), '\zs')
                                    let startToCur = ""
                                    for i in range(0,len(line)-1)
                                        let startToCur .= line[i]
                                    endfor
                            
                                    if currentNode.path.isDirectory
                                        if startToCur =~# nerdtree#treeMarkupReg() && startToCur =~# '[+~▾▸] \?$'
                                            call currentNode.activate()
                                            return
                                        endif
                                    endif
                            
                                    if (g:NERDTreeMouseMode ==# 2 && currentNode.path.isDirectory) || g:NERDTreeMouseMode ==# 3
                                        let char = strpart(startToCur, strlen(startToCur)-1, 1)
                                        if char !~# nerdtree#treeMarkupReg()
                                            if currentNode.path.isDirectory
                                                call currentNode.activate()
                                            else
                                                call currentNode.activate({'reuse': 1, 'where': 'p'})
                                            endif
                                            return
                                        endif
                                    endif
                                endif
                            endfunction
                            
                            " FUNCTION: s:handleMiddleMouse() {{{2
    1              0.000002 function! s:handleMiddleMouse()
                                let curNode = g:NERDTreeFileNode.GetSelected()
                                if curNode ==# {}
                                    call nerdtree#echo("Put the cursor on a node first" )
                                    return
                                endif
                            
                                if curNode.path.isDirectory
                                    call nerdtree#openExplorer(curNode)
                                else
                                    call curNode.open({'where': 'h'})
                                endif
                            endfunction
                            
                            " FUNCTION: s:jumpToFirstChild() {{{2
                            " wrapper for the jump to child method
    1              0.000003 function! s:jumpToFirstChild(node)
                                call nerdtree#jumpToChild(a:node, 0)
                            endfunction
                            
                            " FUNCTION: s:jumpToLastChild() {{{2
                            " wrapper for the jump to child method
    1              0.000002 function! s:jumpToLastChild(node)
                                call nerdtree#jumpToChild(a:node, 1)
                            endfunction
                            
                            " FUNCTION: s:jumpToParent(node) {{{2
                            " moves the cursor to the parent of the current node
    1              0.000002 function! s:jumpToParent(node)
                                if !empty(a:node.parent)
                                    call a:node.parent.putCursorHere(1, 0)
                                    call nerdtree#centerView()
                                else
                                    call nerdtree#echo("cannot jump to parent")
                                endif
                            endfunction
                            
                            " FUNCTION: s:jumpToRoot() {{{2
                            " moves the cursor to the root node
    1              0.000002 function! s:jumpToRoot()
                                call b:NERDTreeRoot.putCursorHere(1, 0)
                                call nerdtree#centerView()
                            endfunction
                            
                            " FUNCTION: s:jumpToNextSibling(node) {{{2
    1              0.000002 function! s:jumpToNextSibling(node)
                                call nerdtree#jumpToSibling(a:node, 1)
                            endfunction
                            
                            " FUNCTION: s:jumpToPrevSibling(node) {{{2
    1              0.000003 function! s:jumpToPrevSibling(node)
                                call nerdtree#jumpToSibling(a:node, 0)
                            endfunction
                            
                            " FUNCTION: nerdtree#openBookmark(name) {{{2
                            " put the cursor on the given bookmark and, if its a file, open it
    1              0.000004 function! nerdtree#openBookmark(name)
                                try
                                    let targetNode = g:NERDTreeBookmark.GetNodeForName(a:name, 0)
                                    call targetNode.putCursorHere(0, 1)
                                    redraw!
                                catch /^NERDTree.BookmarkedNodeNotFoundError/
                                    call nerdtree#echo("note - target node is not cached")
                                    let bookmark = g:NERDTreeBookmark.BookmarkFor(a:name)
                                    let targetNode = g:NERDTreeFileNode.New(bookmark.path)
                                endtry
                                if targetNode.path.isDirectory
                                    call targetNode.openExplorer()
                                else
                                    call targetNode.open({'where': 'p'})
                                endif
                            endfunction
                            
                            " FUNCTION: s:openHSplit(target) {{{2
    1              0.000003 function! s:openHSplit(target)
                                call a:target.activate({'where': 'h'})
                            endfunction
                            
                            " FUNCTION: s:openVSplit(target) {{{2
    1              0.000002 function! s:openVSplit(target)
                                call a:target.activate({'where': 'v'})
                            endfunction
                            
                            " FUNCTION: s:openExplorer(node) {{{2
    1              0.000002 function! s:openExplorer(node)
                                call a:node.openExplorer()
                            endfunction
                            
                            " FUNCTION: s:openInNewTab(target) {{{2
    1              0.000002 function! s:openInNewTab(target)
                                call a:target.activate({'where': 't'})
                            endfunction
                            
                            " FUNCTION: s:openInNewTabSilent(target) {{{2
    1              0.000003 function! s:openInNewTabSilent(target)
                                call a:target.activate({'where': 't', 'stay': 1})
                            endfunction
                            
                            " FUNCTION: s:openNodeRecursively(node) {{{2
    1              0.000002 function! s:openNodeRecursively(node)
                                call nerdtree#echo("Recursively opening node. Please wait...")
                                call a:node.openRecursively()
                                call nerdtree#renderView()
                                redraw
                                call nerdtree#echo("Recursively opening node. Please wait... DONE")
                            endfunction
                            
                            "FUNCTION: s:previewNodeCurrent(node) {{{2
    1              0.000002 function! s:previewNodeCurrent(node)
                                call a:node.open({'stay': 1, 'where': 'p', 'keepopen': 1})
                            endfunction
                            
                            "FUNCTION: s:previewNodeHSplit(node) {{{2
    1              0.000002 function! s:previewNodeHSplit(node)
                                call a:node.open({'stay': 1, 'where': 'h', 'keepopen': 1})
                            endfunction
                            
                            "FUNCTION: s:previewNodeVSplit(node) {{{2
    1              0.000003 function! s:previewNodeVSplit(node)
                                call a:node.open({'stay': 1, 'where': 'v', 'keepopen': 1})
                            endfunction
                            
                            " FUNCTION: nerdtree#revealBookmark(name) {{{2
                            " put the cursor on the node associate with the given name
    1              0.000003 function! nerdtree#revealBookmark(name)
                                try
                                    let targetNode = g:NERDTreeBookmark.GetNodeForName(a:name, 0)
                                    call targetNode.putCursorHere(0, 1)
                                catch /^NERDTree.BookmarkNotFoundError/
                                    call nerdtree#echo("Bookmark isnt cached under the current root")
                                endtry
                            endfunction
                            
                            " FUNCTION: s:refreshRoot() {{{2
                            " Reloads the current root. All nodes below this will be lost and the root dir
                            " will be reloaded.
    1              0.000002 function! s:refreshRoot()
                                call nerdtree#echo("Refreshing the root node. This could take a while...")
                                call b:NERDTreeRoot.refresh()
                                call nerdtree#renderView()
                                redraw
                                call nerdtree#echo("Refreshing the root node. This could take a while... DONE")
                            endfunction
                            
                            " FUNCTION: s:refreshCurrent(node) {{{2
                            " refreshes the root for the current node
    1              0.000003 function! s:refreshCurrent(node)
                                let node = a:node
                                if !node.path.isDirectory
                                    let node = node.parent
                                endif
                            
                                call nerdtree#echo("Refreshing node. This could take a while...")
                                call node.refresh()
                                call nerdtree#renderView()
                                redraw
                                call nerdtree#echo("Refreshing node. This could take a while... DONE")
                            endfunction
                            
                            " FUNCTION: s:showMenu(node) {{{2
    1              0.000003 function! s:showMenu(node)
                                let mc = g:NERDTreeMenuController.New(g:NERDTreeMenuItem.AllEnabled())
                                call mc.showMenu()
                            endfunction
                            
                            " FUNCTION: s:toggleIgnoreFilter() {{{2
                            " toggles the use of the NERDTreeIgnore option
    1              0.000003 function! s:toggleIgnoreFilter()
                                let b:NERDTreeIgnoreEnabled = !b:NERDTreeIgnoreEnabled
                                call nerdtree#renderViewSavingPosition()
                                call nerdtree#centerView()
                            endfunction
                            
                            " FUNCTION: s:toggleShowBookmarks() {{{2
                            " toggles the display of bookmarks
    1              0.000003 function! s:toggleShowBookmarks()
                                let b:NERDTreeShowBookmarks = !b:NERDTreeShowBookmarks
                                if b:NERDTreeShowBookmarks
                                    call nerdtree#renderView()
                                    call nerdtree#putCursorOnBookmarkTable()
                                else
                                    call nerdtree#renderViewSavingPosition()
                                endif
                                call nerdtree#centerView()
                            endfunction
                            
                            " FUNCTION: s:toggleShowFiles() {{{2
                            " toggles the display of hidden files
    1              0.000002 function! s:toggleShowFiles()
                                let b:NERDTreeShowFiles = !b:NERDTreeShowFiles
                                call nerdtree#renderViewSavingPosition()
                                call nerdtree#centerView()
                            endfunction
                            
                            " FUNCTION: s:toggleShowHidden() {{{2
                            " toggles the display of hidden files
    1              0.000002 function! s:toggleShowHidden()
                                let b:NERDTreeShowHidden = !b:NERDTreeShowHidden
                                call nerdtree#renderViewSavingPosition()
                                call nerdtree#centerView()
                            endfunction
                            
                            " FUNCTION: s:toggleZoom() {{{2
                            " zoom (maximize/minimize) the NERDTree window
    1              0.000002 function! s:toggleZoom()
                                if exists("b:NERDTreeZoomed") && b:NERDTreeZoomed
                                    let size = exists("b:NERDTreeOldWindowSize") ? b:NERDTreeOldWindowSize : g:NERDTreeWinSize
                                    exec "silent vertical resize ". size
                                    let b:NERDTreeZoomed = 0
                                else
                                    exec "vertical resize"
                                    let b:NERDTreeZoomed = 1
                                endif
                            endfunction
                            
                            " FUNCTION: s:upDirCurrentRootOpen() {{{2
    1              0.000002 function! s:upDirCurrentRootOpen()
                                call nerdtree#upDir(1)
                            endfunction
                            
                            " FUNCTION: s:upDirCurrentRootClosed() {{{2
    1              0.000002 function! s:upDirCurrentRootClosed()
                                call nerdtree#upDir(0)
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/nerdtree/plugin/nerdtree/path.vim
Sourced 2 times
Total time:   0.002010
 Self time:   0.002010

count  total (s)   self (s)
                            "we need to use this number many times for sorting... so we calculate it only
                            "once here
    2              0.000015 let s:NERDTreeSortStarIndex = index(g:NERDTreeSortOrder, '*')
                            
                            "CLASS: Path
                            "============================================================
    2              0.000005 let s:Path = {}
    2              0.000049 let g:NERDTreePath = s:Path
                            
                            "FUNCTION: Path.AbsolutePathFor(str) {{{1
    2              0.000005 function! s:Path.AbsolutePathFor(str)
                                let prependCWD = 0
                                if nerdtree#runningWindows()
                                    let prependCWD = a:str !~# '^.:\(\\\|\/\)' && a:str !~# '^\(\\\\\|\/\/\)'
                                else
                                    let prependCWD = a:str !~# '^/'
                                endif
                            
                                let toReturn = a:str
                                if prependCWD
                                    let toReturn = getcwd() . s:Path.Slash() . a:str
                                endif
                            
                                return toReturn
                            endfunction
                            
                            "FUNCTION: Path.bookmarkNames() {{{1
    2              0.000004 function! s:Path.bookmarkNames()
                                if !exists("self._bookmarkNames")
                                    call self.cacheDisplayString()
                                endif
                                return self._bookmarkNames
                            endfunction
                            
                            "FUNCTION: Path.cacheDisplayString() {{{1
    2              0.000005 function! s:Path.cacheDisplayString()
                                let self.cachedDisplayString = self.getLastPathComponent(1)
                            
                                if self.isExecutable
                                    let self.cachedDisplayString = self.cachedDisplayString . '*'
                                endif
                            
                                let self._bookmarkNames = []
                                for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
                                    endif
                                endfor
                                if !empty(self._bookmarkNames)
                                    let self.cachedDisplayString .= ' {' . join(self._bookmarkNames) . '}'
                                endif
                            
                                if self.isSymLink
                                    let self.cachedDisplayString .=  ' -> ' . self.symLinkDest
                                endif
                            
                                if self.isReadOnly
                                    let self.cachedDisplayString .=  ' [RO]'
                                endif
                            endfunction
                            
                            "FUNCTION: Path.changeToDir() {{{1
    2              0.000004 function! s:Path.changeToDir()
                                let dir = self.str({'format': 'Cd'})
                                if self.isDirectory ==# 0
                                    let dir = self.getParent().str({'format': 'Cd'})
                                endif
                            
                                try
                                    execute "cd " . dir
                                    call nerdtree#echo("CWD is now: " . getcwd())
                                catch
                                    throw "NERDTree.PathChangeError: cannot change CWD to " . dir
                                endtry
                            endfunction
                            
                            "FUNCTION: Path.compareTo() {{{1
                            "
                            "Compares this Path to the given path and returns 0 if they are equal, -1 if
                            "this Path is "less than" the given path, or 1 if it is "greater".
                            "
                            "Args:
                            "path: the path object to compare this to
                            "
                            "Return:
                            "1, -1 or 0
    2              0.000005 function! s:Path.compareTo(path)
                                let thisPath = self.getLastPathComponent(1)
                                let thatPath = a:path.getLastPathComponent(1)
                            
                                "if the paths are the same then clearly we return 0
                                if thisPath ==# thatPath
                                    return 0
                                endif
                            
                                let thisSS = self.getSortOrderIndex()
                                let thatSS = a:path.getSortOrderIndex()
                            
                                "compare the sort sequences, if they are different then the return
                                "value is easy
                                if thisSS < thatSS
                                    return -1
                                elseif thisSS > thatSS
                                    return 1
                                else
                                    "if the sort sequences are the same then compare the paths
                                    "alphabetically
                                    let pathCompare = g:NERDTreeCaseSensitiveSort ? thisPath <# thatPath : thisPath <? thatPath
                                    if pathCompare
                                        return -1
                                    else
                                        return 1
                                    endif
                                endif
                            endfunction
                            
                            "FUNCTION: Path.Create(fullpath) {{{1
                            "
                            "Factory method.
                            "
                            "Creates a path object with the given path. The path is also created on the
                            "filesystem. If the path already exists, a NERDTree.Path.Exists exception is
                            "thrown. If any other errors occur, a NERDTree.Path exception is thrown.
                            "
                            "Args:
                            "fullpath: the full filesystem path to the file/dir to create
    2              0.000005 function! s:Path.Create(fullpath)
                                "bail if the a:fullpath already exists
                                if isdirectory(a:fullpath) || filereadable(a:fullpath)
                                    throw "NERDTree.CreatePathError: Directory Exists: '" . a:fullpath . "'"
                                endif
                            
                                try
                            
                                    "if it ends with a slash, assume its a dir create it
                                    if a:fullpath =~# '\(\\\|\/\)$'
                                        "whack the trailing slash off the end if it exists
                                        let fullpath = substitute(a:fullpath, '\(\\\|\/\)$', '', '')
                            
                                        call mkdir(fullpath, 'p')
                            
                                    "assume its a file and create
                                    else
                                        call writefile([], a:fullpath)
                                    endif
                                catch
                                    throw "NERDTree.CreatePathError: Could not create path: '" . a:fullpath . "'"
                                endtry
                            
                                return s:Path.New(a:fullpath)
                            endfunction
                            
                            "FUNCTION: Path.copy(dest) {{{1
                            "
                            "Copies the file/dir represented by this Path to the given location
                            "
                            "Args:
                            "dest: the location to copy this dir/file to
    2              0.000005 function! s:Path.copy(dest)
                                if !s:Path.CopyingSupported()
                                    throw "NERDTree.CopyingNotSupportedError: Copying is not supported on this OS"
                                endif
                            
                                let dest = s:Path.WinToUnixPath(a:dest)
                            
                                let cmd = g:NERDTreeCopyCmd . " " . escape(self.str(), nerdtree#escChars()) . " " . escape(dest, nerdtree#escChars())
                                let success = system(cmd)
                                if success != 0
                                    throw "NERDTree.CopyError: Could not copy ''". self.str() ."'' to: '" . a:dest . "'"
                                endif
                            endfunction
                            
                            "FUNCTION: Path.CopyingSupported() {{{1
                            "
                            "returns 1 if copying is supported for this OS
    2              0.000003 function! s:Path.CopyingSupported()
                                return exists('g:NERDTreeCopyCmd')
                            endfunction
                            
                            "FUNCTION: Path.copyingWillOverwrite(dest) {{{1
                            "
                            "returns 1 if copy this path to the given location will cause files to
                            "overwritten
                            "
                            "Args:
                            "dest: the location this path will be copied to
    2              0.000004 function! s:Path.copyingWillOverwrite(dest)
                                if filereadable(a:dest)
                                    return 1
                                endif
                            
                                if isdirectory(a:dest)
                                    let path = s:Path.JoinPathStrings(a:dest, self.getLastPathComponent(0))
                                    if filereadable(path)
                                        return 1
                                    endif
                                endif
                            endfunction
                            
                            "FUNCTION: Path.delete() {{{1
                            "
                            "Deletes the file represented by this path.
                            "Deletion of directories is not supported
                            "
                            "Throws NERDTree.Path.Deletion exceptions
    2              0.000004 function! s:Path.delete()
                                if self.isDirectory
                            
                                    let cmd = g:NERDTreeRemoveDirCmd . self.str({'escape': 1})
                                    let success = system(cmd)
                            
                                    if v:shell_error != 0
                                        throw "NERDTree.PathDeletionError: Could not delete directory: '" . self.str() . "'"
                                    endif
                                else
                                    let success = delete(self.str())
                                    if success != 0
                                        throw "NERDTree.PathDeletionError: Could not delete file: '" . self.str() . "'"
                                    endif
                                endif
                            
                                "delete all bookmarks for this path
                                for i in self.bookmarkNames()
                                    let bookmark = g:NERDTreeBookmark.BookmarkFor(i)
                                    call bookmark.delete()
                                endfor
                            endfunction
                            
                            "FUNCTION: Path.displayString() {{{1
                            "
                            "Returns a string that specifies how the path should be represented as a
                            "string
    2              0.000004 function! s:Path.displayString()
                                if self.cachedDisplayString ==# ""
                                    call self.cacheDisplayString()
                                endif
                            
                                return self.cachedDisplayString
                            endfunction
                            
                            "FUNCTION: Path.edit() {{{1
    2              0.000004 function! s:Path.edit()
                                exec "edit " . self.str({'format': 'Edit'})
                            endfunction
                            
                            "FUNCTION: Path.extractDriveLetter(fullpath) {{{1
                            "
                            "If running windows, cache the drive letter for this path
    2              0.000004 function! s:Path.extractDriveLetter(fullpath)
                                if nerdtree#runningWindows()
                                    if a:fullpath =~ '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', "g")
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
                                else
                                    let self.drive = ''
                                endif
                            
                            endfunction
                            
                            "FUNCTION: Path.exists() {{{1
                            "return 1 if this path points to a location that is readable or is a directory
    2              0.000003 function! s:Path.exists()
                                let p = self.str()
                                return filereadable(p) || isdirectory(p)
                            endfunction
                            
                            "FUNCTION: Path.getDir() {{{1
                            "
                            "Returns this path if it is a directory, else this paths parent.
                            "
                            "Return:
                            "a Path object
    2              0.000002 function! s:Path.getDir()
                                if self.isDirectory
                                    return self
                                else
                                    return self.getParent()
                                endif
                            endfunction
                            
                            "FUNCTION: Path.getParent() {{{1
                            "
                            "Returns a new path object for this paths parent
                            "
                            "Return:
                            "a new Path object
    2              0.000004 function! s:Path.getParent()
                                if nerdtree#runningWindows()
                                    let path = self.drive . '\' . join(self.pathSegments[0:-2], '\')
                                else
                                    let path = '/'. join(self.pathSegments[0:-2], '/')
                                endif
                            
                                return s:Path.New(path)
                            endfunction
                            
                            "FUNCTION: Path.getLastPathComponent(dirSlash) {{{1
                            "
                            "Gets the last part of this path.
                            "
                            "Args:
                            "dirSlash: if 1 then a trailing slash will be added to the returned value for
                            "directory nodes.
    2              0.000005 function! s:Path.getLastPathComponent(dirSlash)
                                if empty(self.pathSegments)
                                    return ''
                                endif
                                let toReturn = self.pathSegments[-1]
                                if a:dirSlash && self.isDirectory
                                    let toReturn = toReturn . '/'
                                endif
                                return toReturn
                            endfunction
                            
                            "FUNCTION: Path.getSortOrderIndex() {{{1
                            "returns the index of the pattern in g:NERDTreeSortOrder that this path matches
    2              0.000005 function! s:Path.getSortOrderIndex()
                                let i = 0
                                while i < len(g:NERDTreeSortOrder)
                                    if  self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
                                        return i
                                    endif
                                    let i = i + 1
                                endwhile
                                return s:NERDTreeSortStarIndex
                            endfunction
                            
                            "FUNCTION: Path.isUnixHiddenFile() {{{1
                            "check for unix hidden files
    2              0.000004 function! s:Path.isUnixHiddenFile()
                                return self.getLastPathComponent(0) =~# '^\.'
                            endfunction
                            
                            "FUNCTION: Path.isUnixHiddenPath() {{{1
                            "check for unix path with hidden components
    2              0.000004 function! s:Path.isUnixHiddenPath()
                                if self.getLastPathComponent(0) =~# '^\.'
                                    return 1
                                else
                                    for segment in self.pathSegments
                                        if segment =~# '^\.'
                                            return 1
                                        endif
                                    endfor
                                    return 0
                                endif
                            endfunction
                            
                            "FUNCTION: Path.ignore() {{{1
                            "returns true if this path should be ignored
    2              0.000004 function! s:Path.ignore()
                                "filter out the user specified paths to ignore
                                if b:NERDTreeIgnoreEnabled
                                    for i in g:NERDTreeIgnore
                                        if self._ignorePatternMatches(i)
                                            return 1
                                        endif
                                    endfor
                                endif
                            
                                "dont show hidden files unless instructed to
                                if b:NERDTreeShowHidden ==# 0 && self.isUnixHiddenFile()
                                    return 1
                                endif
                            
                                if b:NERDTreeShowFiles ==# 0 && self.isDirectory ==# 0
                                    return 1
                                endif
                            
                                if exists("*NERDTreeCustomIgnoreFilter") && NERDTreeCustomIgnoreFilter(self)
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
                            "FUNCTION: Path._ignorePatternMatches(pattern) {{{1
                            "returns true if this path matches the given ignore pattern
    2              0.000005 function! s:Path._ignorePatternMatches(pattern)
                                let pat = a:pattern
                                if strpart(pat,len(pat)-7) == '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
                                elseif strpart(pat,len(pat)-8) == '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
                                endif
                            
                                return self.getLastPathComponent(0) =~# pat
                            endfunction
                            
                            "FUNCTION: Path.isUnder(path) {{{1
                            "return 1 if this path is somewhere under the given path in the filesystem.
                            "
                            "a:path should be a dir
    2              0.000004 function! s:Path.isUnder(path)
                                if a:path.isDirectory == 0
                                    return 0
                                endif
                            
                                let this = self.str()
                                let that = a:path.str()
                                return stridx(this, that . s:Path.Slash()) == 0
                            endfunction
                            
                            "FUNCTION: Path.JoinPathStrings(...) {{{1
    2              0.000004 function! s:Path.JoinPathStrings(...)
                                let components = []
                                for i in a:000
                                    let components = extend(components, split(i, '/'))
                                endfor
                                return '/' . join(components, '/')
                            endfunction
                            
                            "FUNCTION: Path.equals() {{{1
                            "
                            "Determines whether 2 path objects are "equal".
                            "They are equal if the paths they represent are the same
                            "
                            "Args:
                            "path: the other path obj to compare this with
    2              0.000004 function! s:Path.equals(path)
                                return self.str() ==# a:path.str()
                            endfunction
                            
                            "FUNCTION: Path.New() {{{1
                            "The Constructor for the Path object
    2              0.000004 function! s:Path.New(path)
                                let newPath = copy(self)
                            
                                call newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:path))
                            
                                let newPath.cachedDisplayString = ""
                            
                                return newPath
                            endfunction
                            
                            "FUNCTION: Path.Slash() {{{1
                            "return the slash to use for the current OS
    2              0.000004 function! s:Path.Slash()
                                return nerdtree#runningWindows() ? '\' : '/'
                            endfunction
                            
                            "FUNCTION: Path.Resolve() {{{1
                            "Invoke the vim resolve() function and return the result
                            "This is necessary because in some versions of vim resolve() removes trailing
                            "slashes while in other versions it doesn't.  This always removes the trailing
                            "slash
    2              0.000005 function! s:Path.Resolve(path)
                                let tmp = resolve(a:path)
                                return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
                            endfunction
                            
                            "FUNCTION: Path.readInfoFromDisk(fullpath) {{{1
                            "
                            "
                            "Throws NERDTree.Path.InvalidArguments exception.
    2              0.000005 function! s:Path.readInfoFromDisk(fullpath)
                                call self.extractDriveLetter(a:fullpath)
                            
                                let fullpath = s:Path.WinToUnixPath(a:fullpath)
                            
                                if getftype(fullpath) ==# "fifo"
                                    throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
                                endif
                            
                                let self.pathSegments = split(fullpath, '/')
                            
                                let self.isReadOnly = 0
                                if isdirectory(a:fullpath)
                                    let self.isDirectory = 1
                                elseif filereadable(a:fullpath)
                                    let self.isDirectory = 0
                                    let self.isReadOnly = filewritable(a:fullpath) ==# 0
                                else
                                    throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
                                endif
                            
                                let self.isExecutable = 0
                                if !self.isDirectory
                                    let self.isExecutable = getfperm(a:fullpath) =~# 'x'
                                endif
                            
                                "grab the last part of the path (minus the trailing slash)
                                let lastPathComponent = self.getLastPathComponent(0)
                            
                                "get the path to the new node with the parent dir fully resolved
                                let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                            
                                "if  the last part of the path is a symlink then flag it as such
                                let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
                                if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)
                            
                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)
                            
                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'
                            
                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
                                endif
                            endfunction
                            
                            "FUNCTION: Path.refresh() {{{1
    2              0.000004 function! s:Path.refresh()
                                call self.readInfoFromDisk(self.str())
                                call self.cacheDisplayString()
                            endfunction
                            
                            "FUNCTION: Path.rename() {{{1
                            "
                            "Renames this node on the filesystem
    2              0.000004 function! s:Path.rename(newPath)
                                if a:newPath ==# ''
                                    throw "NERDTree.InvalidArgumentsError: Invalid newPath for renaming = ". a:newPath
                                endif
                            
                                let success =  rename(self.str(), a:newPath)
                                if success != 0
                                    throw "NERDTree.PathRenameError: Could not rename: '" . self.str() . "'" . 'to:' . a:newPath
                                endif
                                call self.readInfoFromDisk(a:newPath)
                            
                                for i in self.bookmarkNames()
                                    let b = g:NERDTreeBookmark.BookmarkFor(i)
                                    call b.setPath(copy(self))
                                endfor
                                call g:NERDTreeBookmark.Write()
                            endfunction
                            
                            "FUNCTION: Path.str() {{{1
                            "
                            "Returns a string representation of this Path
                            "
                            "Takes an optional dictionary param to specify how the output should be
                            "formatted.
                            "
                            "The dict may have the following keys:
                            "  'format'
                            "  'escape'
                            "  'truncateTo'
                            "
                            "The 'format' key may have a value of:
                            "  'Cd' - a string to be used with the :cd command
                            "  'Edit' - a string to be used with :e :sp :new :tabedit etc
                            "  'UI' - a string used in the NERD tree UI
                            "
                            "The 'escape' key, if specified will cause the output to be escaped with
                            "shellescape()
                            "
                            "The 'truncateTo' key causes the resulting string to be truncated to the value
                            "'truncateTo' maps to. A '<' char will be prepended.
    2              0.000003 function! s:Path.str(...)
                                let options = a:0 ? a:1 : {}
                                let toReturn = ""
                            
                                if has_key(options, 'format')
                                    let format = options['format']
                                    if has_key(self, '_strFor' . format)
                                        exec 'let toReturn = self._strFor' . format . '()'
                                    else
                                        raise 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
                                    endif
                                else
                                    let toReturn = self._str()
                                endif
                            
                                if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
                                endif
                            
                                if has_key(options, 'truncateTo')
                                    let limit = options['truncateTo']
                                    if len(toReturn) > limit
                                        let toReturn = "<" . strpart(toReturn, len(toReturn) - limit + 1)
                                    endif
                                endif
                            
                                return toReturn
                            endfunction
                            
                            "FUNCTION: Path._strForUI() {{{1
    2              0.000004 function! s:Path._strForUI()
                                let toReturn = '/' . join(self.pathSegments, '/')
                                if self.isDirectory && toReturn != '/'
                                    let toReturn  = toReturn . '/'
                                endif
                                return toReturn
                            endfunction
                            
                            "FUNCTION: Path._strForCd() {{{1
                            "
                            " returns a string that can be used with :cd
    2              0.000005 function! s:Path._strForCd()
                                return escape(self.str(), nerdtree#escChars())
                            endfunction
                            
                            "FUNCTION: Path._strForEdit() {{{1
                            "
                            "Return: the string for this path that is suitable to be used with the :edit
                            "command
    2              0.000004 function! s:Path._strForEdit()
                                let p = escape(self.str({'format': 'UI'}), nerdtree#escChars())
                                let cwd = getcwd() . s:Path.Slash()
                            
                                "return a relative path if we can
                                let isRelative = 0
                                if nerdtree#runningWindows()
                                    let isRelative = stridx(tolower(p), tolower(cwd)) == 0
                                else
                                    let isRelative = stridx(p, cwd) == 0
                                endif
                            
                                if isRelative
                                    let p = strpart(p, strlen(cwd))
                            
                                    "handle the edge case where the file begins with a + (vim interprets
                                    "the +foo in `:e +foo` as an option to :edit)
                                    if p[0] == "+"
                                        let p = '\' . p
                                    endif
                                endif
                            
                                if p ==# ''
                                    let p = '.'
                                endif
                            
                                return p
                            endfunction
                            
                            "FUNCTION: Path._strForGlob() {{{1
    2              0.000004 function! s:Path._strForGlob()
                                let lead = s:Path.Slash()
                            
                                "if we are running windows then slap a drive letter on the front
                                if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
                                endif
                            
                                let toReturn = lead . join(self.pathSegments, s:Path.Slash())
                            
                                if !nerdtree#runningWindows()
                                    let toReturn = escape(toReturn, nerdtree#escChars())
                                endif
                                return toReturn
                            endfunction
                            
                            "FUNCTION: Path._str() {{{1
                            "
                            "Gets the string path for this path object that is appropriate for the OS.
                            "EG, in windows c:\foo\bar
                            "    in *nix  /foo/bar
    2              0.000004 function! s:Path._str()
                                let lead = s:Path.Slash()
                            
                                "if we are running windows then slap a drive letter on the front
                                if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
                                endif
                            
                                return lead . join(self.pathSegments, s:Path.Slash())
                            endfunction
                            
                            "FUNCTION: Path.strTrunk() {{{1
                            "Gets the path without the last segment on the end.
    2              0.000003 function! s:Path.strTrunk()
                                return self.drive . '/' . join(self.pathSegments[0:-2], '/')
                            endfunction
                            
                            " FUNCTION: Path.tabnr() {{{1
                            " return the number of the first tab that is displaying this file
                            "
                            " return 0 if no tab was found
    2              0.000004 function! s:Path.tabnr()
                                let str = self.str()
                                for t in range(tabpagenr('$'))
                                    for b in tabpagebuflist(t+1)
                                        if str == expand('#' . b . ':p')
                                            return t+1
                                        endif
                                    endfor
                                endfor
                                return 0
                            endfunction
                            
                            "FUNCTION: Path.WinToUnixPath(pathstr){{{1
                            "Takes in a windows path and returns the unix equiv
                            "
                            "A class level method
                            "
                            "Args:
                            "pathstr: the windows path to convert
    2              0.000004 function! s:Path.WinToUnixPath(pathstr)
                                if !nerdtree#runningWindows()
                                    return a:pathstr
                                endif
                            
                                let toReturn = a:pathstr
                            
                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', "")
                            
                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', "")
                            
                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', "g")
                            
                                return toReturn
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/nerdtree/plugin/nerdtree/menu_controller.vim
Sourced 2 times
Total time:   0.000596
 Self time:   0.000596

count  total (s)   self (s)
                            "CLASS: MenuController
                            "============================================================
    2              0.000010 let s:MenuController = {}
    2              0.000019 let g:NERDTreeMenuController = s:MenuController
                            
                            "FUNCTION: MenuController.New(menuItems) {{{1
                            "create a new menu controller that operates on the given menu items
    2              0.000006 function! s:MenuController.New(menuItems)
                                let newMenuController =  copy(self)
                                if a:menuItems[0].isSeparator()
                                    let newMenuController.menuItems = a:menuItems[1:-1]
                                else
                                    let newMenuController.menuItems = a:menuItems
                                endif
                                return newMenuController
                            endfunction
                            
                            "FUNCTION: MenuController.showMenu() {{{1
                            "start the main loop of the menu and get the user to choose/execute a menu
                            "item
    2              0.000004 function! s:MenuController.showMenu()
                                call self._saveOptions()
                            
                                try
                                    let self.selection = 0
                            
                                    let done = 0
                                    while !done
                                        redraw!
                                        call self._echoPrompt()
                                        let key = nr2char(getchar())
                                        let done = self._handleKeypress(key)
                                    endwhile
                                finally
                                    call self._restoreOptions()
                                endtry
                            
                                if self.selection != -1
                                    let m = self._current()
                                    call m.execute()
                                endif
                            endfunction
                            
                            "FUNCTION: MenuController._echoPrompt() {{{1
    2              0.000004 function! s:MenuController._echoPrompt()
                                echo "NERDTree Menu. Use j/k/enter and the shortcuts indicated"
                                echo "=========================================================="
                            
                                for i in range(0, len(self.menuItems)-1)
                                    if self.selection == i
                                        echo "> " . self.menuItems[i].text
                                    else
                                        echo "  " . self.menuItems[i].text
                                    endif
                                endfor
                            endfunction
                            
                            "FUNCTION: MenuController._current(key) {{{1
                            "get the MenuItem that is currently selected
    2              0.000004 function! s:MenuController._current()
                                return self.menuItems[self.selection]
                            endfunction
                            
                            "FUNCTION: MenuController._handleKeypress(key) {{{1
                            "change the selection (if appropriate) and return 1 if the user has made
                            "their choice, 0 otherwise
    2              0.000005 function! s:MenuController._handleKeypress(key)
                                if a:key == 'j'
                                    call self._cursorDown()
                                elseif a:key == 'k'
                                    call self._cursorUp()
                                elseif a:key == nr2char(27) "escape
                                    let self.selection = -1
                                    return 1
                                elseif a:key == "\r" || a:key == "\n" "enter and ctrl-j
                                    return 1
                                else
                                    let index = self._nextIndexFor(a:key)
                                    if index != -1
                                        let self.selection = index
                                        if len(self._allIndexesFor(a:key)) == 1
                                            return 1
                                        endif
                                    endif
                                endif
                            
                                return 0
                            endfunction
                            
                            "FUNCTION: MenuController._allIndexesFor(shortcut) {{{1
                            "get indexes to all menu items with the given shortcut
    2              0.000005 function! s:MenuController._allIndexesFor(shortcut)
                                let toReturn = []
                            
                                for i in range(0, len(self.menuItems)-1)
                                    if self.menuItems[i].shortcut == a:shortcut
                                        call add(toReturn, i)
                                    endif
                                endfor
                            
                                return toReturn
                            endfunction
                            
                            "FUNCTION: MenuController._nextIndexFor(shortcut) {{{1
                            "get the index to the next menu item with the given shortcut, starts from the
                            "current cursor location and wraps around to the top again if need be
    2              0.000005 function! s:MenuController._nextIndexFor(shortcut)
                                for i in range(self.selection+1, len(self.menuItems)-1)
                                    if self.menuItems[i].shortcut == a:shortcut
                                        return i
                                    endif
                                endfor
                            
                                for i in range(0, self.selection)
                                    if self.menuItems[i].shortcut == a:shortcut
                                        return i
                                    endif
                                endfor
                            
                                return -1
                            endfunction
                            
                            "FUNCTION: MenuController._setCmdheight() {{{1
                            "sets &cmdheight to whatever is needed to display the menu
    2              0.000004 function! s:MenuController._setCmdheight()
                                let &cmdheight = len(self.menuItems) + 3
                            endfunction
                            
                            "FUNCTION: MenuController._saveOptions() {{{1
                            "set any vim options that are required to make the menu work (saving their old
                            "values)
    2              0.000004 function! s:MenuController._saveOptions()
                                let self._oldLazyredraw = &lazyredraw
                                let self._oldCmdheight = &cmdheight
                                set nolazyredraw
                                call self._setCmdheight()
                            endfunction
                            
                            "FUNCTION: MenuController._restoreOptions() {{{1
                            "restore the options we saved in _saveOptions()
    2              0.000005 function! s:MenuController._restoreOptions()
                                let &cmdheight = self._oldCmdheight
                                let &lazyredraw = self._oldLazyredraw
                            endfunction
                            
                            "FUNCTION: MenuController._cursorDown() {{{1
                            "move the cursor to the next menu item, skipping separators
    2              0.000004 function! s:MenuController._cursorDown()
                                let done = 0
                                while !done
                                    if self.selection < len(self.menuItems)-1
                                        let self.selection += 1
                                    else
                                        let self.selection = 0
                                    endif
                            
                                    if !self._current().isSeparator()
                                        let done = 1
                                    endif
                                endwhile
                            endfunction
                            
                            "FUNCTION: MenuController._cursorUp() {{{1
                            "move the cursor to the previous menu item, skipping separators
    2              0.000004 function! s:MenuController._cursorUp()
                                let done = 0
                                while !done
                                    if self.selection > 0
                                        let self.selection -= 1
                                    else
                                        let self.selection = len(self.menuItems)-1
                                    endif
                            
                                    if !self._current().isSeparator()
                                        let done = 1
                                    endif
                                endwhile
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/nerdtree/plugin/nerdtree/menu_item.vim
Sourced 2 times
Total time:   0.000380
 Self time:   0.000380

count  total (s)   self (s)
                            "CLASS: MenuItem
                            "============================================================
    2              0.000007 let s:MenuItem = {}
    2              0.000009 let g:NERDTreeMenuItem = s:MenuItem
                            
                            "FUNCTION: MenuItem.All() {{{1
                            "get all top level menu items
    2              0.000004 function! s:MenuItem.All()
                                if !exists("s:menuItems")
                                    let s:menuItems = []
                                endif
                                return s:menuItems
                            endfunction
                            
                            "FUNCTION: MenuItem.AllEnabled() {{{1
                            "get all top level menu items that are currently enabled
    2              0.000004 function! s:MenuItem.AllEnabled()
                                let toReturn = []
                                for i in s:MenuItem.All()
                                    if i.enabled()
                                        call add(toReturn, i)
                                    endif
                                endfor
                                return toReturn
                            endfunction
                            
                            "FUNCTION: MenuItem.Create(options) {{{1
                            "make a new menu item and add it to the global list
    2              0.000004 function! s:MenuItem.Create(options)
                                let newMenuItem = copy(self)
                            
                                let newMenuItem.text = a:options['text']
                                let newMenuItem.shortcut = a:options['shortcut']
                                let newMenuItem.children = []
                            
                                let newMenuItem.isActiveCallback = -1
                                if has_key(a:options, 'isActiveCallback')
                                    let newMenuItem.isActiveCallback = a:options['isActiveCallback']
                                endif
                            
                                let newMenuItem.callback = -1
                                if has_key(a:options, 'callback')
                                    let newMenuItem.callback = a:options['callback']
                                endif
                            
                                if has_key(a:options, 'parent')
                                    call add(a:options['parent'].children, newMenuItem)
                                else
                                    call add(s:MenuItem.All(), newMenuItem)
                                endif
                            
                                return newMenuItem
                            endfunction
                            
                            "FUNCTION: MenuItem.CreateSeparator(options) {{{1
                            "make a new separator menu item and add it to the global list
    2              0.000005 function! s:MenuItem.CreateSeparator(options)
                                let standard_options = { 'text': '--------------------',
                                            \ 'shortcut': -1,
                                            \ 'callback': -1 }
                                let options = extend(a:options, standard_options, "force")
                            
                                return s:MenuItem.Create(options)
                            endfunction
                            
                            "FUNCTION: MenuItem.CreateSubmenu(options) {{{1
                            "make a new submenu and add it to global list
    2              0.000004 function! s:MenuItem.CreateSubmenu(options)
                                let standard_options = { 'callback': -1 }
                                let options = extend(a:options, standard_options, "force")
                            
                                return s:MenuItem.Create(options)
                            endfunction
                            
                            "FUNCTION: MenuItem.enabled() {{{1
                            "return 1 if this menu item should be displayed
                            "
                            "delegates off to the isActiveCallback, and defaults to 1 if no callback was
                            "specified
    2              0.000003 function! s:MenuItem.enabled()
                                if self.isActiveCallback != -1
                                    return {self.isActiveCallback}()
                                endif
                                return 1
                            endfunction
                            
                            "FUNCTION: MenuItem.execute() {{{1
                            "perform the action behind this menu item, if this menuitem has children then
                            "display a new menu for them, otherwise deletegate off to the menuitem's
                            "callback
    2              0.000004 function! s:MenuItem.execute()
                                if len(self.children)
                                    let mc = s:MenuController.New(self.children)
                                    call mc.showMenu()
                                else
                                    if self.callback != -1
                                        call {self.callback}()
                                    endif
                                endif
                            endfunction
                            
                            "FUNCTION: MenuItem.isSeparator() {{{1
                            "return 1 if this menuitem is a separator
    2              0.000004 function! s:MenuItem.isSeparator()
                                return self.callback == -1 && self.children == []
                            endfunction
                            
                            "FUNCTION: MenuItem.isSubmenu() {{{1
                            "return 1 if this menuitem is a submenu
    2              0.000004 function! s:MenuItem.isSubmenu()
                                return self.callback == -1 && !empty(self.children)
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/nerdtree/plugin/nerdtree/key_map.vim
Sourced 2 times
Total time:   0.000427
 Self time:   0.000427

count  total (s)   self (s)
                            "CLASS: KeyMap
                            "============================================================
    2              0.000008 let s:KeyMap = {}
    2              0.000008 let g:NERDTreeKeyMap = s:KeyMap
                            
                            "FUNCTION: KeyMap.All() {{{1
    2              0.000004 function! s:KeyMap.All()
                                if !exists("s:keyMaps")
                                    let s:keyMaps = []
                                endif
                                return s:keyMaps
                            endfunction
                            
                            "FUNCTION: KeyMap.FindFor(key, scope) {{{1
    2              0.000005 function! s:KeyMap.FindFor(key, scope)
                                for i in s:KeyMap.All()
                                     if i.key ==# a:key && i.scope ==# a:scope
                                        return i
                                    endif
                                endfor
                                return {}
                            endfunction
                            
                            "FUNCTION: KeyMap.BindAll() {{{1
    2              0.000003 function! s:KeyMap.BindAll()
                                for i in s:KeyMap.All()
                                    call i.bind()
                                endfor
                            endfunction
                            
                            "FUNCTION: KeyMap.bind() {{{1
    2              0.000004 function! s:KeyMap.bind()
                                " If the key sequence we're trying to map contains any '<>' notation, we
                                " must replace each of the '<' characters with '<lt>' to ensure the string
                                " is not translated into its corresponding keycode during the later part
                                " of the map command below
                                " :he <>
                                let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
                                if self.key =~# specialNotationRegex
                                    let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
                                else
                                    let keymapInvokeString = self.key
                                endif
                            
                                let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
                            
                                exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#invokeKeyMap("'. keymapInvokeString .'")<cr>'
                            endfunction
                            
                            "FUNCTION: KeyMap.Remove(key, scope) {{{1
    2              0.000005 function! s:KeyMap.Remove(key, scope)
                                let maps = s:KeyMap.All()
                                for i in range(len(maps))
                                     if maps[i].key ==# a:key && maps[i].scope ==# a:scope
                                        return remove(maps, i)
                                    endif
                                endfor
                            endfunction
                            
                            "FUNCTION: KeyMap.invoke() {{{1
                            "Call the KeyMaps callback function
    2              0.000003 function! s:KeyMap.invoke(...)
                                let Callback = function(self.callback)
                                if a:0
                                    call Callback(a:1)
                                else
                                    call Callback()
                                endif
                            endfunction
                            
                            "FUNCTION: KeyMap.Invoke() {{{1
                            "Find a keymapping for a:key and the current scope invoke it.
                            "
                            "Scope is determined as follows:
                            "   * if the cursor is on a dir node then "DirNode"
                            "   * if the cursor is on a file node then "FileNode"
                            "   * if the cursor is on a bookmark then "Bookmark"
                            "
                            "If a keymap has the scope of "all" then it will be called if no other keymap
                            "is found for a:key and the scope.
    2              0.000004 function! s:KeyMap.Invoke(key)
                                let node = g:NERDTreeFileNode.GetSelected()
                                if !empty(node)
                            
                                    "try file node
                                    if !node.path.isDirectory
                                        let km = s:KeyMap.FindFor(a:key, "FileNode")
                                        if !empty(km)
                                            return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try dir node
                                    if node.path.isDirectory
                                        let km = s:KeyMap.FindFor(a:key, "DirNode")
                                        if !empty(km)
                                            return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try generic node
                                    let km = s:KeyMap.FindFor(a:key, "Node")
                                    if !empty(km)
                                        return km.invoke(node)
                                    endif
                            
                                endif
                            
                                "try bookmark
                                let bm = g:NERDTreeBookmark.GetSelected()
                                if !empty(bm)
                                    let km = s:KeyMap.FindFor(a:key, "Bookmark")
                                    if !empty(km)
                                        return km.invoke(bm)
                                    endif
                                endif
                            
                                "try all
                                let km = s:KeyMap.FindFor(a:key, "all")
                                if !empty(km)
                                    return km.invoke()
                                endif
                            endfunction
                            
                            "FUNCTION: KeyMap.Create(options) {{{1
    2              0.000004 function! s:KeyMap.Create(options)
                                let newKeyMap = copy(self)
                                let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
                                let newKeyMap.key = opts['key']
                                let newKeyMap.quickhelpText = opts['quickhelpText']
                                let newKeyMap.callback = opts['callback']
                                let newKeyMap.scope = opts['scope']
                            
                                call s:KeyMap.Add(newKeyMap)
                            endfunction
                            
                            "FUNCTION: KeyMap.Add(keymap) {{{1
    2              0.000004 function! s:KeyMap.Add(keymap)
                                call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
                                call add(s:KeyMap.All(), a:keymap)
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/nerdtree/plugin/nerdtree/bookmark.vim
Sourced 2 times
Total time:   0.001125
 Self time:   0.001125

count  total (s)   self (s)
                            "CLASS: Bookmark
                            "============================================================
    2              0.000008 let s:Bookmark = {}
    2              0.000029 let g:NERDTreeBookmark = s:Bookmark
                            
                            " FUNCTION: Bookmark.activate() {{{1
    2              0.000004 function! s:Bookmark.activate(...)
                                call self.open(a:0 ? a:1 : {})
                            endfunction
                            
                            " FUNCTION: Bookmark.AddBookmark(name, path) {{{1
                            " Class method to add a new bookmark to the list, if a previous bookmark exists
                            " with the same name, just update the path for that bookmark
    2              0.000006 function! s:Bookmark.AddBookmark(name, path)
                                for i in s:Bookmark.Bookmarks()
                                    if i.name ==# a:name
                                        let i.path = a:path
                                        return
                                    endif
                                endfor
                                call add(s:Bookmark.Bookmarks(), s:Bookmark.New(a:name, a:path))
                                call s:Bookmark.Sort()
                            endfunction
                            
                            " FUNCTION: Bookmark.Bookmarks()   {{{1
                            " Class method to get all bookmarks. Lazily initializes the bookmarks global
                            " variable
    2              0.000004 function! s:Bookmark.Bookmarks()
                                if !exists("g:NERDTreeBookmarks")
                                    let g:NERDTreeBookmarks = []
                                endif
                                return g:NERDTreeBookmarks
                            endfunction
                            
                            " FUNCTION: Bookmark.BookmarkExistsFor(name)   {{{1
                            " class method that returns 1 if a bookmark with the given name is found, 0
                            " otherwise
    2              0.000006 function! s:Bookmark.BookmarkExistsFor(name)
                                try
                                    call s:Bookmark.BookmarkFor(a:name)
                                    return 1
                                catch /^NERDTree.BookmarkNotFoundError/
                                    return 0
                                endtry
                            endfunction
                            
                            " FUNCTION: Bookmark.BookmarkFor(name)   {{{1
                            " Class method to get the bookmark that has the given name. {} is return if no
                            " bookmark is found
    2              0.000004 function! s:Bookmark.BookmarkFor(name)
                                for i in s:Bookmark.Bookmarks()
                                    if i.name ==# a:name
                                        return i
                                    endif
                                endfor
                                throw "NERDTree.BookmarkNotFoundError: no bookmark found for name: \"". a:name  .'"'
                            endfunction
                            
                            " FUNCTION: Bookmark.BookmarkNames()   {{{1
                            " Class method to return an array of all bookmark names
    2              0.000004 function! s:Bookmark.BookmarkNames()
                                let names = []
                                for i in s:Bookmark.Bookmarks()
                                    call add(names, i.name)
                                endfor
                                return names
                            endfunction
                            
                            " FUNCTION: Bookmark.CacheBookmarks(silent) {{{1
                            " Class method to read all bookmarks from the bookmarks file intialize
                            " bookmark objects for each one.
                            "
                            " Args:
                            " silent - dont echo an error msg if invalid bookmarks are found
    2              0.000004 function! s:Bookmark.CacheBookmarks(silent)
                                if filereadable(g:NERDTreeBookmarksFile)
                                    let g:NERDTreeBookmarks = []
                                    let g:NERDTreeInvalidBookmarks = []
                                    let bookmarkStrings = readfile(g:NERDTreeBookmarksFile)
                                    let invalidBookmarksFound = 0
                                    for i in bookmarkStrings
                            
                                        "ignore blank lines
                                        if i != ''
                            
                                            let name = substitute(i, '^\(.\{-}\) .*$', '\1', '')
                                            let path = substitute(i, '^.\{-} \(.*\)$', '\1', '')
                            
                                            try
                                                let bookmark = s:Bookmark.New(name, g:NERDTreePath.New(path))
                                                call add(g:NERDTreeBookmarks, bookmark)
                                            catch /^NERDTree.InvalidArgumentsError/
                                                call add(g:NERDTreeInvalidBookmarks, i)
                                                let invalidBookmarksFound += 1
                                            endtry
                                        endif
                                    endfor
                                    if invalidBookmarksFound
                                        call s:Bookmark.Write()
                                        if !a:silent
                                            call nerdtree#echo(invalidBookmarksFound . " invalid bookmarks were read. See :help NERDTreeInvalidBookmarks for info.")
                                        endif
                                    endif
                                    call s:Bookmark.Sort()
                                endif
                            endfunction
                            
                            " FUNCTION: Bookmark.compareTo(otherbookmark) {{{1
                            " Compare these two bookmarks for sorting purposes
    2              0.000006 function! s:Bookmark.compareTo(otherbookmark)
                                return a:otherbookmark.name < self.name
                            endfunction
                            " FUNCTION: Bookmark.ClearAll() {{{1
                            " Class method to delete all bookmarks.
    2              0.000004 function! s:Bookmark.ClearAll()
                                for i in s:Bookmark.Bookmarks()
                                    call i.delete()
                                endfor
                                call s:Bookmark.Write()
                            endfunction
                            
                            " FUNCTION: Bookmark.delete() {{{1
                            " Delete this bookmark. If the node for this bookmark is under the current
                            " root, then recache bookmarks for its Path object
    2              0.000009 function! s:Bookmark.delete()
                                let node = {}
                                try
                                    let node = self.getNode(1)
                                catch /^NERDTree.BookmarkedNodeNotFoundError/
                                endtry
                                call remove(s:Bookmark.Bookmarks(), index(s:Bookmark.Bookmarks(), self))
                                if !empty(node)
                                    call node.path.cacheDisplayString()
                                endif
                                call s:Bookmark.Write()
                            endfunction
                            
                            " FUNCTION: Bookmark.getNode(searchFromAbsoluteRoot) {{{1
                            " Gets the treenode for this bookmark
                            "
                            " Args:
                            " searchFromAbsoluteRoot: specifies whether we should search from the current
                            " tree root, or the highest cached node
    2              0.000004 function! s:Bookmark.getNode(searchFromAbsoluteRoot)
                                let searchRoot = a:searchFromAbsoluteRoot ? g:NERDTreeDirNode.AbsoluteTreeRoot() : b:NERDTreeRoot
                                let targetNode = searchRoot.findNode(self.path)
                                if empty(targetNode)
                                    throw "NERDTree.BookmarkedNodeNotFoundError: no node was found for bookmark: " . self.name
                                endif
                                return targetNode
                            endfunction
                            
                            " FUNCTION: Bookmark.GetNodeForName(name, searchFromAbsoluteRoot) {{{1
                            " Class method that finds the bookmark with the given name and returns the
                            " treenode for it.
    2              0.000005 function! s:Bookmark.GetNodeForName(name, searchFromAbsoluteRoot)
                                let bookmark = s:Bookmark.BookmarkFor(a:name)
                                return bookmark.getNode(a:searchFromAbsoluteRoot)
                            endfunction
                            
                            " FUNCTION: Bookmark.GetSelected() {{{1
                            " returns the Bookmark the cursor is over, or {}
    2              0.000004 function! s:Bookmark.GetSelected()
                                let line = getline(".")
                                let name = substitute(line, '^>\(.\{-}\) .\+$', '\1', '')
                                if name != line
                                    try
                                        return s:Bookmark.BookmarkFor(name)
                                    catch /^NERDTree.BookmarkNotFoundError/
                                        return {}
                                    endtry
                                endif
                                return {}
                            endfunction
                            
                            " FUNCTION: Bookmark.InvalidBookmarks()   {{{1
                            " Class method to get all invalid bookmark strings read from the bookmarks
                            " file
    2              0.000004 function! s:Bookmark.InvalidBookmarks()
                                if !exists("g:NERDTreeInvalidBookmarks")
                                    let g:NERDTreeInvalidBookmarks = []
                                endif
                                return g:NERDTreeInvalidBookmarks
                            endfunction
                            
                            " FUNCTION: Bookmark.mustExist() {{{1
    2              0.000004 function! s:Bookmark.mustExist()
                                if !self.path.exists()
                                    call s:Bookmark.CacheBookmarks(1)
                                    throw "NERDTree.BookmarkPointsToInvalidLocationError: the bookmark \"".
                                        \ self.name ."\" points to a non existing location: \"". self.path.str()
                                endif
                            endfunction
                            
                            " FUNCTION: Bookmark.New(name, path) {{{1
                            " Create a new bookmark object with the given name and path object
    2              0.000006 function! s:Bookmark.New(name, path)
                                if a:name =~# ' '
                                    throw "NERDTree.IllegalBookmarkNameError: illegal name:" . a:name
                                endif
                            
                                let newBookmark = copy(self)
                                let newBookmark.name = a:name
                                let newBookmark.path = a:path
                                return newBookmark
                            endfunction
                            
                            " FUNCTION: Bookmark.open([options]) {{{1
                            "Args:
                            "A dictionary containing the following keys (all optional):
                            "  'where': Specifies whether the node should be opened in new split/tab or in
                            "           the previous window. Can be either 'v' (vertical split), 'h'
                            "           (horizontal split), 't' (new tab) or 'p' (previous window).
                            "  'reuse': if a window is displaying the file then jump the cursor there
                            "  'keepopen': dont close the tree window
                            "  'stay': open the file, but keep the cursor in the tree win
                            "
    2              0.000004 function! s:Bookmark.open(...)
                                let opts = a:0 ? a:1 : {}
                            
                                if self.path.isDirectory && !has_key(opts, 'where')
                                    call self.toRoot()
                                else
                                    let opener = g:NERDTreeOpener.New(self.path, opts)
                                    call opener.open(self)
                                endif
                            endfunction
                            
                            " FUNCTION: Bookmark.openInNewTab(options) {{{1
                            " Create a new bookmark object with the given name and path object
    2              0.000005 function! s:Bookmark.openInNewTab(options)
                                call nerdtree#deprecated('Bookmark.openInNewTab', 'is deprecated, use open() instead')
                                call self.open(a:options)
                            endfunction
                            
                            " FUNCTION: Bookmark.setPath(path)   {{{1
                            " makes this bookmark point to the given path
    2              0.000004 function! s:Bookmark.setPath(path)
                                let self.path = a:path
                            endfunction
                            
                            " FUNCTION: Bookmark.Sort()   {{{1
                            " Class method that sorts all bookmarks
    2              0.000007 function! s:Bookmark.Sort()
                                let CompareFunc = function("nerdtree#compareBookmarks")
                                call sort(s:Bookmark.Bookmarks(), CompareFunc)
                            endfunction
                            
                            " FUNCTION: Bookmark.str()   {{{1
                            " Get the string that should be rendered in the view for this bookmark
    2              0.000004 function! s:Bookmark.str()
                                let pathStrMaxLen = winwidth(nerdtree#getTreeWinNum()) - 4 - len(self.name)
                                if &nu
                                    let pathStrMaxLen = pathStrMaxLen - &numberwidth
                                endif
                            
                                let pathStr = self.path.str({'format': 'UI'})
                                if len(pathStr) > pathStrMaxLen
                                    let pathStr = '<' . strpart(pathStr, len(pathStr) - pathStrMaxLen)
                                endif
                                return '>' . self.name . ' ' . pathStr
                            endfunction
                            
                            " FUNCTION: Bookmark.toRoot() {{{1
                            " Make the node for this bookmark the new tree root
    2              0.000004 function! s:Bookmark.toRoot()
                                if self.validate()
                                    try
                                        let targetNode = self.getNode(1)
                                    catch /^NERDTree.BookmarkedNodeNotFoundError/
                                        let targetNode = g:NERDTreeFileNode.New(s:Bookmark.BookmarkFor(self.name).path)
                                    endtry
                                    call targetNode.makeRoot()
                                    call nerdtree#renderView()
                                    call targetNode.putCursorHere(0, 0)
                                endif
                            endfunction
                            
                            " FUNCTION: Bookmark.ToRoot(name) {{{1
                            " Make the node for this bookmark the new tree root
    2              0.000004 function! s:Bookmark.ToRoot(name)
                                let bookmark = s:Bookmark.BookmarkFor(a:name)
                                call bookmark.toRoot()
                            endfunction
                            
                            " FUNCTION: Bookmark.validate() {{{1
    2              0.000004 function! s:Bookmark.validate()
                                if self.path.exists()
                                    return 1
                                else
                                    call s:Bookmark.CacheBookmarks(1)
                                    call nerdtree#renderView()
                                    call nerdtree#echo(self.name . "now points to an invalid location. See :help NERDTreeInvalidBookmarks for info.")
                                    return 0
                                endif
                            endfunction
                            
                            " FUNCTION: Bookmark.Write()   {{{1
                            " Class method to write all bookmarks to the bookmarks file
    2              0.000004 function! s:Bookmark.Write()
                                let bookmarkStrings = []
                                for i in s:Bookmark.Bookmarks()
                                    call add(bookmarkStrings, i.name . ' ' . i.path.str())
                                endfor
                            
                                "add a blank line before the invalid ones
                                call add(bookmarkStrings, "")
                            
                                for j in s:Bookmark.InvalidBookmarks()
                                    call add(bookmarkStrings, j)
                                endfor
                                call writefile(bookmarkStrings, g:NERDTreeBookmarksFile)
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/nerdtree/plugin/nerdtree/tree_file_node.vim
Sourced 2 times
Total time:   0.001387
 Self time:   0.001387

count  total (s)   self (s)
                            "CLASS: TreeFileNode
                            "This class is the parent of the TreeDirNode class and is the
                            "'Component' part of the composite design pattern between the treenode
                            "classes.
                            "============================================================
    2              0.000008 let s:TreeFileNode = {}
    2              0.000015 let g:NERDTreeFileNode = s:TreeFileNode
                            
                            "FUNCTION: TreeFileNode.activate(...) {{{1
    2              0.000006 function! s:TreeFileNode.activate(...)
                                call self.open(a:0 ? a:1 : {})
                            endfunction
                            
                            "FUNCTION: TreeFileNode.bookmark(name) {{{1
                            "bookmark this node with a:name
    2              0.000004 function! s:TreeFileNode.bookmark(name)
                            
                                "if a bookmark exists with the same name and the node is cached then save
                                "it so we can update its display string
                                let oldMarkedNode = {}
                                try
                                    let oldMarkedNode = g:NERDTreeBookmark.GetNodeForName(a:name, 1)
                                catch /^NERDTree.BookmarkNotFoundError/
                                catch /^NERDTree.BookmarkedNodeNotFoundError/
                                endtry
                            
                                call g:NERDTreeBookmark.AddBookmark(a:name, self.path)
                                call self.path.cacheDisplayString()
                                call g:NERDTreeBookmark.Write()
                            
                                if !empty(oldMarkedNode)
                                    call oldMarkedNode.path.cacheDisplayString()
                                endif
                            endfunction
                            
                            "FUNCTION: TreeFileNode.cacheParent() {{{1
                            "initializes self.parent if it isnt already
    2              0.000004 function! s:TreeFileNode.cacheParent()
                                if empty(self.parent)
                                    let parentPath = self.path.getParent()
                                    if parentPath.equals(self.path)
                                        throw "NERDTree.CannotCacheParentError: already at root"
                                    endif
                                    let self.parent = s:TreeFileNode.New(parentPath)
                                endif
                            endfunction
                            
                            "FUNCTION: TreeFileNode.clearBookmarks() {{{1
    2              0.000004 function! s:TreeFileNode.clearBookmarks()
                                for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self.path)
                                        call i.delete()
                                    end
                                endfor
                                call self.path.cacheDisplayString()
                            endfunction
                            
                            "FUNCTION: TreeFileNode.copy(dest) {{{1
    2              0.000005 function! s:TreeFileNode.copy(dest)
                                call self.path.copy(a:dest)
                                let newPath = g:NERDTreePath.New(a:dest)
                                let parent = b:NERDTreeRoot.findNode(newPath.getParent())
                                if !empty(parent)
                                    call parent.refresh()
                                    return parent.findNode(newPath)
                                else
                                    return {}
                                endif
                            endfunction
                            
                            "FUNCTION: TreeFileNode.delete {{{1
                            "Removes this node from the tree and calls the Delete method for its path obj
    2              0.000004 function! s:TreeFileNode.delete()
                                call self.path.delete()
                                call self.parent.removeChild(self)
                            endfunction
                            
                            "FUNCTION: TreeFileNode.displayString() {{{1
                            "
                            "Returns a string that specifies how the node should be represented as a
                            "string
                            "
                            "Return:
                            "a string that can be used in the view to represent this node
    2              0.000004 function! s:TreeFileNode.displayString()
                                return self.path.displayString()
                            endfunction
                            
                            "FUNCTION: TreeFileNode.equals(treenode) {{{1
                            "
                            "Compares this treenode to the input treenode and returns 1 if they are the
                            "same node.
                            "
                            "Use this method instead of ==  because sometimes when the treenodes contain
                            "many children, vim seg faults when doing ==
                            "
                            "Args:
                            "treenode: the other treenode to compare to
    2              0.000004 function! s:TreeFileNode.equals(treenode)
                                return self.path.str() ==# a:treenode.path.str()
                            endfunction
                            
                            "FUNCTION: TreeFileNode.findNode(path) {{{1
                            "Returns self if this node.path.Equals the given path.
                            "Returns {} if not equal.
                            "
                            "Args:
                            "path: the path object to compare against
    2              0.000004 function! s:TreeFileNode.findNode(path)
                                if a:path.equals(self.path)
                                    return self
                                endif
                                return {}
                            endfunction
                            
                            "FUNCTION: TreeFileNode.findOpenDirSiblingWithVisibleChildren(direction) {{{1
                            "
                            "Finds the next sibling for this node in the indicated direction. This sibling
                            "must be a directory and may/may not have children as specified.
                            "
                            "Args:
                            "direction: 0 if you want to find the previous sibling, 1 for the next sibling
                            "
                            "Return:
                            "a treenode object or {} if no appropriate sibling could be found
    2              0.000006 function! s:TreeFileNode.findOpenDirSiblingWithVisibleChildren(direction)
                                "if we have no parent then we can have no siblings
                                if self.parent != {}
                                    let nextSibling = self.findSibling(a:direction)
                            
                                    while nextSibling != {}
                                        if nextSibling.path.isDirectory && nextSibling.hasVisibleChildren() && nextSibling.isOpen
                                            return nextSibling
                                        endif
                                        let nextSibling = nextSibling.findSibling(a:direction)
                                    endwhile
                                endif
                            
                                return {}
                            endfunction
                            
                            "FUNCTION: TreeFileNode.findSibling(direction) {{{1
                            "
                            "Finds the next sibling for this node in the indicated direction
                            "
                            "Args:
                            "direction: 0 if you want to find the previous sibling, 1 for the next sibling
                            "
                            "Return:
                            "a treenode object or {} if no sibling could be found
    2              0.000005 function! s:TreeFileNode.findSibling(direction)
                                "if we have no parent then we can have no siblings
                                if self.parent != {}
                            
                                    "get the index of this node in its parents children
                                    let siblingIndx = self.parent.getChildIndex(self.path)
                            
                                    if siblingIndx != -1
                                        "move a long to the next potential sibling node
                                        let siblingIndx = a:direction ==# 1 ? siblingIndx+1 : siblingIndx-1
                            
                                        "keep moving along to the next sibling till we find one that is valid
                                        let numSiblings = self.parent.getChildCount()
                                        while siblingIndx >= 0 && siblingIndx < numSiblings
                            
                                            "if the next node is not an ignored node (i.e. wont show up in the
                                            "view) then return it
                                            if self.parent.children[siblingIndx].path.ignore() ==# 0
                                                return self.parent.children[siblingIndx]
                                            endif
                            
                                            "go to next node
                                            let siblingIndx = a:direction ==# 1 ? siblingIndx+1 : siblingIndx-1
                                        endwhile
                                    endif
                                endif
                            
                                return {}
                            endfunction
                            
                            "FUNCTION: TreeFileNode.getLineNum(){{{1
                            "returns the line number this node is rendered on, or -1 if it isnt rendered
    2              0.000004 function! s:TreeFileNode.getLineNum()
                                "if the node is the root then return the root line no.
                                if self.isRoot()
                                    return s:TreeFileNode.GetRootLineNum()
                                endif
                            
                                let totalLines = line("$")
                            
                                "the path components we have matched so far
                                let pathcomponents = [substitute(b:NERDTreeRoot.path.str({'format': 'UI'}), '/ *$', '', '')]
                                "the index of the component we are searching for
                                let curPathComponent = 1
                            
                                let fullpath = self.path.str({'format': 'UI'})
                            
                            
                                let lnum = s:TreeFileNode.GetRootLineNum()
                                while lnum > 0
                                    let lnum = lnum + 1
                                    "have we reached the bottom of the tree?
                                    if lnum ==# totalLines+1
                                        return -1
                                    endif
                            
                                    let curLine = getline(lnum)
                            
                                    let indent = nerdtree#indentLevelFor(curLine)
                                    if indent ==# curPathComponent
                                        let curLine = nerdtree#stripMarkupFromLine(curLine, 1)
                            
                                        let curPath =  join(pathcomponents, '/') . '/' . curLine
                                        if stridx(fullpath, curPath, 0) ==# 0
                                            if fullpath ==# curPath || strpart(fullpath, len(curPath)-1,1) ==# '/'
                                                let curLine = substitute(curLine, '/ *$', '', '')
                                                call add(pathcomponents, curLine)
                                                let curPathComponent = curPathComponent + 1
                            
                                                if fullpath ==# curPath
                                                    return lnum
                                                endif
                                            endif
                                        endif
                                    endif
                                endwhile
                                return -1
                            endfunction
                            
                            "FUNCTION: TreeFileNode.GetRootForTab(){{{1
                            "get the root node for this tab
    2              0.000004 function! s:TreeFileNode.GetRootForTab()
                                if nerdtree#treeExistsForTab()
                                    return getbufvar(t:NERDTreeBufName, 'NERDTreeRoot')
                                end
                                return {}
                            endfunction
                            
                            "FUNCTION: TreeFileNode.GetRootLineNum(){{{1
                            "gets the line number of the root node
    2              0.000004 function! s:TreeFileNode.GetRootLineNum()
                                let rootLine = 1
                                while getline(rootLine) !~# '^\(/\|<\)'
                                    let rootLine = rootLine + 1
                                endwhile
                                return rootLine
                            endfunction
                            
                            "FUNCTION: TreeFileNode.GetSelected() {{{1
                            "gets the treenode that the cursor is currently over
    2              0.000004 function! s:TreeFileNode.GetSelected()
                                try
                                    let path = nerdtree#getPath(line("."))
                                    if path ==# {}
                                        return {}
                                    endif
                                    return b:NERDTreeRoot.findNode(path)
                                catch /^NERDTree/
                                    return {}
                                endtry
                            endfunction
                            
                            "FUNCTION: TreeFileNode.isVisible() {{{1
                            "returns 1 if this node should be visible according to the tree filters and
                            "hidden file filters (and their on/off status)
    2              0.000004 function! s:TreeFileNode.isVisible()
                                return !self.path.ignore()
                            endfunction
                            
                            "FUNCTION: TreeFileNode.isRoot() {{{1
                            "returns 1 if this node is b:NERDTreeRoot
    2              0.000004 function! s:TreeFileNode.isRoot()
                                if !nerdtree#treeExistsForBuf()
                                    throw "NERDTree.NoTreeError: No tree exists for the current buffer"
                                endif
                            
                                return self.equals(b:NERDTreeRoot)
                            endfunction
                            
                            "FUNCTION: TreeFileNode.makeRoot() {{{1
                            "Make this node the root of the tree
    2              0.000003 function! s:TreeFileNode.makeRoot()
                                if self.path.isDirectory
                                    let b:NERDTreeRoot = self
                                else
                                    call self.cacheParent()
                                    let b:NERDTreeRoot = self.parent
                                endif
                            
                                call b:NERDTreeRoot.open()
                            
                                "change dir to the dir of the new root if instructed to
                                if g:NERDTreeChDirMode ==# 2
                                    exec "cd " . b:NERDTreeRoot.path.str({'format': 'Edit'})
                                endif
                            
                                silent doautocmd User NERDTreeNewRoot
                            endfunction
                            
                            "FUNCTION: TreeFileNode.New(path) {{{1
                            "Returns a new TreeNode object with the given path and parent
                            "
                            "Args:
                            "path: a path object representing the full filesystem path to the file/dir that the node represents
    2              0.000004 function! s:TreeFileNode.New(path)
                                if a:path.isDirectory
                                    return g:NERDTreeDirNode.New(a:path)
                                else
                                    let newTreeNode = copy(self)
                                    let newTreeNode.path = a:path
                                    let newTreeNode.parent = {}
                                    return newTreeNode
                                endif
                            endfunction
                            
                            "FUNCTION: TreeFileNode.open() {{{1
    2              0.000004 function! s:TreeFileNode.open(...)
                                let opts = a:0 ? a:1 : {}
                                let opener = g:NERDTreeOpener.New(self.path, opts)
                                call opener.open(self)
                            endfunction
                            
                            "FUNCTION: TreeFileNode.openSplit() {{{1
                            "Open this node in a new window
    2              0.000006 function! s:TreeFileNode.openSplit()
                                call nerdtree#deprecated('TreeFileNode.openSplit', 'is deprecated, use .open() instead.')
                                call self.open({'where': 'h'})
                            endfunction
                            
                            "FUNCTION: TreeFileNode.openVSplit() {{{1
                            "Open this node in a new vertical window
    2              0.000004 function! s:TreeFileNode.openVSplit()
                                call nerdtree#deprecated('TreeFileNode.openVSplit', 'is deprecated, use .open() instead.')
                                call self.open({'where': 'v'})
                            endfunction
                            
                            "FUNCTION: TreeFileNode.openInNewTab(options) {{{1
    2              0.000004 function! s:TreeFileNode.openInNewTab(options)
                                echomsg 'TreeFileNode.openInNewTab is deprecated'
                                call self.open(extend({'where': 't'}, a:options))
                            endfunction
                            
                            "FUNCTION: TreeFileNode.putCursorHere(isJump, recurseUpward){{{1
                            "Places the cursor on the line number this node is rendered on
                            "
                            "Args:
                            "isJump: 1 if this cursor movement should be counted as a jump by vim
                            "recurseUpward: try to put the cursor on the parent if the this node isnt
                            "visible
    2              0.000004 function! s:TreeFileNode.putCursorHere(isJump, recurseUpward)
                                let ln = self.getLineNum()
                                if ln != -1
                                    if a:isJump
                                        mark '
                                    endif
                                    call cursor(ln, col("."))
                                else
                                    if a:recurseUpward
                                        let node = self
                                        while node != {} && node.getLineNum() ==# -1
                                            let node = node.parent
                                            call node.open()
                                        endwhile
                                        call nerdtree#renderView()
                                        call node.putCursorHere(a:isJump, 0)
                                    endif
                                endif
                            endfunction
                            
                            "FUNCTION: TreeFileNode.refresh() {{{1
    2              0.000004 function! s:TreeFileNode.refresh()
                                call self.path.refresh()
                            endfunction
                            
                            "FUNCTION: TreeFileNode.rename() {{{1
                            "Calls the rename method for this nodes path obj
    2              0.000004 function! s:TreeFileNode.rename(newName)
                                let newName = substitute(a:newName, '\(\\\|\/\)$', '', '')
                                call self.path.rename(newName)
                                call self.parent.removeChild(self)
                            
                                let parentPath = self.path.getParent()
                                let newParent = b:NERDTreeRoot.findNode(parentPath)
                            
                                if newParent != {}
                                    call newParent.createChild(self.path, 1)
                                    call newParent.refresh()
                                endif
                            endfunction
                            
                            "FUNCTION: TreeFileNode.renderToString {{{1
                            "returns a string representation for this tree to be rendered in the view
    2              0.000008 function! s:TreeFileNode.renderToString()
                                return self._renderToString(0, 0, [], self.getChildCount() ==# 1)
                            endfunction
                            
                            "Args:
                            "depth: the current depth in the tree for this call
                            "drawText: 1 if we should actually draw the line for this node (if 0 then the
                            "child nodes are rendered only)
                            "vertMap: a binary array that indicates whether a vertical bar should be draw
                            "for each depth in the tree
                            "isLastChild:true if this curNode is the last child of its parent
    2              0.000006 function! s:TreeFileNode._renderToString(depth, drawText, vertMap, isLastChild)
                                let output = ""
                                if a:drawText ==# 1
                            
                                    let treeParts = ''
                            
                                    "get all the leading spaces and vertical tree parts for this line
                                    if a:depth > 1
                                        for j in a:vertMap[0:-2]
                                            if g:NERDTreeDirArrows
                                                let treeParts = treeParts . '  '
                                            else
                                                if j ==# 1
                                                    let treeParts = treeParts . '| '
                                                else
                                                    let treeParts = treeParts . '  '
                                                endif
                                            endif
                                        endfor
                                    endif
                            
                                    "get the last vertical tree part for this line which will be different
                                    "if this node is the last child of its parent
                                    if !g:NERDTreeDirArrows
                                        if a:isLastChild
                                            let treeParts = treeParts . '`'
                                        else
                                            let treeParts = treeParts . '|'
                                        endif
                                    endif
                            
                                    "smack the appropriate dir/file symbol on the line before the file/dir
                                    "name itself
                                    if self.path.isDirectory
                                        if self.isOpen
                                            if g:NERDTreeDirArrows
                                                let treeParts = treeParts . '▾ '
                                            else
                                                let treeParts = treeParts . '~'
                                            endif
                                        else
                                            if g:NERDTreeDirArrows
                                                let treeParts = treeParts . '▸ '
                                            else
                                                let treeParts = treeParts . '+'
                                            endif
                                        endif
                                    else
                                        if g:NERDTreeDirArrows
                                            let treeParts = treeParts . '  '
                                        else
                                            let treeParts = treeParts . '-'
                                        endif
                                    endif
                                    let line = treeParts . self.displayString()
                            
                                    let output = output . line . "\n"
                                endif
                            
                                "if the node is an open dir, draw its children
                                if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
                                    let childNodesToDraw = self.getVisibleChildren()
                                    if len(childNodesToDraw) > 0
                            
                                        "draw all the nodes children except the last
                                        let lastIndx = len(childNodesToDraw)-1
                                        if lastIndx > 0
                                            for i in childNodesToDraw[0:lastIndx-1]
                                                let output = output . i._renderToString(a:depth + 1, 1, add(copy(a:vertMap), 1), 0)
                                            endfor
                                        endif
                            
                                        "draw the last child, indicating that it IS the last
                                        let output = output . childNodesToDraw[lastIndx]._renderToString(a:depth + 1, 1, add(copy(a:vertMap), 0), 1)
                                    endif
                                endif
                            
                                return output
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/nerdtree/plugin/nerdtree/tree_dir_node.vim
Sourced 2 times
Total time:   0.001315
 Self time:   0.001315

count  total (s)   self (s)
                            "CLASS: TreeDirNode
                            "A subclass of NERDTreeFileNode.
                            "
                            "The 'composite' part of the file/dir composite.
                            "============================================================
    2              0.000036 let s:TreeDirNode = copy(g:NERDTreeFileNode)
    2              0.000042 let g:NERDTreeDirNode = s:TreeDirNode
                            
                            "FUNCTION: TreeDirNode.AbsoluteTreeRoot(){{{1
                            "class method that returns the highest cached ancestor of the current root
    2              0.000005 function! s:TreeDirNode.AbsoluteTreeRoot()
                                let currentNode = b:NERDTreeRoot
                                while currentNode.parent != {}
                                    let currentNode = currentNode.parent
                                endwhile
                                return currentNode
                            endfunction
                            
                            "FUNCTION: TreeDirNode.activate([options]) {{{1
    2              0.000005 unlet s:TreeDirNode.activate
    2              0.000004 function! s:TreeDirNode.activate(...)
                                let opts = a:0 ? a:1 : {}
                                call self.toggleOpen(opts)
                                call nerdtree#renderView()
                                call self.putCursorHere(0, 0)
                            endfunction
                            
                            "FUNCTION: TreeDirNode.addChild(treenode, inOrder) {{{1
                            "Adds the given treenode to the list of children for this node
                            "
                            "Args:
                            "-treenode: the node to add
                            "-inOrder: 1 if the new node should be inserted in sorted order
    2              0.000005 function! s:TreeDirNode.addChild(treenode, inOrder)
                                call add(self.children, a:treenode)
                                let a:treenode.parent = self
                            
                                if a:inOrder
                                    call self.sortChildren()
                                endif
                            endfunction
                            
                            "FUNCTION: TreeDirNode.close() {{{1
                            "Closes this directory
    2              0.000004 function! s:TreeDirNode.close()
                                let self.isOpen = 0
                            endfunction
                            
                            "FUNCTION: TreeDirNode.closeChildren() {{{1
                            "Closes all the child dir nodes of this node
    2              0.000004 function! s:TreeDirNode.closeChildren()
                                for i in self.children
                                    if i.path.isDirectory
                                        call i.close()
                                        call i.closeChildren()
                                    endif
                                endfor
                            endfunction
                            
                            "FUNCTION: TreeDirNode.createChild(path, inOrder) {{{1
                            "Instantiates a new child node for this node with the given path. The new
                            "nodes parent is set to this node.
                            "
                            "Args:
                            "path: a Path object that this node will represent/contain
                            "inOrder: 1 if the new node should be inserted in sorted order
                            "
                            "Returns:
                            "the newly created node
    2              0.000004 function! s:TreeDirNode.createChild(path, inOrder)
                                let newTreeNode = g:NERDTreeFileNode.New(a:path)
                                call self.addChild(newTreeNode, a:inOrder)
                                return newTreeNode
                            endfunction
                            
                            "FUNCTION: TreeDirNode.findNode(path) {{{1
                            "Will find one of the children (recursively) that has the given path
                            "
                            "Args:
                            "path: a path object
    2              0.000004 unlet s:TreeDirNode.findNode
    2              0.000004 function! s:TreeDirNode.findNode(path)
                                if a:path.equals(self.path)
                                    return self
                                endif
                                if stridx(a:path.str(), self.path.str(), 0) ==# -1
                                    return {}
                                endif
                            
                                if self.path.isDirectory
                                    for i in self.children
                                        let retVal = i.findNode(a:path)
                                        if retVal != {}
                                            return retVal
                                        endif
                                    endfor
                                endif
                                return {}
                            endfunction
                            
                            "FUNCTION: TreeDirNode.getChildCount() {{{1
                            "Returns the number of children this node has
    2              0.000004 function! s:TreeDirNode.getChildCount()
                                return len(self.children)
                            endfunction
                            
                            "FUNCTION: TreeDirNode.getChild(path) {{{1
                            "Returns child node of this node that has the given path or {} if no such node
                            "exists.
                            "
                            "This function doesnt not recurse into child dir nodes
                            "
                            "Args:
                            "path: a path object
    2              0.000004 function! s:TreeDirNode.getChild(path)
                                if stridx(a:path.str(), self.path.str(), 0) ==# -1
                                    return {}
                                endif
                            
                                let index = self.getChildIndex(a:path)
                                if index ==# -1
                                    return {}
                                else
                                    return self.children[index]
                                endif
                            
                            endfunction
                            
                            "FUNCTION: TreeDirNode.getChildByIndex(indx, visible) {{{1
                            "returns the child at the given index
                            "Args:
                            "indx: the index to get the child from
                            "visible: 1 if only the visible children array should be used, 0 if all the
                            "children should be searched.
    2              0.000005 function! s:TreeDirNode.getChildByIndex(indx, visible)
                                let array_to_search = a:visible? self.getVisibleChildren() : self.children
                                if a:indx > len(array_to_search)
                                    throw "NERDTree.InvalidArgumentsError: Index is out of bounds."
                                endif
                                return array_to_search[a:indx]
                            endfunction
                            
                            "FUNCTION: TreeDirNode.getChildIndex(path) {{{1
                            "Returns the index of the child node of this node that has the given path or
                            "-1 if no such node exists.
                            "
                            "This function doesnt not recurse into child dir nodes
                            "
                            "Args:
                            "path: a path object
    2              0.000004 function! s:TreeDirNode.getChildIndex(path)
                                if stridx(a:path.str(), self.path.str(), 0) ==# -1
                                    return -1
                                endif
                            
                                "do a binary search for the child
                                let a = 0
                                let z = self.getChildCount()
                                while a < z
                                    let mid = (a+z)/2
                                    let diff = a:path.compareTo(self.children[mid].path)
                            
                                    if diff ==# -1
                                        let z = mid
                                    elseif diff ==# 1
                                        let a = mid+1
                                    else
                                        return mid
                                    endif
                                endwhile
                                return -1
                            endfunction
                            
                            "FUNCTION: TreeDirNode.GetSelected() {{{1
                            "Returns the current node if it is a dir node, or else returns the current
                            "nodes parent
    2              0.000004 unlet s:TreeDirNode.GetSelected
    2              0.000004 function! s:TreeDirNode.GetSelected()
                                let currentDir = g:NERDTreeFileNode.GetSelected()
                                if currentDir != {} && !currentDir.isRoot()
                                    if currentDir.path.isDirectory ==# 0
                                        let currentDir = currentDir.parent
                                    endif
                                endif
                                return currentDir
                            endfunction
                            
                            "FUNCTION: TreeDirNode.getVisibleChildCount() {{{1
                            "Returns the number of visible children this node has
    2              0.000004 function! s:TreeDirNode.getVisibleChildCount()
                                return len(self.getVisibleChildren())
                            endfunction
                            
                            "FUNCTION: TreeDirNode.getVisibleChildren() {{{1
                            "Returns a list of children to display for this node, in the correct order
                            "
                            "Return:
                            "an array of treenodes
    2              0.000004 function! s:TreeDirNode.getVisibleChildren()
                                let toReturn = []
                                for i in self.children
                                    if i.path.ignore() ==# 0
                                        call add(toReturn, i)
                                    endif
                                endfor
                                return toReturn
                            endfunction
                            
                            "FUNCTION: TreeDirNode.hasVisibleChildren() {{{1
                            "returns 1 if this node has any childre, 0 otherwise..
    2              0.000004 function! s:TreeDirNode.hasVisibleChildren()
                                return self.getVisibleChildCount() != 0
                            endfunction
                            
                            "FUNCTION: TreeDirNode._initChildren() {{{1
                            "Removes all childen from this node and re-reads them
                            "
                            "Args:
                            "silent: 1 if the function should not echo any "please wait" messages for
                            "large directories
                            "
                            "Return: the number of child nodes read
    2              0.000005 function! s:TreeDirNode._initChildren(silent)
                                "remove all the current child nodes
                                let self.children = []
                            
                                "get an array of all the files in the nodes dir
                                let dir = self.path
                                let globDir = dir.str({'format': 'Glob'})
                            
                                if version >= 703
                                    let filesStr = globpath(globDir, '*', 1) . "\n" . globpath(globDir, '.*', 1)
                                else
                                    let filesStr = globpath(globDir, '*') . "\n" . globpath(globDir, '.*')
                                endif
                            
                                let files = split(filesStr, "\n")
                            
                                if !a:silent && len(files) > g:NERDTreeNotificationThreshold
                                    call nerdtree#echo("Please wait, caching a large dir ...")
                                endif
                            
                                let invalidFilesFound = 0
                                for i in files
                            
                                    "filter out the .. and . directories
                                    "Note: we must match .. AND ../ cos sometimes the globpath returns
                                    "../ for path with strange chars (eg $)
                                    if i !~# '\/\.\.\/\?$' && i !~# '\/\.\/\?$'
                            
                                        "put the next file in a new node and attach it
                                        try
                                            let path = g:NERDTreePath.New(i)
                                            call self.createChild(path, 0)
                                        catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                                            let invalidFilesFound += 1
                                        endtry
                                    endif
                                endfor
                            
                                call self.sortChildren()
                            
                                if !a:silent && len(files) > g:NERDTreeNotificationThreshold
                                    call nerdtree#echo("Please wait, caching a large dir ... DONE (". self.getChildCount() ." nodes cached).")
                                endif
                            
                                if invalidFilesFound
                                    call nerdtree#echoWarning(invalidFilesFound . " file(s) could not be loaded into the NERD tree")
                                endif
                                return self.getChildCount()
                            endfunction
                            
                            "FUNCTION: TreeDirNode.New(path) {{{1
                            "Returns a new TreeNode object with the given path and parent
                            "
                            "Args:
                            "path: a path object representing the full filesystem path to the file/dir that the node represents
    2              0.000004 unlet s:TreeDirNode.New
    2              0.000004 function! s:TreeDirNode.New(path)
                                if a:path.isDirectory != 1
                                    throw "NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object."
                                endif
                            
                                let newTreeNode = copy(self)
                                let newTreeNode.path = a:path
                            
                                let newTreeNode.isOpen = 0
                                let newTreeNode.children = []
                            
                                let newTreeNode.parent = {}
                            
                                return newTreeNode
                            endfunction
                            
                            "FUNCTION: TreeDirNode.open([opts]) {{{1
                            "Open the dir in the current tree or in a new tree elsewhere.
                            "
                            "If opening in the current tree, return the number of cached nodes.
    2              0.000004 unlet s:TreeDirNode.open
    2              0.000004 function! s:TreeDirNode.open(...)
                                let opts = a:0 ? a:1 : {}
                            
                                if has_key(opts, 'where') && !empty(opts['where'])
                                    let opener = g:NERDTreeOpener.New(self.path, opts)
                                    call opener.open(self)
                                else
                                    let self.isOpen = 1
                                    if self.children ==# []
                                        return self._initChildren(0)
                                    else
                                        return 0
                                    endif
                                endif
                            endfunction
                            
                            "FUNCTION: TreeDirNode.openAlong([opts]) {{{1
                            "recursive open the dir if it has only one directory child.
                            "
                            "return the level of opened directories.
    2              0.000004 function! s:TreeDirNode.openAlong(...)
                                let opts = a:0 ? a:1 : {}
                                let level = 0
                            
                                let node = self
                                while node.path.isDirectory
                                    call node.open(opts)
                                    let level += 1
                                    if node.getVisibleChildCount() == 1
                                        let node = node.getChildByIndex(0, 1)
                                    else
                                        break
                                    endif
                                endwhile
                                return level
                            endfunction
                            
                            " FUNCTION: TreeDirNode.openExplorer() {{{1
                            " opens an explorer window for this node in the previous window (could be a
                            " nerd tree or a netrw)
    2              0.000004 function! s:TreeDirNode.openExplorer()
                                call self.open({'where': 'p'})
                            endfunction
                            
                            "FUNCTION: TreeDirNode.openInNewTab(options) {{{1
    2              0.000007 unlet s:TreeDirNode.openInNewTab
    2              0.000004 function! s:TreeDirNode.openInNewTab(options)
                                call nerdtree#deprecated('TreeDirNode.openInNewTab', 'is deprecated, use open() instead')
                                call self.open({'where': 't'})
                            endfunction
                            
                            "FUNCTION: TreeDirNode._openInNewTab() {{{1
    2              0.000003 function! s:TreeDirNode._openInNewTab()
                                tabnew
                                call g:NERDTreeCreator.CreatePrimary(self.path.str())
                            endfunction
                            
                            "FUNCTION: TreeDirNode.openRecursively() {{{1
                            "Opens this treenode and all of its children whose paths arent 'ignored'
                            "because of the file filters.
                            "
                            "This method is actually a wrapper for the OpenRecursively2 method which does
                            "the work.
    2              0.000004 function! s:TreeDirNode.openRecursively()
                                call self._openRecursively2(1)
                            endfunction
                            
                            "FUNCTION: TreeDirNode._openRecursively2() {{{1
                            "Opens this all children of this treenode recursively if either:
                            "   *they arent filtered by file filters
                            "   *a:forceOpen is 1
                            "
                            "Args:
                            "forceOpen: 1 if this node should be opened regardless of file filters
    2              0.000005 function! s:TreeDirNode._openRecursively2(forceOpen)
                                if self.path.ignore() ==# 0 || a:forceOpen
                                    let self.isOpen = 1
                                    if self.children ==# []
                                        call self._initChildren(1)
                                    endif
                            
                                    for i in self.children
                                        if i.path.isDirectory ==# 1
                                            call i._openRecursively2(0)
                                        endif
                                    endfor
                                endif
                            endfunction
                            
                            "FUNCTION: TreeDirNode.refresh() {{{1
    2              0.000007 unlet s:TreeDirNode.refresh
    2              0.000004 function! s:TreeDirNode.refresh()
                                call self.path.refresh()
                            
                                "if this node was ever opened, refresh its children
                                if self.isOpen || !empty(self.children)
                                    "go thru all the files/dirs under this node
                                    let newChildNodes = []
                                    let invalidFilesFound = 0
                                    let dir = self.path
                                    let globDir = dir.str({'format': 'Glob'})
                                    let filesStr = globpath(globDir, '*') . "\n" . globpath(globDir, '.*')
                                    let files = split(filesStr, "\n")
                                    for i in files
                                        "filter out the .. and . directories
                                        "Note: we must match .. AND ../ cos sometimes the globpath returns
                                        "../ for path with strange chars (eg $)
                                        if i !~# '\/\.\.\/\?$' && i !~# '\/\.\/\?$'
                            
                                            try
                                                "create a new path and see if it exists in this nodes children
                                                let path = g:NERDTreePath.New(i)
                                                let newNode = self.getChild(path)
                                                if newNode != {}
                                                    call newNode.refresh()
                                                    call add(newChildNodes, newNode)
                            
                                                "the node doesnt exist so create it
                                                else
                                                    let newNode = g:NERDTreeFileNode.New(path)
                                                    let newNode.parent = self
                                                    call add(newChildNodes, newNode)
                                                endif
                            
                            
                                            catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                                                let invalidFilesFound = 1
                                            endtry
                                        endif
                                    endfor
                            
                                    "swap this nodes children out for the children we just read/refreshed
                                    let self.children = newChildNodes
                                    call self.sortChildren()
                            
                                    if invalidFilesFound
                                        call nerdtree#echoWarning("some files could not be loaded into the NERD tree")
                                    endif
                                endif
                            endfunction
                            
                            "FUNCTION: TreeDirNode.reveal(path) {{{1
                            "reveal the given path, i.e. cache and open all treenodes needed to display it
                            "in the UI
    2              0.000005 function! s:TreeDirNode.reveal(path)
                                if !a:path.isUnder(self.path)
                                    throw "NERDTree.InvalidArgumentsError: " . a:path.str() . " should be under " . self.path.str()
                                endif
                            
                                call self.open()
                            
                                if self.path.equals(a:path.getParent())
                                    let n = self.findNode(a:path)
                                    call nerdtree#renderView()
                                    call n.putCursorHere(1,0)
                                    return
                                endif
                            
                                let p = a:path
                                while !p.getParent().equals(self.path)
                                    let p = p.getParent()
                                endwhile
                            
                                let n = self.findNode(p)
                                call n.reveal(a:path)
                            endfunction
                            
                            "FUNCTION: TreeDirNode.removeChild(treenode) {{{1
                            "
                            "Removes the given treenode from this nodes set of children
                            "
                            "Args:
                            "treenode: the node to remove
                            "
                            "Throws a NERDTree.ChildNotFoundError if the given treenode is not found
    2              0.000004 function! s:TreeDirNode.removeChild(treenode)
                                for i in range(0, self.getChildCount()-1)
                                    if self.children[i].equals(a:treenode)
                                        call remove(self.children, i)
                                        return
                                    endif
                                endfor
                            
                                throw "NERDTree.ChildNotFoundError: child node was not found"
                            endfunction
                            
                            "FUNCTION: TreeDirNode.sortChildren() {{{1
                            "
                            "Sorts the children of this node according to alphabetical order and the
                            "directory priority.
                            "
    2              0.000004 function! s:TreeDirNode.sortChildren()
                                let CompareFunc = function("nerdtree#compareNodes")
                                call sort(self.children, CompareFunc)
                            endfunction
                            
                            "FUNCTION: TreeDirNode.toggleOpen([options]) {{{1
                            "Opens this directory if it is closed and vice versa
    2              0.000004 function! s:TreeDirNode.toggleOpen(...)
                                let opts = a:0 ? a:1 : {}
                                if self.isOpen ==# 1
                                    call self.close()
                                else
                                    if g:NERDTreeCasadeOpenSingleChildDir == 0
                                        call self.open(opts)
                                    else
                                        call self.openAlong(opts)
                                    endif
                                endif
                            endfunction
                            
                            "FUNCTION: TreeDirNode.transplantChild(newNode) {{{1
                            "Replaces the child of this with the given node (where the child node's full
                            "path matches a:newNode's fullpath). The search for the matching node is
                            "non-recursive
                            "
                            "Arg:
                            "newNode: the node to graft into the tree
    2              0.000005 function! s:TreeDirNode.transplantChild(newNode)
                                for i in range(0, self.getChildCount()-1)
                                    if self.children[i].equals(a:newNode)
                                        let self.children[i] = a:newNode
                                        let a:newNode.parent = self
                                        break
                                    endif
                                endfor
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/nerdtree/plugin/nerdtree/opener.vim
Sourced 2 times
Total time:   0.000466
 Self time:   0.000466

count  total (s)   self (s)
                            "CLASS: Opener
                            "============================================================
    2              0.000007 let s:Opener = {}
    2              0.000023 let g:NERDTreeOpener = s:Opener
                            
                            "FUNCTION: Opener._checkToCloseTree(newtab) {{{1
                            "Check the class options and global options (i.e. NERDTreeQuitOnOpen) to see
                            "if the tree should be closed now.
                            "
                            "Args:
                            "a:newtab - boolean. If set, only close the tree now if we are opening the
                            "target in a new tab. This is needed because we have to close tree before we
                            "leave the tab
    2              0.000005 function! s:Opener._checkToCloseTree(newtab)
                                if self._keepopen
                                    return
                                endif
                            
                                if (a:newtab && self._where == 't') || !a:newtab
                                    call nerdtree#closeTreeIfQuitOnOpen()
                                endif
                            endfunction
                            
                            "FUNCTION: Opener._gotoTargetWin() {{{1
    2              0.000004 function! s:Opener._gotoTargetWin()
                                if b:NERDTreeType ==# "secondary"
                                    if self._where == 'v'
                                        vsplit
                                    elseif self._where == 'h'
                                        split
                                    elseif self._where == 't'
                                        tabnew
                                    endif
                                else
                                    call self._checkToCloseTree(1)
                            
                                    if self._where == 'v'
                                        call self._newVSplit()
                                    elseif self._where == 'h'
                                        call self._newSplit()
                                    elseif self._where == 't'
                                        tabnew
                                    elseif self._where == 'p'
                                        call self._previousWindow()
                                    endif
                            
                                    call self._checkToCloseTree(0)
                                endif
                            endfunction
                            
                            "FUNCTION: Opener.New(path, opts) {{{1
                            "Args:
                            "
                            "a:path: The path object that is to be opened.
                            "
                            "a:opts:
                            "
                            "A dictionary containing the following keys (all optional):
                            "  'where': Specifies whether the node should be opened in new split/tab or in
                            "           the previous window. Can be either 'v' or 'h' or 't' (for open in
                            "           new tab)
                            "  'reuse': if a window is displaying the file then jump the cursor there
                            "  'keepopen': dont close the tree window
                            "  'stay': open the file, but keep the cursor in the tree win
    2              0.000005 function! s:Opener.New(path, opts)
                                let newObj = copy(self)
                            
                                let newObj._path = a:path
                                let newObj._stay = nerdtree#has_opt(a:opts, 'stay')
                                let newObj._reuse = nerdtree#has_opt(a:opts, 'reuse')
                                let newObj._keepopen = nerdtree#has_opt(a:opts, 'keepopen')
                                let newObj._where = has_key(a:opts, 'where') ? a:opts['where'] : ''
                                let newObj._treetype = b:NERDTreeType
                                call newObj._saveCursorPos()
                            
                                return newObj
                            endfunction
                            
                            "FUNCTION: Opener._newSplit() {{{1
    2              0.000004 function! s:Opener._newSplit()
                                " Save the user's settings for splitbelow and splitright
                                let savesplitbelow=&splitbelow
                                let savesplitright=&splitright
                            
                                " 'there' will be set to a command to move from the split window
                                " back to the explorer window
                                "
                                " 'back' will be set to a command to move from the explorer window
                                " back to the newly split window
                                "
                                " 'right' and 'below' will be set to the settings needed for
                                " splitbelow and splitright IF the explorer is the only window.
                                "
                                let there= g:NERDTreeWinPos ==# "left" ? "wincmd h" : "wincmd l"
                                let back = g:NERDTreeWinPos ==# "left" ? "wincmd l" : "wincmd h"
                                let right= g:NERDTreeWinPos ==# "left"
                                let below=0
                            
                                " Attempt to go to adjacent window
                                call nerdtree#exec(back)
                            
                                let onlyOneWin = (winnr("$") ==# 1)
                            
                                " If no adjacent window, set splitright and splitbelow appropriately
                                if onlyOneWin
                                    let &splitright=right
                                    let &splitbelow=below
                                else
                                    " found adjacent window - invert split direction
                                    let &splitright=!right
                                    let &splitbelow=!below
                                endif
                            
                                let splitMode = onlyOneWin ? "vertical" : ""
                            
                                " Open the new window
                                try
                                    exec(splitMode." sp ")
                                catch /^Vim\%((\a\+)\)\=:E37/
                                    call nerdtree#putCursorInTreeWin()
                                    throw "NERDTree.FileAlreadyOpenAndModifiedError: ". self._path.str() ." is already open and modified."
                                catch /^Vim\%((\a\+)\)\=:/
                                    "do nothing
                                endtry
                            
                                "resize the tree window if no other window was open before
                                if onlyOneWin
                                    let size = exists("b:NERDTreeOldWindowSize") ? b:NERDTreeOldWindowSize : g:NERDTreeWinSize
                                    call nerdtree#exec(there)
                                    exec("silent ". splitMode ." resize ". size)
                                    call nerdtree#exec('wincmd p')
                                endif
                            
                                " Restore splitmode settings
                                let &splitbelow=savesplitbelow
                                let &splitright=savesplitright
                            endfunction
                            
                            "FUNCTION: Opener._newVSplit() {{{1
    2              0.000005 function! s:Opener._newVSplit()
                                let winwidth = winwidth(".")
                                if winnr("$")==#1
                                    let winwidth = g:NERDTreeWinSize
                                endif
                            
                                call nerdtree#exec("wincmd p")
                                vnew
                            
                                "resize the nerd tree back to the original size
                                call nerdtree#putCursorInTreeWin()
                                exec("silent vertical resize ". winwidth)
                                call nerdtree#exec('wincmd p')
                            endfunction
                            
                            "FUNCTION: Opener.open(target) {{{1
    2              0.000004 function! s:Opener.open(target)
                                if self._path.isDirectory
                                    call self._openDirectory(a:target)
                                else
                                    call self._openFile()
                                endif
                            endfunction
                            
                            "FUNCTION: Opener._openFile() {{{1
    2              0.000003 function! s:Opener._openFile()
                                if self._reuse && self._reuseWindow()
                                    return
                                endif
                            
                                call self._gotoTargetWin()
                            
                                if self._treetype ==# "secondary"
                                    call self._path.edit()
                                else
                                    call self._path.edit()
                            
                            
                                    if self._stay
                                        call self._restoreCursorPos()
                                    endif
                                endif
                            endfunction
                            
                            "FUNCTION: Opener._openDirectory(node) {{{1
    2              0.000004 function! s:Opener._openDirectory(node)
                                if self._treetype ==# "secondary"
                                    call self._gotoTargetWin()
                                    call g:NERDTreeCreator.CreateSecondary(a:node.path.str())
                                else
                                    call self._gotoTargetWin()
                                    if empty(self._where)
                                        call a:node.makeRoot()
                                        call nerdtree#renderView()
                                        call a:node.putCursorHere(0, 0)
                                    elseif self._where == 't'
                                        call g:NERDTreeCreator.CreatePrimary(a:node.path.str())
                                    else
                                        call g:NERDTreeCreator.CreateSecondary(a:node.path.str())
                                    endif
                                endif
                            
                                if self._stay
                                    call self._restoreCursorPos()
                                endif
                            endfunction
                            
                            "FUNCTION: Opener._previousWindow() {{{1
    2              0.000004 function! s:Opener._previousWindow()
                                if !nerdtree#isWindowUsable(winnr("#")) && nerdtree#firstUsableWindow() ==# -1
                                    call self._newSplit()
                                else
                                    try
                                        if !nerdtree#isWindowUsable(winnr("#"))
                                            call nerdtree#exec(nerdtree#firstUsableWindow() . "wincmd w")
                                        else
                                            call nerdtree#exec('wincmd p')
                                        endif
                                    catch /^Vim\%((\a\+)\)\=:E37/
                                        call nerdtree#putCursorInTreeWin()
                                        throw "NERDTree.FileAlreadyOpenAndModifiedError: ". self._path.str() ." is already open and modified."
                                    catch /^Vim\%((\a\+)\)\=:/
                                        echo v:exception
                                    endtry
                                endif
                            endfunction
                            
                            "FUNCTION: Opener._restoreCursorPos(){{{1
    2              0.000004 function! s:Opener._restoreCursorPos()
                                call nerdtree#exec('normal ' . self._tabnr . 'gt')
                                call nerdtree#exec(bufwinnr(self._bufnr) . 'wincmd w')
                            endfunction
                            
                            "FUNCTION: Opener._reuseWindow(){{{1
                            "put the cursor in the first window we find for this file
                            "
                            "return 1 if we were successful
    2              0.000004 function! s:Opener._reuseWindow()
                                "check the current tab for the window
                                let winnr = bufwinnr('^' . self._path.str() . '$')
                                if winnr != -1
                                    call nerdtree#exec(winnr . "wincmd w")
                                    call self._checkToCloseTree(0)
                                    return 1
                                else
                                    "check other tabs
                                    let tabnr = self._path.tabnr()
                                    if tabnr
                                        call self._checkToCloseTree(1)
                                        call nerdtree#exec('normal! ' . tabnr . 'gt')
                                        let winnr = bufwinnr('^' . self._path.str() . '$')
                                        call nerdtree#exec(winnr . "wincmd w")
                                        return 1
                                    endif
                                endif
                                return 0
                            endfunction
                            
                            "FUNCTION: Opener._saveCursorPos(){{{1
    2              0.000004 function! s:Opener._saveCursorPos()
                                let self._bufnr = bufnr("")
                                let self._tabnr = tabpagenr()
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/nerdtree/plugin/nerdtree/creator.vim
Sourced 2 times
Total time:   0.000601
 Self time:   0.000601

count  total (s)   self (s)
                            "CLASS: Creator
                            "Creates primary/secondary/mirror nerdtree windows. Sets up all the window and
                            "buffer options and key mappings etc.
                            "============================================================
    2              0.000008 let s:Creator = {}
    2              0.000029 let g:NERDTreeCreator = s:Creator
                            
                            "FUNCTION: s:Creator._bindMappings() {{{1
    2              0.000005 function! s:Creator._bindMappings()
                                "make <cr> do the same as the default 'o' mapping
                                exec "nnoremap <silent> <buffer> <cr> :call nerdtree#invokeKeyMap('". g:NERDTreeMapActivateNode ."')<cr>"
                            
                                call g:NERDTreeKeyMap.BindAll()
                            
                                command! -buffer -nargs=? Bookmark :call nerdtree#bookmarkNode('<args>')
                                command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 RevealBookmark :call nerdtree#revealBookmark('<args>')
                                command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 OpenBookmark :call nerdtree#openBookmark('<args>')
                                command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=* ClearBookmarks call nerdtree#clearBookmarks('<args>')
                                command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=+ BookmarkToRoot call g:NERDTreeBookmark.ToRoot('<args>')
                                command! -buffer -nargs=0 ClearAllBookmarks call g:NERDTreeBookmark.ClearAll() <bar> call nerdtree#renderView()
                                command! -buffer -nargs=0 ReadBookmarks call g:NERDTreeBookmark.CacheBookmarks(0) <bar> call nerdtree#renderView()
                                command! -buffer -nargs=0 WriteBookmarks call g:NERDTreeBookmark.Write()
                            endfunction
                            
                            "FUNCTION: s:Creator._broadcastInitEvent() {{{1
    2              0.000004 function! s:Creator._broadcastInitEvent()
                                silent doautocmd User NERDTreeInit
                            endfunction
                            
                            " FUNCTION: s:Creator.BufNamePrefix() {{{2
    2              0.000003 function! s:Creator.BufNamePrefix()
                                return 'NERD_tree_'
                            endfunction
                            
                            "FUNCTION: s:Creator.CreatePrimary(a:name) {{{1
    2              0.000004 function! s:Creator.CreatePrimary(name)
                                let creator = s:Creator.New()
                                call creator.createPrimary(a:name)
                            endfunction
                            
                            "FUNCTION: s:Creator.createPrimary(a:name) {{{1
                            "name: the name of a bookmark or a directory
    2              0.000004 function! s:Creator.createPrimary(name)
                                let path = self._pathForString(a:name)
                            
                                "if instructed to, then change the vim CWD to the dir the NERDTree is
                                "inited in
                                if g:NERDTreeChDirMode != 0
                                    call path.changeToDir()
                                endif
                            
                                if nerdtree#treeExistsForTab()
                                    if nerdtree#isTreeOpen()
                                        call nerdtree#closeTree()
                                    endif
                                    unlet t:NERDTreeBufName
                                endif
                            
                                let newRoot = g:NERDTreeDirNode.New(path)
                                call newRoot.open()
                            
                                call self._createTreeWin()
                                let b:treeShowHelp = 0
                                let b:NERDTreeIgnoreEnabled = 1
                                let b:NERDTreeShowFiles = g:NERDTreeShowFiles
                                let b:NERDTreeShowHidden = g:NERDTreeShowHidden
                                let b:NERDTreeShowBookmarks = g:NERDTreeShowBookmarks
                                let b:NERDTreeRoot = newRoot
                                let b:NERDTreeType = "primary"
                            
                                call nerdtree#renderView()
                                call b:NERDTreeRoot.putCursorHere(0, 0)
                            
                                call self._broadcastInitEvent()
                            endfunction
                            
                            "FUNCTION: s:Creator.CreateSecondary(dir) {{{1
    2              0.000004 function! s:Creator.CreateSecondary(dir)
                                let creator = s:Creator.New()
                                call creator.createSecondary(a:dir)
                            endfunction
                            
                            "FUNCTION: s:Creator.createSecondary(dir) {{{1
    2              0.000004 function! s:Creator.createSecondary(dir)
                                try
                                    let path = g:NERDTreePath.New(a:dir)
                                catch /^NERDTree.InvalidArgumentsError/
                                    call nerdtree#echo("Invalid directory name:" . a:name)
                                    return
                                endtry
                            
                                "we want the directory buffer to disappear when we do the :edit below
                                setlocal bufhidden=wipe
                            
                                let previousBuf = expand("#")
                            
                                "we need a unique name for each secondary tree buffer to ensure they are
                                "all independent
                                exec "silent edit " . self._nextBufferName()
                            
                                let b:NERDTreePreviousBuf = bufnr(previousBuf)
                            
                                let b:NERDTreeRoot = g:NERDTreeDirNode.New(path)
                                call b:NERDTreeRoot.open()
                            
                                call self._setCommonBufOptions()
                                let b:NERDTreeType = "secondary"
                            
                                call nerdtree#renderView()
                            
                                call self._broadcastInitEvent()
                            endfunction
                            
                            " FUNCTION: s:Creator.CreateMirror() {{{1
    2              0.000004 function! s:Creator.CreateMirror()
                                let creator = s:Creator.New()
                                call creator.createMirror()
                            endfunction
                            
                            " FUNCTION: s:Creator.createMirror() {{{1
    2              0.000004 function! s:Creator.createMirror()
                                "get the names off all the nerd tree buffers
                                let treeBufNames = []
                                for i in range(1, tabpagenr("$"))
                                    let nextName = nerdtree#tabpagevar(i, 'NERDTreeBufName')
                                    if nextName != -1 && (!exists("t:NERDTreeBufName") || nextName != t:NERDTreeBufName)
                                        call add(treeBufNames, nextName)
                                    endif
                                endfor
                                let treeBufNames = nerdtree#unique(treeBufNames)
                            
                                "map the option names (that the user will be prompted with) to the nerd
                                "tree buffer names
                                let options = {}
                                let i = 0
                                while i < len(treeBufNames)
                                    let bufName = treeBufNames[i]
                                    let treeRoot = getbufvar(bufName, "NERDTreeRoot")
                                    let options[i+1 . '. ' . treeRoot.path.str() . '  (buf name: ' . bufName . ')'] = bufName
                                    let i = i + 1
                                endwhile
                            
                                "work out which tree to mirror, if there is more than 1 then ask the user
                                let bufferName = ''
                                if len(keys(options)) > 1
                                    let choices = ["Choose a tree to mirror"]
                                    let choices = extend(choices, sort(keys(options)))
                                    let choice = inputlist(choices)
                                    if choice < 1 || choice > len(options) || choice ==# ''
                                        return
                                    endif
                            
                                    let bufferName = options[sort(keys(options))[choice-1]]
                                elseif len(keys(options)) ==# 1
                                    let bufferName = values(options)[0]
                                else
                                    call nerdtree#echo("No trees to mirror")
                                    return
                                endif
                            
                                if nerdtree#treeExistsForTab() && nerdtree#isTreeOpen()
                                    call nerdtree#closeTree()
                                endif
                            
                                let t:NERDTreeBufName = bufferName
                                call self._createTreeWin()
                                exec 'buffer ' .  bufferName
                                if !&hidden
                                    call nerdtree#renderView()
                                endif
                            endfunction
                            
                            "FUNCTION: s:Creator._createTreeWin() {{{1
                            "Inits the NERD tree window. ie. opens it, sizes it, sets all the local
                            "options etc
    2              0.000004 function! s:Creator._createTreeWin()
                                "create the nerd tree window
                                let splitLocation = g:NERDTreeWinPos ==# "left" ? "topleft " : "botright "
                                let splitSize = g:NERDTreeWinSize
                            
                                if !exists('t:NERDTreeBufName')
                                    let t:NERDTreeBufName = self._nextBufferName()
                                    silent! exec splitLocation . 'vertical ' . splitSize . ' new'
                                    silent! exec "edit " . t:NERDTreeBufName
                                else
                                    silent! exec splitLocation . 'vertical ' . splitSize . ' split'
                                    silent! exec "buffer " . t:NERDTreeBufName
                                endif
                            
                                setlocal winfixwidth
                                call self._setCommonBufOptions()
                            endfunction
                            
                            "FUNCTION: s:Creator.New() {{{1
    2              0.000004 function! s:Creator.New()
                                let newCreator = copy(self)
                                return newCreator
                            endfunction
                            
                            " FUNCTION: s:Creator._nextBufferName() {{{2
                            " returns the buffer name for the next nerd tree
    2              0.000005 function! s:Creator._nextBufferName()
                                let name = s:Creator.BufNamePrefix() . self._nextBufferNumber()
                                return name
                            endfunction
                            
                            " FUNCTION: s:Creator._nextBufferNumber() {{{2
                            " the number to add to the nerd tree buffer name to make the buf name unique
    2              0.000003 function! s:Creator._nextBufferNumber()
                                if !exists("s:Creator._NextBufNum")
                                    let s:Creator._NextBufNum = 1
                                else
                                    let s:Creator._NextBufNum += 1
                                endif
                            
                                return s:Creator._NextBufNum
                            endfunction
                            
                            "FUNCTION: s:Creator._pathForString(str) {{{1
                            "find a bookmark or adirectory for the given string
    2              0.000004 function! s:Creator._pathForString(str)
                                let path = {}
                                if g:NERDTreeBookmark.BookmarkExistsFor(a:str)
                                    let path = g:NERDTreeBookmark.BookmarkFor(a:str).path
                                else
                                    let dir = a:str ==# '' ? getcwd() : a:str
                            
                                    "hack to get an absolute path if a relative path is given
                                    if dir =~# '^\.'
                                        let dir = getcwd() . g:NERDTreePath.Slash() . dir
                                    endif
                                    let dir = g:NERDTreePath.Resolve(dir)
                            
                                    try
                                        let path = g:NERDTreePath.New(dir)
                                    catch /^NERDTree.InvalidArgumentsError/
                                        call nerdtree#echo("No bookmark or directory found for: " . a:str)
                                        return
                                    endtry
                                endif
                                if !path.isDirectory
                                    let path = path.getParent()
                                endif
                            
                                return path
                            endfunction
                            
                            "FUNCTION: s:Creator._setCommonBufOptions() {{{1
    2              0.000004 function! s:Creator._setCommonBufOptions()
                                "throwaway buffer options
                                setlocal noswapfile
                                setlocal buftype=nofile
                                setlocal bufhidden=hide
                                setlocal nowrap
                                setlocal foldcolumn=0
                                setlocal foldmethod=manual
                                setlocal nofoldenable
                                setlocal nobuflisted
                                setlocal nospell
                                if g:NERDTreeShowLineNumbers
                                    setlocal nu
                                else
                                    setlocal nonu
                                    if v:version >= 703
                                        setlocal nornu
                                    endif
                                endif
                            
                                iabc <buffer>
                            
                                if g:NERDTreeHighlightCursorline
                                    setlocal cursorline
                                endif
                            
                                call self._setupStatusline()
                            
                                let b:treeShowHelp = 0
                                let b:NERDTreeIgnoreEnabled = 1
                                let b:NERDTreeShowFiles = g:NERDTreeShowFiles
                                let b:NERDTreeShowHidden = g:NERDTreeShowHidden
                                let b:NERDTreeShowBookmarks = g:NERDTreeShowBookmarks
                                setfiletype nerdtree
                                call self._bindMappings()
                            endfunction
                            
                            "FUNCTION: s:Creator._setupStatusline() {{{1
    2              0.000003 function! s:Creator._setupStatusline()
                                if g:NERDTreeStatusline != -1
                                    let &l:statusline = g:NERDTreeStatusline
                                endif
                            endfunction
                            
                            "FUNCTION: s:Creator.TogglePrimary(dir) {{{1
    2              0.000004 function! s:Creator.TogglePrimary(dir)
                                let creator = s:Creator.New()
                                call creator.togglePrimary(a:dir)
                            endfunction
                            
                            "FUNCTION: s:Creator.togglePrimary(dir) {{{1
                            "Toggles the NERD tree. I.e the NERD tree is open, it is closed, if it is
                            "closed it is restored or initialized (if it doesnt exist)
                            "
                            "Args:
                            "dir: the full path for the root node (is only used if the NERD tree is being
                            "initialized.
    2              0.000005 function! s:Creator.togglePrimary(dir)
                                if nerdtree#treeExistsForTab()
                                    if !nerdtree#isTreeOpen()
                                        call self._createTreeWin()
                                        if !&hidden
                                            call nerdtree#renderView()
                                        endif
                                        call nerdtree#restoreScreenState()
                                    else
                                        call nerdtree#closeTree()
                                    endif
                                else
                                    call self.createPrimary(a:dir)
                                endif
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim
Sourced 1 time
Total time:   0.000136
 Self time:   0.000059

count  total (s)   self (s)
                            " ============================================================================
                            " File:        exec_menuitem.vim
                            " Description: plugin for NERD Tree that provides an execute file menu item
                            " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
                            " Last Change: 22 July, 2009
                            " License:     This program is free software. It comes without any warranty,
                            "              to the extent permitted by applicable law. You can redistribute
                            "              it and/or modify it under the terms of the Do What The Fuck You
                            "              Want To Public License, Version 2, as published by Sam Hocevar.
                            "              See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            " ============================================================================
    1              0.000006 if exists("g:loaded_nerdtree_exec_menuitem")
                                finish
                            endif
    1              0.000005 let g:loaded_nerdtree_exec_menuitem = 1
                            
    1   0.000092   0.000015 call NERDTreeAddMenuItem({
                                        \ 'text': '(!)Execute file',
                                        \ 'shortcut': '!',
                                        \ 'callback': 'NERDTreeExecFile',
                                        \ 'isActiveCallback': 'NERDTreeExecFileActive' })
                            
    1              0.000003 function! NERDTreeExecFileActive()
                                let node = g:NERDTreeFileNode.GetSelected()
                                return !node.path.isDirectory && node.path.isExecutable
                            endfunction
                            
    1              0.000002 function! NERDTreeExecFile()
                                let treenode = g:NERDTreeFileNode.GetSelected()
                                echo "==========================================================\n"
                                echo "Complete the command to execute (add arguments etc):\n"
                                let cmd = treenode.path.str({'escape': 1})
                                let cmd = input(':!', cmd . ' ')
                            
                                if cmd != ''
                                    exec ':!' . cmd
                                else
                                    echo "Aborted"
                                endif
                            endfunction

SCRIPT  /home/joshb/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim
Sourced 1 time
Total time:   0.000574
 Self time:   0.000307

count  total (s)   self (s)
                            " ============================================================================
                            " File:        fs_menu.vim
                            " Description: plugin for the NERD Tree that provides a file system menu
                            " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
                            " Last Change: 17 July, 2009
                            " License:     This program is free software. It comes without any warranty,
                            "              to the extent permitted by applicable law. You can redistribute
                            "              it and/or modify it under the terms of the Do What The Fuck You
                            "              Want To Public License, Version 2, as published by Sam Hocevar.
                            "              See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            " ============================================================================
    1              0.000005 if exists("g:loaded_nerdtree_fs_menu")
                                finish
                            endif
    1              0.000003 let g:loaded_nerdtree_fs_menu = 1
                            
                            "Automatically delete the buffer after deleting or renaming a file
    1              0.000004 if !exists("g:NERDTreeAutoDeleteBuffer")
    1              0.000003     let g:NERDTreeAutoDeleteBuffer = 0
    1              0.000001 endif
                            
    1   0.000076   0.000008 call NERDTreeAddMenuItem({'text': '(a)dd a childnode', 'shortcut': 'a', 'callback': 'NERDTreeAddNode'})
    1   0.000073   0.000009 call NERDTreeAddMenuItem({'text': '(m)ove the current node', 'shortcut': 'm', 'callback': 'NERDTreeMoveNode'})
    1   0.000071   0.000008 call NERDTreeAddMenuItem({'text': '(d)elete the current node', 'shortcut': 'd', 'callback': 'NERDTreeDeleteNode'})
                            
    1              0.000011 if has("gui_mac") || has("gui_macvim") 
                                call NERDTreeAddMenuItem({'text': '(r)eveal in Finder the current node', 'shortcut': 'r', 'callback': 'NERDTreeRevealInFinder'})
                                call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFile'})
                                call NERDTreeAddMenuItem({'text': '(q)uicklook the current node', 'shortcut': 'q', 'callback': 'NERDTreeQuickLook'})
                            endif
                            
    1   0.000011   0.000006 if g:NERDTreePath.CopyingSupported()
    1   0.000074   0.000007     call NERDTreeAddMenuItem({'text': '(c)opy the current node', 'shortcut': 'c', 'callback': 'NERDTreeCopyNode'})
    1              0.000002 endif
                            
                            "FUNCTION: s:echo(msg){{{1
    1              0.000003 function! s:echo(msg)
                                redraw
                                echomsg "NERDTree: " . a:msg
                            endfunction
                            
                            "FUNCTION: s:echoWarning(msg){{{1
    1              0.000002 function! s:echoWarning(msg)
                                echohl warningmsg
                                call s:echo(a:msg)
                                echohl normal
                            endfunction
                            
                            "FUNCTION: s:promptToDelBuffer(bufnum, msg){{{1
                            "prints out the given msg and, if the user responds by pushing 'y' then the
                            "buffer with the given bufnum is deleted
                            "
                            "Args:
                            "bufnum: the buffer that may be deleted
                            "msg: a message that will be echoed to the user asking them if they wish to
                            "     del the buffer
    1              0.000003 function! s:promptToDelBuffer(bufnum, msg)
                                echo a:msg
                                if g:NERDTreeAutoDeleteBuffer || nr2char(getchar()) ==# 'y'
                                    " 1. ensure that all windows which display the just deleted filename
                                    " now display an empty buffer (so a layout is preserved).
                                    " Is not it better to close single tabs with this file only ?
                                    let s:originalTabNumber = tabpagenr()
                                    let s:originalWindowNumber = winnr()
                                    exec "tabdo windo if winbufnr(0) == " . a:bufnum . " | exec ':enew! ' | endif"
                                    exec "tabnext " . s:originalTabNumber
                                    exec s:originalWindowNumber . "wincmd w"
                                    " 3. We don't need a previous buffer anymore
                                    exec "bwipeout! " . a:bufnum
                                endif
                            endfunction
                            
                            "FUNCTION: s:promptToRenameBuffer(bufnum, msg){{{1
                            "prints out the given msg and, if the user responds by pushing 'y' then the
                            "buffer with the given bufnum is replaced with a new one
                            "
                            "Args:
                            "bufnum: the buffer that may be deleted
                            "msg: a message that will be echoed to the user asking them if they wish to
                            "     del the buffer
    1              0.000003 function! s:promptToRenameBuffer(bufnum, msg, newFileName)
                                echo a:msg
                                if g:NERDTreeAutoDeleteBuffer || nr2char(getchar()) ==# 'y'
                                    " 1. ensure that a new buffer is loaded
                                    exec "badd " . a:newFileName
                                    " 2. ensure that all windows which display the just deleted filename
                                    " display a buffer for a new filename. 
                                    let s:originalTabNumber = tabpagenr()
                                    let s:originalWindowNumber = winnr()
                                    exec "tabdo windo if winbufnr(0) == " . a:bufnum . " | exec ':e! " . a:newFileName . "' | endif"
                                    exec "tabnext " . s:originalTabNumber
                                    exec s:originalWindowNumber . "wincmd w"
                                    " 3. We don't need a previous buffer anymore
                                    exec "bwipeout! " . a:bufnum
                                endif
                            endfunction
                            "FUNCTION: NERDTreeAddNode(){{{1
    1              0.000002 function! NERDTreeAddNode()
                                let curDirNode = g:NERDTreeDirNode.GetSelected()
                            
                                let newNodeName = input("Add a childnode\n".
                                                      \ "==========================================================\n".
                                                      \ "Enter the dir/file name to be created. Dirs end with a '/'\n" .
                                                      \ "", curDirNode.path.str() . g:NERDTreePath.Slash(), "file")
                            
                                if newNodeName ==# ''
                                    call s:echo("Node Creation Aborted.")
                                    return
                                endif
                            
                                try
                                    let newPath = g:NERDTreePath.Create(newNodeName)
                                    let parentNode = b:NERDTreeRoot.findNode(newPath.getParent())
                            
                                    let newTreeNode = g:NERDTreeFileNode.New(newPath)
                                    if parentNode.isOpen || !empty(parentNode.children)
                                        call parentNode.addChild(newTreeNode, 1)
                                        call NERDTreeRender()
                                        call newTreeNode.putCursorHere(1, 0)
                                    endif
                                catch /^NERDTree/
                                    call s:echoWarning("Node Not Created.")
                                endtry
                            endfunction
                            
                            "FUNCTION: NERDTreeMoveNode(){{{1
    1              0.000002 function! NERDTreeMoveNode()
                                let curNode = g:NERDTreeFileNode.GetSelected()
                                let newNodePath = input("Rename the current node\n" .
                                                      \ "==========================================================\n" .
                                                      \ "Enter the new path for the node:                          \n" .
                                                      \ "", curNode.path.str(), "file")
                            
                                if newNodePath ==# ''
                                    call s:echo("Node Renaming Aborted.")
                                    return
                                endif
                            
                                try
                                    let bufnum = bufnr(curNode.path.str())
                            
                                    call curNode.rename(newNodePath)
                                    call NERDTreeRender()
                            
                                    "if the node is open in a buffer, ask the user if they want to
                                    "close that buffer
                                    if bufnum != -1
                                        let prompt = "\nNode renamed.\n\nThe old file is open in buffer ". bufnum . (bufwinnr(bufnum) ==# -1 ? " (hidden)" : "") .". Replace this buffer with a new file? (yN)"
                                        call s:promptToRenameBuffer(bufnum,  prompt, newNodePath)
                                    endif
                            
                                    call curNode.putCursorHere(1, 0)
                            
                                    redraw
                                catch /^NERDTree/
                                    call s:echoWarning("Node Not Renamed.")
                                endtry
                            endfunction
                            
                            " FUNCTION: NERDTreeDeleteNode() {{{1
    1              0.000002 function! NERDTreeDeleteNode()
                                let currentNode = g:NERDTreeFileNode.GetSelected()
                                let confirmed = 0
                            
                                if currentNode.path.isDirectory
                                    let choice =input("Delete the current node\n" .
                                                     \ "==========================================================\n" .
                                                     \ "STOP! To delete this entire directory, type 'yes'\n" .
                                                     \ "" . currentNode.path.str() . ": ")
                                    let confirmed = choice ==# 'yes'
                                else
                                    echo "Delete the current node\n" .
                                       \ "==========================================================\n".
                                       \ "Are you sure you wish to delete the node:\n" .
                                       \ "" . currentNode.path.str() . " (yN):"
                                    let choice = nr2char(getchar())
                                    let confirmed = choice ==# 'y'
                                endif
                            
                            
                                if confirmed
                                    try
                                        call currentNode.delete()
                                        call NERDTreeRender()
                            
                                        "if the node is open in a buffer, ask the user if they want to
                                        "close that buffer
                                        let bufnum = bufnr(currentNode.path.str())
                                        if buflisted(bufnum)
                                            let prompt = "\nNode deleted.\n\nThe file is open in buffer ". bufnum . (bufwinnr(bufnum) ==# -1 ? " (hidden)" : "") .". Delete this buffer? (yN)"
                                            call s:promptToDelBuffer(bufnum, prompt)
                                        endif
                            
                                        redraw
                                    catch /^NERDTree/
                                        call s:echoWarning("Could not remove node")
                                    endtry
                                else
                                    call s:echo("delete aborted")
                                endif
                            
                            endfunction
                            
                            " FUNCTION: NERDTreeCopyNode() {{{1
    1              0.000002 function! NERDTreeCopyNode()
                                let currentNode = g:NERDTreeFileNode.GetSelected()
                                let newNodePath = input("Copy the current node\n" .
                                                      \ "==========================================================\n" .
                                                      \ "Enter the new path to copy the node to:                   \n" .
                                                      \ "", currentNode.path.str(), "file")
                            
                                if newNodePath != ""
                                    "strip trailing slash
                                    let newNodePath = substitute(newNodePath, '\/$', '', '')
                            
                                    let confirmed = 1
                                    if currentNode.path.copyingWillOverwrite(newNodePath)
                                        call s:echo("Warning: copying may overwrite files! Continue? (yN)")
                                        let choice = nr2char(getchar())
                                        let confirmed = choice ==# 'y'
                                    endif
                            
                                    if confirmed
                                        try
                                            let newNode = currentNode.copy(newNodePath)
                                            if !empty(newNode)
                                                call NERDTreeRender()
                                                call newNode.putCursorHere(0, 0)
                                            endif
                                        catch /^NERDTree/
                                            call s:echoWarning("Could not copy node")
                                        endtry
                                    endif
                                else
                                    call s:echo("Copy aborted.")
                                endif
                                redraw
                            endfunction
                            
    1              0.000002 function! NERDTreeQuickLook()
                                let treenode = g:NERDTreeFileNode.GetSelected()
                                if treenode != {}
                                    call system("qlmanage -p 2>/dev/null '" . treenode.path.str() . "'")
                                endif
                            endfunction
                            
    1              0.000002 function! NERDTreeRevealInFinder()
                                let treenode = g:NERDTreeFileNode.GetSelected()
                                if treenode != {}
                                    let x = system("open -R '" . treenode.path.str() . "'")
                                endif
                            endfunction
                            
    1              0.000002 function! NERDTreeExecuteFile()
                                let treenode = g:NERDTreeFileNode.GetSelected()
                                if treenode != {}
                                    let x = system("open '" . treenode.path.str() . "'")
                                endif
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/joshb/.vim/bundle/taglist.vim/plugin/taglist.vim
Sourced 1 time
Total time:   0.000773
 Self time:   0.000773

count  total (s)   self (s)
                            " File: taglist.vim
                            " Author: Yegappan Lakshmanan (yegappan AT yahoo DOT com)
                            " Version: 4.5
                            " Last Modified: September 21, 2007
                            " Copyright: Copyright (C) 2002-2007 Yegappan Lakshmanan
                            "            Permission is hereby granted to use and distribute this code,
                            "            with or without modifications, provided that this copyright
                            "            notice is copied with it. Like anything else that's free,
                            "            taglist.vim is provided *as is* and comes with no warranty of any
                            "            kind, either expressed or implied. In no event will the copyright
                            "            holder be liable for any damamges resulting from the use of this
                            "            software.
                            "
                            " The "Tag List" plugin is a source code browser plugin for Vim and provides
                            " an overview of the structure of the programming language files and allows
                            " you to efficiently browse through source code files for different
                            " programming languages.  You can visit the taglist plugin home page for more
                            " information:
                            "
                            "       http://vim-taglist.sourceforge.net
                            "
                            " You can subscribe to the taglist mailing list to post your questions
                            " or suggestions for improvement or to report bugs. Visit the following
                            " page for subscribing to the mailing list:
                            "
                            "       http://groups.yahoo.com/group/taglist/
                            "
                            " For more information about using this plugin, after installing the
                            " taglist plugin, use the ":help taglist" command.
                            "
                            " Installation
                            " ------------
                            " 1. Download the taglist.zip file and unzip the files to the $HOME/.vim
                            "    or the $HOME/vimfiles or the $VIM/vimfiles directory. This should
                            "    unzip the following two files (the directory structure should be
                            "    preserved):
                            "
                            "       plugin/taglist.vim - main taglist plugin file
                            "       doc/taglist.txt    - documentation (help) file
                            "
                            "    Refer to the 'add-plugin', 'add-global-plugin' and 'runtimepath'
                            "    Vim help pages for more details about installing Vim plugins.
                            " 2. Change to the $HOME/.vim/doc or $HOME/vimfiles/doc or
                            "    $VIM/vimfiles/doc directory, start Vim and run the ":helptags ."
                            "    command to process the taglist help file.
                            " 3. If the exuberant ctags utility is not present in your PATH, then set the
                            "    Tlist_Ctags_Cmd variable to point to the location of the exuberant ctags
                            "    utility (not to the directory) in the .vimrc file.
                            " 4. If you are running a terminal/console version of Vim and the
                            "    terminal doesn't support changing the window width then set the
                            "    'Tlist_Inc_Winwidth' variable to 0 in the .vimrc file.
                            " 5. Restart Vim.
                            " 6. You can now use the ":TlistToggle" command to open/close the taglist
                            "    window. You can use the ":help taglist" command to get more
                            "    information about using the taglist plugin.
                            "
                            " ****************** Do not modify after this line ************************
                            
                            " Line continuation used here
    1              0.000012 let s:cpo_save = &cpo
    1              0.000012 set cpo&vim
                            
    1              0.000005 if !exists('loaded_taglist')
                                " First time loading the taglist plugin
                                "
                                " To speed up the loading of Vim, the taglist plugin uses autoload
                                " mechanism to load the taglist functions.
                                " Only define the configuration variables, user commands and some
                                " auto-commands and finish sourcing the file
                            
                                " The taglist plugin requires the built-in Vim system() function. If this
                                " function is not available, then don't load the plugin.
    1              0.000004     if !exists('*system')
                                    echomsg 'Taglist: Vim system() built-in function is not available. ' .
                                                \ 'Plugin is not loaded.'
                                    let loaded_taglist = 'no'
                                    let &cpo = s:cpo_save
                                    finish
                                endif
                            
                                " Location of the exuberant ctags tool
    1              0.000003     if !exists('Tlist_Ctags_Cmd')
    1              0.000018         if executable('exuberant-ctags')
                                        " On Debian Linux, exuberant ctags is installed
                                        " as exuberant-ctags
                                        let Tlist_Ctags_Cmd = 'exuberant-ctags'
                                    elseif executable('exctags')
                                        " On Free-BSD, exuberant ctags is installed as exctags
                                        let Tlist_Ctags_Cmd = 'exctags'
                                    elseif executable('ctags')
    1              0.000004             let Tlist_Ctags_Cmd = 'ctags'
    1              0.000005         elseif executable('ctags.exe')
                                        let Tlist_Ctags_Cmd = 'ctags.exe'
                                    elseif executable('tags')
                                        let Tlist_Ctags_Cmd = 'tags'
                                    else
                                        echomsg 'Taglist: Exuberant ctags (http://ctags.sf.net) ' .
                                                    \ 'not found in PATH. Plugin is not loaded.'
                                        " Skip loading the plugin
                                        let loaded_taglist = 'no'
                                        let &cpo = s:cpo_save
                                        finish
                                    endif
    1              0.000001     endif
                            
                            
                                " Automatically open the taglist window on Vim startup
    1              0.000004     if !exists('Tlist_Auto_Open')
    1              0.000003         let Tlist_Auto_Open = 0
    1              0.000001     endif
                            
                                " When the taglist window is toggle opened, move the cursor to the
                                " taglist window
    1              0.000004     if !exists('Tlist_GainFocus_On_ToggleOpen')
                                    let Tlist_GainFocus_On_ToggleOpen = 0
                                endif
                            
                                " Process files even when the taglist window is not open
    1              0.000003     if !exists('Tlist_Process_File_Always')
    1              0.000004         let Tlist_Process_File_Always = 0
    1              0.000001     endif
                            
    1              0.000003     if !exists('Tlist_Show_Menu')
    1              0.000003         let Tlist_Show_Menu = 0
    1              0.000001     endif
                            
                                " Tag listing sort type - 'name' or 'order'
    1              0.000003     if !exists('Tlist_Sort_Type')
    1              0.000003         let Tlist_Sort_Type = 'order'
    1              0.000001     endif
                            
                                " Tag listing window split (horizontal/vertical) control
    1              0.000003     if !exists('Tlist_Use_Horiz_Window')
                                    let Tlist_Use_Horiz_Window = 0
                                endif
                            
                                " Open the vertically split taglist window on the left or on the right
                                " side.  This setting is relevant only if Tlist_Use_Horiz_Window is set to
                                " zero (i.e.  only for vertically split windows)
    1              0.000003     if !exists('Tlist_Use_Right_Window')
                                    let Tlist_Use_Right_Window = 0
                                endif
                            
                                " Increase Vim window width to display vertically split taglist window.
                                " For MS-Windows version of Vim running in a MS-DOS window, this must be
                                " set to 0 otherwise the system may hang due to a Vim limitation.
    1              0.000003     if !exists('Tlist_Inc_Winwidth')
    1              0.000010         if (has('win16') || has('win95')) && !has('gui_running')
                                        let Tlist_Inc_Winwidth = 0
                                    else
    1              0.000002             let Tlist_Inc_Winwidth = 1
    1              0.000001         endif
    1              0.000001     endif
                            
                                " Vertically split taglist window width setting
    1              0.000004     if !exists('Tlist_WinWidth')
                                    let Tlist_WinWidth = 30
                                endif
                            
                                " Horizontally split taglist window height setting
    1              0.000003     if !exists('Tlist_WinHeight')
    1              0.000003         let Tlist_WinHeight = 10
    1              0.000001     endif
                            
                                " Display tag prototypes or tag names in the taglist window
    1              0.000003     if !exists('Tlist_Display_Prototype')
    1              0.000003         let Tlist_Display_Prototype = 0
    1              0.000001     endif
                            
                                " Display tag scopes in the taglist window
    1              0.000003     if !exists('Tlist_Display_Tag_Scope')
    1              0.000003         let Tlist_Display_Tag_Scope = 1
    1              0.000001     endif
                            
                                " Use single left mouse click to jump to a tag. By default this is disabled.
                                " Only double click using the mouse will be processed.
    1              0.000003     if !exists('Tlist_Use_SingleClick')
    1              0.000003         let Tlist_Use_SingleClick = 0
    1              0.000001     endif
                            
                                " Control whether additional help is displayed as part of the taglist or
                                " not.  Also, controls whether empty lines are used to separate the tag
                                " tree.
    1              0.000003     if !exists('Tlist_Compact_Format')
                                    let Tlist_Compact_Format = 0
                                endif
                            
                                " Exit Vim if only the taglist window is currently open. By default, this is
                                " set to zero.
    1              0.000003     if !exists('Tlist_Exit_OnlyWindow')
                                    let Tlist_Exit_OnlyWindow = 0
                                endif
                            
                                " Automatically close the folds for the non-active files in the taglist
                                " window
    1              0.000003     if !exists('Tlist_File_Fold_Auto_Close')
                                    let Tlist_File_Fold_Auto_Close = 0
                                endif
                            
                                " Close the taglist window when a tag is selected
    1              0.000004     if !exists('Tlist_Close_On_Select')
    1              0.000003         let Tlist_Close_On_Select = 0
    1              0.000001     endif
                            
                                " Automatically update the taglist window to display tags for newly
                                " edited files
    1              0.000003     if !exists('Tlist_Auto_Update')
    1              0.000003         let Tlist_Auto_Update = 1
    1              0.000001     endif
                            
                                " Automatically highlight the current tag
    1              0.000003     if !exists('Tlist_Auto_Highlight_Tag')
    1              0.000003         let Tlist_Auto_Highlight_Tag = 1
    1              0.000001     endif
                                
                                " Automatically highlight the current tag on entering a buffer
    1              0.000003     if !exists('Tlist_Highlight_Tag_On_BufEnter')
    1              0.000004         let Tlist_Highlight_Tag_On_BufEnter = 1
    1              0.000001     endif
                            
                                " Enable fold column to display the folding for the tag tree
    1              0.000004     if !exists('Tlist_Enable_Fold_Column')
    1              0.000003         let Tlist_Enable_Fold_Column = 1
    1              0.000001     endif
                            
                                " Display the tags for only one file in the taglist window
    1              0.000003     if !exists('Tlist_Show_One_File')
    1              0.000003         let Tlist_Show_One_File = 0
    1              0.000001     endif
                            
    1              0.000004     if !exists('Tlist_Max_Submenu_Items')
    1              0.000002         let Tlist_Max_Submenu_Items = 20
    1              0.000002     endif
                            
    1              0.000003     if !exists('Tlist_Max_Tag_Length')
    1              0.000003         let Tlist_Max_Tag_Length = 10
    1              0.000001     endif
                            
                                " Do not change the name of the taglist title variable. The winmanager
                                " plugin relies on this name to determine the title for the taglist
                                " plugin.
    1              0.000003     let TagList_title = "__Tag_List__"
                            
                                " Taglist debug messages
    1              0.000002     let s:tlist_msg = ''
                            
                                " Define the taglist autocommand to automatically open the taglist window
                                " on Vim startup
    1              0.000002     if g:Tlist_Auto_Open
                                    autocmd VimEnter * nested call s:Tlist_Window_Check_Auto_Open()
                                endif
                            
                                " Refresh the taglist
    1              0.000002     if g:Tlist_Process_File_Always
                                    autocmd BufEnter * call s:Tlist_Refresh()
                                endif
                            
    1              0.000002     if g:Tlist_Show_Menu
                                    autocmd GUIEnter * call s:Tlist_Menu_Init()
                                endif
                            
                                " When the taglist buffer is created when loading a Vim session file,
                                " the taglist buffer needs to be initialized. The BufFilePost event
                                " is used to handle this case.
    1              0.000008     autocmd BufFilePost __Tag_List__ call s:Tlist_Vim_Session_Load()
                            
                                " Define the user commands to manage the taglist window
    1              0.000016     command! -nargs=0 -bar TlistToggle call s:Tlist_Window_Toggle()
    1              0.000009     command! -nargs=0 -bar TlistOpen call s:Tlist_Window_Open()
                                " For backwards compatiblity define the Tlist command
    1              0.000006     command! -nargs=0 -bar Tlist TlistToggle
    1              0.000011     command! -nargs=+ -complete=file TlistAddFiles
                                            \  call s:Tlist_Add_Files(<f-args>)
    1              0.000013     command! -nargs=+ -complete=dir TlistAddFilesRecursive
                                            \ call s:Tlist_Add_Files_Recursive(<f-args>)
    1              0.000008     command! -nargs=0 -bar TlistClose call s:Tlist_Window_Close()
    1              0.000009     command! -nargs=0 -bar TlistUpdate call s:Tlist_Update_Current_File()
    1              0.000017     command! -nargs=0 -bar TlistHighlightTag call s:Tlist_Window_Highlight_Tag(
                                                    \ fnamemodify(bufname('%'), ':p'), line('.'), 2, 1)
                                " For backwards compatiblity define the TlistSync command
    1              0.000006     command! -nargs=0 -bar TlistSync TlistHighlightTag
    1              0.000013     command! -nargs=* -complete=buffer TlistShowPrototype
                                            \ echo Tlist_Get_Tag_Prototype_By_Line(<f-args>)
    1              0.000011     command! -nargs=* -complete=buffer TlistShowTag
                                            \ echo Tlist_Get_Tagname_By_Line(<f-args>)
    1              0.000011     command! -nargs=* -complete=file TlistSessionLoad
                                            \ call s:Tlist_Session_Load(<q-args>)
    1              0.000010     command! -nargs=* -complete=file TlistSessionSave
                                            \ call s:Tlist_Session_Save(<q-args>)
    1              0.000007     command! -bar TlistLock let Tlist_Auto_Update=0
    1              0.000008     command! -bar TlistUnlock let Tlist_Auto_Update=1
                            
                                " Commands for enabling/disabling debug and to display debug messages
    1              0.000011     command! -nargs=? -complete=file -bar TlistDebug
                                            \ call s:Tlist_Debug_Enable(<q-args>)
    1              0.000008     command! -nargs=0 -bar TlistUndebug  call s:Tlist_Debug_Disable()
    1              0.000008     command! -nargs=0 -bar TlistMessages call s:Tlist_Debug_Show()
                            
                                " Define autocommands to autoload the taglist plugin when needed.
                            
                                " Trick to get the current script ID
    1              0.000011     map <SID>xx <SID>xx
    1              0.000026     let s:tlist_sid = substitute(maparg('<SID>xx'), '<SNR>\(\d\+_\)xx$',
                                                            \ '\1', '')
    1              0.000008     unmap <SID>xx
                            
    1              0.000021     exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_* source ' .
                                            \ escape(expand('<sfile>'), ' ')
    1              0.000017     exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_Window_* source ' .
                                            \ escape(expand('<sfile>'), ' ')
    1              0.000017     exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_Menu_* source ' .
                                            \ escape(expand('<sfile>'), ' ')
    1              0.000015     exe 'autocmd FuncUndefined Tlist_* source ' .
                                            \ escape(expand('<sfile>'), ' ')
    1              0.000015     exe 'autocmd FuncUndefined TagList_* source ' .
                                            \ escape(expand('<sfile>'), ' ')
                            
    1              0.000004     let loaded_taglist = 'fast_load_done'
                            
    1              0.000006     if g:Tlist_Show_Menu && has('gui_running')
                                    call s:Tlist_Menu_Init()
                                endif
                            
                                " restore 'cpo'
    1              0.000010     let &cpo = s:cpo_save
    1              0.000001     finish

SCRIPT  /home/joshb/.vim/bundle/tcomment_vim/plugin/tcomment.vim
Sourced 1 time
Total time:   0.001527
 Self time:   0.001527

count  total (s)   self (s)
                            " tComment.vim -- An easily extensible & universal comment plugin 
                            " @Author:      Tom Link (micathom AT gmail com)
                            " @License:     GPL (see http://www.gnu.org/licenses/gpl.txt)
                            " @Created:     27-Dez-2004.
                            " @Last Change: 2012-11-26.
                            " @Revision:    771
                            " GetLatestVimScripts: 1173 1 tcomment.vim
                            
    1              0.000011 if &cp || exists('loaded_tcomment')
                                finish
                            endif
    1              0.000003 let loaded_tcomment = 208
                            
    1              0.000004 if !exists('g:tcommentMaps')
                                " If true, set maps.
    1              0.000003     let g:tcommentMaps = 1   "{{{2
    1              0.000001 endif
                            
    1              0.000003 if !exists("g:tcommentMapLeader1")
                                " g:tcommentMapLeader1 should be a shortcut that can be used with 
                                " map, imap, vmap.
    1              0.000003     let g:tcommentMapLeader1 = '<c-_>' "{{{2
    1              0.000001 endif
                            
    1              0.000003 if !exists("g:tcommentMapLeader2")
                                " g:tcommentMapLeader2 should be a shortcut that can be used with 
                                " map, xmap.
    1              0.000003     let g:tcommentMapLeader2 = '<Leader>_' "{{{2
    1              0.000001 endif
                            
    1              0.000003 if !exists("g:tcommentMapLeaderOp1")
                                " See |tcomment-operator|.
    1              0.000003     let g:tcommentMapLeaderOp1 = 'gc' "{{{2
    1              0.000001 endif
                            
    1              0.000003 if !exists("g:tcommentMapLeaderOp2")
                                " See |tcomment-operator|.
    1              0.000003     let g:tcommentMapLeaderOp2 = 'gC' "{{{2
    1              0.000001 endif
                            
                            
                            " :display: :[range]TComment[!] ?ARGS...
                            " If there is a visual selection that begins and ends in the same line, 
                            " then |:TCommentInline| is used instead.
                            " The optional range defaults to the current line. With a bang '!', 
                            " always comment the line.
                            "
                            " ARGS... are either (see also |tcomment#Comment()|):
                            "   1. a list of key=value pairs
                            "   2. 1-2 values for: ?commentBegin, ?commentEnd
    1              0.000034 command! -bang -range -nargs=* -complete=customlist,tcomment#CompleteArgs TComment
                                        \ keepjumps call tcomment#Comment(<line1>, <line2>, 'G', "<bang>", <f-args>)
                            
                            " :display: :[range]TCommentAs[!] commenttype ?ARGS...
                            " TCommentAs requires g:tcomment_{filetype} to be defined.
                            " With a bang '!', always comment the line.
                            "
                            " ARGS... are either (see also |tcomment#Comment()|):
                            "   1. a list of key=value pairs
                            "   2. 1-2 values for: ?commentBegin, ?commentEnd
    1              0.000021 command! -bang -complete=customlist,tcomment#Complete -range -nargs=+ TCommentAs 
                                        \ call tcomment#CommentAs(<line1>, <line2>, "<bang>", <f-args>)
                            
                            " :display: :[range]TCommentRight[!] ?ARGS...
                            " Comment the text to the right of the cursor. If a visual selection was 
                            " made (be it block-wise or not), all lines are commented out at from 
                            " the current cursor position downwards.
                            " With a bang '!', always comment the line.
                            "
                            " ARGS... are either (see also |tcomment#Comment()|):
                            "   1. a list of key=value pairs
                            "   2. 1-2 values for: ?commentBegin, ?commentEnd
    1              0.000022 command! -bang -range -nargs=* -complete=customlist,tcomment#CompleteArgs TCommentRight
                                        \ keepjumps call tcomment#Comment(<line1>, <line2>, 'R', "<bang>", <f-args>)
                            
                            " :display: :[range]TCommentBlock[!] ?ARGS...
                            " Comment as "block", e.g. use the {&ft}_block comment style. The 
                            " commented text isn't indented or reformated.
                            " With a bang '!', always comment the line.
                            "
                            " ARGS... are either (see also |tcomment#Comment()|):
                            "   1. a list of key=value pairs
                            "   2. 1-2 values for: ?commentBegin, ?commentEnd
    1              0.000021 command! -bang -range -nargs=* -complete=customlist,tcomment#CompleteArgs TCommentBlock
                                        \ keepjumps call tcomment#Comment(<line1>, <line2>, 'B', "<bang>", <f-args>)
                            
                            " :display: :[range]TCommentInline[!] ?ARGS...
                            " Use the {&ft}_inline comment style.
                            " With a bang '!', always comment the line.
                            "
                            " ARGS... are either (see also |tcomment#Comment()|):
                            "   1. a list of key=value pairs
                            "   2. 1-2 values for: ?commentBegin, ?commentEnd
    1              0.000022 command! -bang -range -nargs=* -complete=customlist,tcomment#CompleteArgs TCommentInline
                                        \ keepjumps call tcomment#Comment(<line1>, <line2>, 'I', "<bang>", <f-args>)
                            
                            " :display: :[range]TCommentMaybeInline[!] ?ARGS...
                            " With a bang '!', always comment the line.
                            "
                            " ARGS... are either (see also |tcomment#Comment()|):
                            "   1. a list of key=value pairs
                            "   2. 1-2 values for: ?commentBegin, ?commentEnd
    1              0.000021 command! -bang -range -nargs=* -complete=customlist,tcomment#CompleteArgs TCommentMaybeInline
                                        \ keepjumps call tcomment#Comment(<line1>, <line2>, 'i', "<bang>", <f-args>)
                            
                            
                            
    1              0.000004 if g:tcommentMaps
    1              0.000003     if g:tcommentMapLeader1 != ''
    1              0.000014         exec 'noremap <silent> '. g:tcommentMapLeader1 . g:tcommentMapLeader1 .' :TComment<cr>'
    1              0.000013         exec 'vnoremap <silent> '. g:tcommentMapLeader1 . g:tcommentMapLeader1 .' :TCommentMaybeInline<cr>'
    1              0.000012         exec 'inoremap <silent> '. g:tcommentMapLeader1 . g:tcommentMapLeader1 .' <c-o>:TComment<cr>'
    1              0.000010         exec 'noremap <silent> '. g:tcommentMapLeader1 .'p m`vip:TComment<cr>``'
    1              0.000012         exec 'inoremap <silent> '. g:tcommentMapLeader1 .'p <c-o>:norm! m`vip<cr>:TComment<cr><c-o>``'
    1              0.000010         exec 'noremap '. g:tcommentMapLeader1 .'<space> :TComment '
    1              0.000010         exec 'inoremap '. g:tcommentMapLeader1 .'<space> <c-o>:TComment '
    1              0.000011         exec 'inoremap <silent> '. g:tcommentMapLeader1 .'r <c-o>:TCommentRight<cr>'
    1              0.000010         exec 'noremap <silent> '. g:tcommentMapLeader1 .'r :TCommentRight<cr>'
    1              0.000011         exec 'vnoremap <silent> '. g:tcommentMapLeader1 .'i :TCommentInline<cr>'
    1              0.000012         exec 'noremap <silent> '. g:tcommentMapLeader1 .'i v:TCommentInline mode=I#<cr>'
    1              0.000012         exec 'inoremap <silent> '. g:tcommentMapLeader1 .'i <c-\><c-o>v:TCommentInline mode=#<cr>'
    1              0.000010         exec 'noremap '. g:tcommentMapLeader1 .'b :TCommentBlock<cr>'
    1              0.000011         exec 'inoremap '. g:tcommentMapLeader1 .'b <c-o>:TCommentBlock<cr>'
    1              0.000010         exec 'noremap '. g:tcommentMapLeader1 .'a :TCommentAs '
    1              0.000011         exec 'inoremap '. g:tcommentMapLeader1 .'a <c-o>:TCommentAs '
    1              0.000012         exec 'noremap '. g:tcommentMapLeader1 .'n :TCommentAs <c-r>=&ft<cr> '
    1              0.000012         exec 'inoremap '. g:tcommentMapLeader1 .'n <c-o>:TCommentAs <c-r>=&ft<cr> '
    1              0.000011         exec 'noremap '. g:tcommentMapLeader1 .'s :TCommentAs <c-r>=&ft<cr>_'
    1              0.000011         exec 'inoremap '. g:tcommentMapLeader1 .'s <c-o>:TCommentAs <c-r>=&ft<cr>_'
    1              0.000017         exec 'noremap <silent> '. g:tcommentMapLeader1 .'cc :<c-u>call tcomment#SetOption("count", v:count1)<cr>'
    1              0.000024         exec 'noremap '. g:tcommentMapLeader1 .'ca :<c-u>call tcomment#SetOption("as", input("Comment as: ", &filetype, "customlist,tcomment#Complete"))<cr>'
   10              0.000021         for s:i in range(1, 9)
    9              0.000117             exec 'noremap <silent> '. g:tcommentMapLeader1 . s:i .' :TComment count='. s:i .'<cr>'
    9              0.000119             exec 'inoremap <silent> '. g:tcommentMapLeader1 . s:i .' <c-\><c-o>:TComment count='. s:i .'<cr>'
    9              0.000122             exec 'vnoremap <silent> '. g:tcommentMapLeader1 . s:i .' :TCommentMaybeInline count='. s:i .'<cr>'
    9              0.000006         endfor
    1              0.000002         unlet s:i
    1              0.000002     endif
    1              0.000002     if g:tcommentMapLeader2 != ''
    1              0.000013         exec 'noremap <silent> '. g:tcommentMapLeader2 .'_ :TComment<cr>'
    1              0.000014         exec 'xnoremap <silent> '. g:tcommentMapLeader2 .'_ :TCommentMaybeInline<cr>'
    1              0.000012         exec 'noremap <silent> '. g:tcommentMapLeader2 .'p vip:TComment<cr>'
    1              0.000013         exec 'noremap '. g:tcommentMapLeader2 .'<space> :TComment '
    1              0.000013         exec 'xnoremap <silent> '. g:tcommentMapLeader2 .'i :TCommentInline<cr>'
    1              0.000014         exec 'noremap <silent> '. g:tcommentMapLeader2 .'r :TCommentRight<cr>'
    1              0.000012         exec 'noremap '. g:tcommentMapLeader2 .'b :TCommentBlock<cr>'
    1              0.000012         exec 'noremap '. g:tcommentMapLeader2 .'a :TCommentAs '
    1              0.000014         exec 'noremap '. g:tcommentMapLeader2 .'n :TCommentAs <c-r>=&ft<cr> '
    1              0.000013         exec 'noremap '. g:tcommentMapLeader2 .'s :TCommentAs <c-r>=&ft<cr>_'
    1              0.000002     endif
    1              0.000002     if g:tcommentMapLeaderOp1 != ''
    1              0.000031         exec 'nnoremap <silent> '. g:tcommentMapLeaderOp1 .' :<c-u>if v:count > 0 \| call tcomment#SetOption("count", v:count) \| endif \| let w:tcommentPos = getpos(".") \| set opfunc=tcomment#Operator<cr>g@'
   10              0.000015         for s:i in range(1, 9)
    9              0.000246             exec 'nnoremap <silent> '. g:tcommentMapLeaderOp1 . s:i .'c :let w:tcommentPos = getpos(".") \| call tcomment#SetOption("count", '. s:i .') \| set opfunc=tcomment#Operator<cr>g@'
    9              0.000010         endfor
    1              0.000002         unlet s:i
    1              0.000020         exec 'nnoremap <silent> '. g:tcommentMapLeaderOp1 .'c :let w:tcommentPos = getpos(".") \| set opfunc=tcomment#OperatorLine<cr>g@$'
    1              0.000032         exec 'nnoremap <silent> '. g:tcommentMapLeaderOp1 .'b :let w:tcommentPos = getpos(".") \| call tcomment#SetOption("mode_extra", "B") \| set opfunc=tcomment#OperatorLine<cr>g@'
    1              0.000014         exec 'xnoremap <silent> '. g:tcommentMapLeaderOp1 .' :TCommentMaybeInline<cr>'
    1              0.000004     endif
    1              0.000002     if g:tcommentMapLeaderOp2 != ''
    1              0.000021         exec 'nnoremap <silent> '. g:tcommentMapLeaderOp2 .' :let w:tcommentPos = getpos(".") \| set opfunc=tcomment#OperatorAnyway<cr>g@'
    1              0.000021         exec 'nnoremap <silent> '. g:tcommentMapLeaderOp2 .'c :let w:tcommentPos = getpos(".") \| set opfunc=tcomment#OperatorLineAnyway<cr>g@$'
    1              0.000029         exec 'nnoremap <silent> '. g:tcommentMapLeaderOp2 .'b :let w:tcommentPos = getpos(".") \| call tcomment#SetOption("mode_extra", "B") \| set opfunc=tcomment#OperatorLine<cr>g@'
    1              0.000013         exec 'xnoremap <silent> '. g:tcommentMapLeaderOp2 .' :TCommentMaybeInline!<cr>'
    1              0.000001     endif
    1              0.000001 endif
                            
                            " vi: ft=vim:tw=72:ts=4:fo=w2croql

SCRIPT  /usr/share/vim/vim73/plugin/getscriptPlugin.vim
Sourced 1 time
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
                            " ---------------------------------------------------------------------
                            " getscriptPlugin.vim
                            "  Author:	Charles E. Campbell, Jr.
                            "  Date:	Jan 07, 2008
                            "  Installing:	:help glvs-install
                            "  Usage:	:help glvs
                            "
                            " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim
                            "
                            " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let
                            " all the peoples praise Him."
                            " ---------------------------------------------------------------------
                            " Initialization:	{{{1
                            " if you're sourcing this file, surely you can't be
                            " expecting vim to be in its vi-compatible mode
    1              0.000012 if &cp || exists("g:loaded_getscriptPlugin")
                             if &verbose
                              echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"
                             endif
                             finish
                            endif
    1              0.000004 let g:loaded_getscriptPlugin = "v34"
    1              0.000008 let s:keepcpo                = &cpo
    1              0.000010 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            "  Public Interface: {{{1
    1              0.000012 com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()
    1              0.000009 com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()
    1              0.000011 silent! com -nargs=0 GLVS                call getscript#GetLatestVimScripts()
                            
                            " ---------------------------------------------------------------------
                            " Restore Options: {{{1
    1              0.000009 let &cpo= s:keepcpo
    1              0.000002 unlet s:keepcpo
                            
                            " ---------------------------------------------------------------------
                            " vim: ts=8 sts=2 fdm=marker nowrap

SCRIPT  /usr/share/vim/vim73/plugin/gzip.vim
Sourced 1 time
Total time:   0.000378
 Self time:   0.000378

count  total (s)   self (s)
                            " Vim plugin for editing compressed files.
                            " Maintainer: Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2010 Mar 10
                            
                            " Exit quickly when:
                            " - this plugin was already loaded
                            " - when 'compatible' is set
                            " - some autocommands are already taking care of compressed files
    1              0.000014 if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
                              finish
                            endif
    1              0.000003 let loaded_gzip = 1
                            
    1              0.000002 augroup gzip
                              " Remove all gzip autocommands
    1              0.000171   au!
                            
                              " Enable editing of gzipped files.
                              " The functions are defined in autoload/gzip.vim.
                              "
                              " Set binary mode before reading the file.
                              " Use "gzip -d", gunzip isn't always available.
    1              0.000022   autocmd BufReadPre,FileReadPre	*.gz,*.bz2,*.Z,*.lzma,*.xz setlocal bin
    1              0.000015   autocmd BufReadPost,FileReadPost	*.gz  call gzip#read("gzip -dn")
    1              0.000015   autocmd BufReadPost,FileReadPost	*.bz2 call gzip#read("bzip2 -d")
    1              0.000014   autocmd BufReadPost,FileReadPost	*.Z   call gzip#read("uncompress")
    1              0.000015   autocmd BufReadPost,FileReadPost	*.lzma call gzip#read("lzma -d")
    1              0.000014   autocmd BufReadPost,FileReadPost	*.xz  call gzip#read("xz -d")
    1              0.000006   autocmd BufWritePost,FileWritePost	*.gz  call gzip#write("gzip")
    1              0.000007   autocmd BufWritePost,FileWritePost	*.bz2 call gzip#write("bzip2")
    1              0.000006   autocmd BufWritePost,FileWritePost	*.Z   call gzip#write("compress -f")
    1              0.000007   autocmd BufWritePost,FileWritePost	*.lzma call gzip#write("lzma -z")
    1              0.000007   autocmd BufWritePost,FileWritePost	*.xz  call gzip#write("xz -z")
    1              0.000004   autocmd FileAppendPre			*.gz  call gzip#appre("gzip -dn")
    1              0.000005   autocmd FileAppendPre			*.bz2 call gzip#appre("bzip2 -d")
    1              0.000004   autocmd FileAppendPre			*.Z   call gzip#appre("uncompress")
    1              0.000005   autocmd FileAppendPre			*.lzma call gzip#appre("lzma -d")
    1              0.000004   autocmd FileAppendPre			*.xz   call gzip#appre("xz -d")
    1              0.000004   autocmd FileAppendPost		*.gz  call gzip#write("gzip")
    1              0.000004   autocmd FileAppendPost		*.bz2 call gzip#write("bzip2")
    1              0.000004   autocmd FileAppendPost		*.Z   call gzip#write("compress -f")
    1              0.000005   autocmd FileAppendPost		*.lzma call gzip#write("lzma -z")
    1              0.000004   autocmd FileAppendPost		*.xz call gzip#write("xz -z")
    1              0.000003 augroup END

SCRIPT  /usr/share/vim/vim73/plugin/matchparen.vim
Sourced 1 time
Total time:   0.000223
 Self time:   0.000223

count  total (s)   self (s)
                            " Vim plugin for showing matching parens
                            " Maintainer:  Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2011 Aug 27
                            
                            " Exit quickly when:
                            " - this plugin was already loaded (or disabled)
                            " - when 'compatible' is set
                            " - the "CursorMoved" autocmd event is not availble.
    1              0.000018 if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")
                              finish
                            endif
    1              0.000003 let g:loaded_matchparen = 1
                            
    1              0.000002 augroup matchparen
                              " Replace all matchparen autocommands
    1              0.000011   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()
    1              0.000002 augroup END
                            
                            " Skip the rest if it was already done.
    1              0.000006 if exists("*s:Highlight_Matching_Pair")
                              finish
                            endif
                            
    1              0.000008 let s:cpo_save = &cpo
    1              0.000011 set cpo-=C
                            
                            " The function that is invoked (very often) to define a ":match" highlighting
                            " for any matching paren.
    1              0.000004 function! s:Highlight_Matching_Pair()
                              " Remove any previous match.
                              if exists('w:paren_hl_on') && w:paren_hl_on
                                3match none
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
                              if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
                              let c_lnum = line('.')
                              let c_col = col('.')
                              let before = 0
                            
                              let c = getline(c_lnum)[c_col - 1]
                              let plist = split(&matchpairs, '.\zs[:,]')
                              let i = index(plist, c)
                              if i < 0
                                " not found, in Insert mode try character before the cursor
                                if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = 1
                                  let c = getline(c_lnum)[c_col - 2]
                                  let i = index(plist, c)
                                endif
                                if i < 0
                                  " not found, nothing to do
                                  return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let save_cursor = winsaveview()
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " When not in a string or comment ignore matches inside them.
                              " We match "escape" for special items, such as lispEscapeSpecial.
                              let s_skip ='synIDattr(synID(line("."), col("."), 0), "name") ' .
                            	\ '=~?  "string\\|character\\|singlequote\\|escape\\|comment"'
                              execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              try
                                " Limit the search time to 300 msec to avoid a hang on very long lines.
                                " This fails when a timeout is not supported.
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, 300)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                call winrestview(save_cursor)
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) .
                            	  \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                let w:paren_hl_on = 1
                              endif
                            endfunction
                            
                            " Define commands that will disable and enable the plugin.
    1              0.000016 command! NoMatchParen windo 3match none | unlet! g:loaded_matchparen |
                            	  \ au! matchparen
    1              0.000011 command! DoMatchParen runtime plugin/matchparen.vim | windo doau CursorMoved
                            
    1              0.000010 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save

SCRIPT  /usr/share/vim/vim73/plugin/netrwPlugin.vim
Sourced 1 time
Total time:   0.000626
 Self time:   0.000626

count  total (s)   self (s)
                            " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
                            "            PLUGIN SECTION
                            " Date:		Aug 24, 2011
                            " Maintainer:	Charles E Campbell, Jr <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
                            " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
                            " Copyright:    Copyright (C) 1999-2008 Charles E. Campbell, Jr. {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
                            "               *as is* and comes with no warranty of any kind, either
                            "               expressed or implied. By using this plugin, you agree that
                            "               in no event will the copyright holder be liable for any damages
                            "               resulting from the use of this software.
                            "
                            "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
                            "  (James 1:22 RSV)
                            " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                            " Load Once: {{{1
    1              0.000011 if &cp || exists("g:loaded_netrwPlugin")
                             finish
                            endif
    1              0.000004 let g:loaded_netrwPlugin = "v143"
    1              0.000003 if v:version < 702
                             echohl WarningMsg | echo "***netrw*** you need vim version 7.2 for this version of netrw" | echohl None
                             finish
                            endif
    1              0.000011 let s:keepcpo = &cpo
    1              0.000009 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
                            
                            " Local Browsing: {{{2
    1              0.000002 augroup FileExplorer
    1              0.000027  au!
                            " au BufReadCmd *[/\\]	sil! call s:LocalBrowse(expand("<amatch>")) 
                            " au BufEnter *[^/\\]	sil! call s:LocalBrowse(expand("<amatch>"))
                            " au VimEnter *[^/\\]	sil! call s:VimEnter(expand("<amatch>"))
    1              0.000006  au BufEnter *	sil! call s:LocalBrowse(expand("<amatch>"))
    1              0.000006  au VimEnter *	sil! call s:VimEnter(expand("<amatch>"))
    1              0.000014  if has("win32") || has("win95") || has("win64") || has("win16")
                              au BufEnter .* sil! call s:LocalBrowse(expand("<amatch>"))
                             endif
    1              0.000001 augroup END
                            
                            " Network Browsing Reading Writing: {{{2
    1              0.000001 augroup Network
    1              0.000017  au!
    1              0.000008  au BufReadCmd   file://*		call netrw#FileUrlRead(expand("<amatch>"))
    1              0.000024  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "silent doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "silent doau BufReadPost ".fnameescape(expand("<amatch>"))
    1              0.000027  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "silent doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "silent doau FileReadPost ".fnameescape(expand("<amatch>"))
    1              0.000023  au BufWriteCmd  ftp://*,rcp://*,scp://*,dav://*,davs://*,rsync://*,sftp://*			exe "silent doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "silent doau BufWritePost ".fnameescape(expand("<amatch>"))
    1              0.000021  au FileWriteCmd ftp://*,rcp://*,scp://*,dav://*,davs://*,rsync://*,sftp://*			exe "silent doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "silent doau FileWritePost ".fnameescape(expand("<amatch>"))
    1              0.000002  try
    1              0.000024   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
    1              0.000003  catch /^Vim\%((\a\+)\)\=:E216/
                              au SourcePre   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
                             endtry
    1              0.000001 augroup END
                            
                            " Commands: :Nread, :Nwrite, :NetUserPass {{{2
    1              0.000024 com! -count=1 -nargs=*	Nread		call netrw#NetrwSavePosn()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call netrw#NetrwRestorePosn()
    1              0.000028 com! -range=% -nargs=*	Nwrite		call netrw#NetrwSavePosn()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call netrw#NetrwRestorePosn()
    1              0.000009 com! -nargs=*		NetUserPass	call NetUserPass(<f-args>)
    1              0.000017 com! -nargs=*	        Nsource		call netrw#NetrwSavePosn()<bar>call netrw#NetSource(<f-args>)<bar>call netrw#NetrwRestorePosn()
                            
                            " Commands: :Explore, :Sexplore, Hexplore, Vexplore {{{2
    1              0.000015 com! -nargs=* -bar -bang -count=0 -complete=dir	Explore		call netrw#Explore(<count>,0,0+<bang>0,<q-args>)
    1              0.000022 com! -nargs=* -bar -bang -count=0 -complete=dir	Sexplore	call netrw#Explore(<count>,1,0+<bang>0,<q-args>)
    1              0.000015 com! -nargs=* -bar -bang -count=0 -complete=dir	Hexplore	call netrw#Explore(<count>,1,2+<bang>0,<q-args>)
    1              0.000016 com! -nargs=* -bar -bang -count=0 -complete=dir	Vexplore	call netrw#Explore(<count>,1,4+<bang>0,<q-args>)
    1              0.000013 com! -nargs=* -bar       -count=0 -complete=dir	Texplore	call netrw#Explore(<count>,0,6        ,<q-args>)
    1              0.000013 com! -nargs=* -bar -bang			Nexplore	call netrw#Explore(-1,0,0,<q-args>)
    1              0.000009 com! -nargs=* -bar -bang			Pexplore	call netrw#Explore(-2,0,0,<q-args>)
                            
                            " Commands: NetrwSettings {{{2
    1              0.000008 com! -nargs=0	NetrwSettings	call netrwSettings#NetrwSettings()
    1              0.000010 com! -bang	NetrwClean	call netrw#NetrwClean(<bang>0)
                            
                            " Maps:
    1              0.000013 if !exists("g:netrw_nogx") && maparg('gx','n') == ""
    1              0.000018  if !hasmapto('<Plug>NetrwBrowseX')
    1              0.000010   nmap <unique> gx <Plug>NetrwBrowseX
    1              0.000001  endif
    1              0.000016  nno <silent> <Plug>NetrwBrowseX :call netrw#NetrwBrowseX(expand("<cWORD>"),0)<cr>
    1              0.000001 endif
                            
                            " ---------------------------------------------------------------------
                            " LocalBrowse: {{{2
    1              0.000005 fun! s:LocalBrowse(dirname)
                              " unfortunate interaction -- debugging calls can't be used here;
                              " the BufEnter event causes triggering when attempts to write to
                              " the DBG buffer are made.
                            "  echomsg "dirname<".a:dirname.">"
                              if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                               endif
                              elseif isdirectory(a:dirname)
                            "   echomsg "dirname<".dirname."> isdir"
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                              endif
                              " not a directory, ignore it
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:VimEnter: {{{2
    1              0.000003 fun! s:VimEnter(dirname)
                              let curwin= winnr()
                              windo if a:dirname != expand("%")|call s:LocalBrowse(expand("%:p"))|endif
                              exe curwin."wincmd w"
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " NetrwStatusLine: {{{1
    1              0.000002 fun! NetrwStatusLine()
                            "  let g:stlmsg= "Xbufnr=".w:netrw_explore_bufnr." bufnr=".bufnr("%")." Xline#".w:netrw_explore_line." line#".line(".")
                              if !exists("w:netrw_explore_bufnr") || w:netrw_explore_bufnr != bufnr("%") || !exists("w:netrw_explore_line") || w:netrw_explore_line != line(".") || !exists("w:netrw_explore_list")
                               let &stl= s:netrw_explore_stl
                               if exists("w:netrw_explore_bufnr")|unlet w:netrw_explore_bufnr|endif
                               if exists("w:netrw_explore_line")|unlet w:netrw_explore_line|endif
                               return ""
                              else
                               return "Match ".w:netrw_explore_mtchcnt." of ".w:netrw_explore_listlen
                              endif
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " NetUserPass: set username and password for subsequent ftp transfer {{{1
                            "   Usage:  :call NetUserPass()			-- will prompt for userid and password
                            "	    :call NetUserPass("uid")		-- will prompt for password
                            "	    :call NetUserPass("uid","password") -- sets global userid and password
    1              0.000001 fun! NetUserPass(...)
                            
                             " get/set userid
                             if a:0 == 0
                            "  call Dfunc("NetUserPass(a:0<".a:0.">)")
                              if !exists("g:netrw_uid") || g:netrw_uid == ""
                               " via prompt
                               let g:netrw_uid= input('Enter username: ')
                              endif
                             else	" from command line
                            "  call Dfunc("NetUserPass(a:1<".a:1.">) {")
                              let g:netrw_uid= a:1
                             endif
                            
                             " get password
                             if a:0 <= 1 " via prompt
                            "  call Decho("a:0=".a:0." case <=1:")
                              let g:netrw_passwd= inputsecret("Enter Password: ")
                             else " from command line
                            "  call Decho("a:0=".a:0." case >1: a:2<".a:2.">")
                              let g:netrw_passwd=a:2
                             endif
                            "  call Dret("NetUserPass")
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " Modelines And Restoration: {{{1
    1              0.000011 let &cpo= s:keepcpo
    1              0.000002 unlet s:keepcpo
                            " vim:ts=8 fdm=marker

SCRIPT  /usr/share/vim/vim73/plugin/rrhelper.vim
Sourced 1 time
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
                            " Vim plugin with helper function(s) for --remote-wait
                            " Maintainer: Flemming Madsen <fma@cci.dk>
                            " Last Change: 2008 May 29
                            
                            " Has this already been loaded?
    1              0.000006 if exists("loaded_rrhelper") || !has("clientserver")
                              finish
                            endif
    1              0.000004 let loaded_rrhelper = 1
                            
                            " Setup answers for a --remote-wait client who will assume
                            " a SetupRemoteReplies() function in the command server
                            
    1              0.000002 function SetupRemoteReplies()
                              let cnt = 0
                              let max = argc()
                            
                              let id = expand("<client>")
                              if id == 0
                                return
                              endif
                              while cnt < max
                                " Handle same file from more clients and file being more than once
                                " on the command line by encoding this stuff in the group name
                                let uniqueGroup = "RemoteReply_".id."_".cnt
                            
                                " Path separators are always forward slashes for the autocommand pattern.
                                " Escape special characters with a backslash.
                                let f = substitute(argv(cnt), '\\', '/', "g")
                                if exists('*fnameescape')
                                  let f = fnameescape(f)
                                else
                                  let f = escape(f, " \t\n*?[{`$\\%#'\"|!<")
                                endif
                                execute "augroup ".uniqueGroup
                                execute "autocmd ".uniqueGroup." BufUnload ". f ."  call DoRemoteReply('".id."', '".cnt."', '".uniqueGroup."', '". f ."')"
                                let cnt = cnt + 1
                              endwhile
                              augroup END
                            endfunc
                            
    1              0.000004 function DoRemoteReply(id, cnt, group, file)
                              call server2client(a:id, a:cnt)
                              execute 'autocmd! '.a:group.' BufUnload '.a:file
                              execute 'augroup! '.a:group
                            endfunc
                            
                            " vim: set sw=2 sts=2 :

SCRIPT  /usr/share/vim/vim73/plugin/spellfile.vim
Sourced 1 time
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
                            " Vim plugin for downloading spell files
                            " Maintainer:  Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2006 Feb 01
                            
                            " Exit quickly when:
                            " - this plugin was already loaded
                            " - when 'compatible' is set
                            " - some autocommands are already taking care of spell files
    1              0.000017 if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
                              finish
                            endif
    1              0.000003 let loaded_spellfile_plugin = 1
                            
                            " The function is in the autoload directory.
    1              0.000008 autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))

SCRIPT  /usr/share/vim/vim73/plugin/tarPlugin.vim
Sourced 1 time
Total time:   0.000210
 Self time:   0.000210

count  total (s)   self (s)
                            " tarPlugin.vim -- a Vim plugin for browsing tarfiles
                            " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
                            " Modified by Charles E. Campbell, Jr.
                            " Distributed under the GNU General Public License.
                            "
                            " Updates are available from <http://michael.toren.net/code/>.  If you
                            " find this script useful, or have suggestions for improvements, please
                            " let me know.
                            " Also look there for further comments and documentation.
                            "
                            " This part only sets the autocommands.  The functions are in autoload/tar.vim.
                            " ---------------------------------------------------------------------
                            "  Load Once: {{{1
    1              0.000011 if &cp || exists("g:loaded_tarPlugin")
                             finish
                            endif
    1              0.000003 let g:loaded_tarPlugin = "v28"
    1              0.000008 let s:keepcpo          = &cpo
    1              0.000009 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            "  Public Interface: {{{1
    1              0.000002 augroup tar
    1              0.000030   au!
    1              0.000008   au BufReadCmd   tarfile::*	call tar#Read(expand("<amatch>"), 1)
    1              0.000006   au FileReadCmd  tarfile::*	call tar#Read(expand("<amatch>"), 0)
    1              0.000006   au BufWriteCmd  tarfile::*	call tar#Write(expand("<amatch>"))
    1              0.000005   au FileWriteCmd tarfile::*	call tar#Write(expand("<amatch>"))
                            
    1              0.000003   if has("unix")
    1              0.000007    au BufReadCmd   tarfile::*/*	call tar#Read(expand("<amatch>"), 1)
    1              0.000007    au FileReadCmd  tarfile::*/*	call tar#Read(expand("<amatch>"), 0)
    1              0.000006    au BufWriteCmd  tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000006    au FileWriteCmd tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000001   endif
                            
    1              0.000005   au BufReadCmd   *.tar.gz		call tar#Browse(expand("<amatch>"))
    1              0.000005   au BufReadCmd   *.tar			call tar#Browse(expand("<amatch>"))
    1              0.000004   au BufReadCmd   *.lrp			call tar#Browse(expand("<amatch>"))
    1              0.000004   au BufReadCmd   *.tar.bz2		call tar#Browse(expand("<amatch>"))
    1              0.000006   au BufReadCmd   *.tar.Z		call tar#Browse(expand("<amatch>"))
    1              0.000004   au BufReadCmd   *.tgz			call tar#Browse(expand("<amatch>"))
    1              0.000005   au BufReadCmd   *.tar.lzma	call tar#Browse(expand("<amatch>"))
    1              0.000005   au BufReadCmd   *.tar.xz		call tar#Browse(expand("<amatch>"))
    1              0.000004   au BufReadCmd   *.txz			call tar#Browse(expand("<amatch>"))
    1              0.000002 augroup END
    1              0.000015 com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
                            
                            " ---------------------------------------------------------------------
                            " Restoration And Modelines: {{{1
                            " vim: fdm=marker
    1              0.000010 let &cpo= s:keepcpo
    1              0.000004 unlet s:keepcpo

SCRIPT  /usr/share/vim/vim73/plugin/tohtml.vim
Sourced 1 time
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
                            " Vim plugin for converting a syntax highlighted file to HTML.
                            " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
                            " Last Change: 2011 May 26
                            "
                            " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
                            " $VIMRUNTIME/syntax/2html.vim
                            "
                            " TODO:
                            "   * Options for generating the CSS in external style sheets. New :TOcss
                            "     command to convert the current color scheme into a (mostly) generic CSS
                            "     stylesheet which can be re-used. Alternate stylesheet support?
                            "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
                            "	- listchars support
                            "	- full-line background highlight
                            "	- other?
                            "   * Font auto-detection similar to
                            "     http://www.vim.org/scripts/script.php?script_id=2384
                            "   * Explicitly trigger IE8+ Standards Mode?
                            "   * Make it so deleted lines in a diff don't create side-scrolling
                            "   * Restore open/closed folds and cursor position after processing each file
                            "     with option not to restore for speed increase
                            "   * Undercurl support via dotted bottom border?
                            "   * Add extra meta info (generation time, etc.)?
                            "   * Tidy up so we can use strict doctype in even more situations
                            "   * Implementation detail: add threshold for writing the lines to the html
                            "     buffer before we're done (5000 or so lines should do it)
                            "   * TODO comments for code cleanup scattered throughout
                            "
                            
    1              0.000005 if exists('g:loaded_2html_plugin')
                              finish
                            endif
    1              0.000004 let g:loaded_2html_plugin = 'vim7.3_v10'
                            
                            "
                            " Changelog:
                            "   7.3_v10 (this version): Fix error E684 when converting a range wholly inside
                            "                           multiple nested folds with dynamic folding on.
                            "                           Also fix problem with foldtext in this situation.
                            "   7.3_v9  (0877b8d6370e): Add html_pre_wrap option active with html_use_css
                            "                           and without html_no_pre, default value same as
                            "                           'wrap' option, (Andy Spencer). Don't use
                            "                           'fileencoding' for converted document encoding if
                            "                           'buftype' indicates a special buffer which isn't
                            "                           written.
                            "   7.3_v8  (85c5a72551e2): Add html_expand_tabs option to allow leaving tab
                            "                           characters in generated output (Andy Spencer).
                            "                           Escape text that looks like a modeline so Vim
                            "                           doesn't use anything in the converted HTML as a
                            "                           modeline. Bugfixes: Fix folding when a fold starts
                            "                           before the conversion range. Remove fold column when
                            "                           there are no folds.
                            "   7.3_v7  (840c3cadb842): see betas released on vim_dev below:
                            "                 7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
                            "                 7.3_v7b2: Remove automatic detection of encodings that are not
                            "                           supported by all major browsers according to
                            "                           http://wiki.whatwg.org/wiki/Web_Encodings and
                            "                           convert to UTF-8 for all Unicode encodings. Make
                            "                           HTML encoding to Vim encoding detection be
                            "                           case-insensitive for built-in pairs.
                            "                 7.3_v7b1: Remove use of setwinvar() function which cannot be
                            "                           called in restricted mode (Andy Spencer). Use
                            "                           'fencoding' instead of 'encoding' to determine by
                            "                           charset, and make sure the 'fenc' of the generated
                            "                           file matches its indicated charset. Add charsets for
                            "                           all of Vim's natively supported encodings.
                            "   7.3_v6  (0d3f0e3d289b): Really fix bug with 'nowrapscan', 'magic' and other
                            "                           user settings interfering with diff mode generation,
                            "                           trailing whitespace (e.g. line number column) when
                            "                           using html_no_pre, and bugs when using
                            "                           html_hover_unfold.
                            "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
                            "                           folds in diff mode when first line was folded.
                            "   7.3_v4  (7e008c174cc3): Bugfixes, especially for xhtml markup, and diff mode
                            "   7.3_v3  (a29075150aee): Refactor option handling and make html_use_css
                            "                           default to true when not set to anything. Use strict
                            "                           doctypes where possible. Rename use_xhtml option to
                            "                           html_use_xhtml for consistency. Use .xhtml extension
                            "                           when using this option. Add meta tag for settings.
                            "   7.3_v2  (80229a724a11): Fix syntax highlighting in diff mode to use both the
                            "                           diff colors and the normal syntax colors
                            "   7.3_v1  (e7751177126b): Add conceal support and meta tags in output
                            "   Pre-v1 baseline: Mercurial changeset 3c9324c0800e
                            
                            " Define the :TOhtml command when:
                            " - 'compatible' is not set
                            " - this plugin was not already loaded
                            " - user commands are available.
    1              0.000015 if !&cp && !exists(":TOhtml") && has("user_commands")
    1              0.000016   command -range=% TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
    1              0.000001 endif
                            
                            " Make sure any patches will probably use consistent indent
                            "   vim: ts=8 sw=2 sts=2 noet

SCRIPT  /usr/share/vim/vim73/plugin/vimballPlugin.vim
Sourced 1 time
Total time:   0.000207
 Self time:   0.000207

count  total (s)   self (s)
                            " vimballPlugin : construct a file containing both paths and files
                            " Author: Charles E. Campbell, Jr.
                            " Copyright: (c) 2004-2010 by Charles E. Campbell, Jr.
                            "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt
                            "            (see |copyright|) except use "Vimball" instead of "Vim".
                            "            No warranty, express or implied.
                            "  *** ***   Use At-Your-Own-Risk!   *** ***
                            "
                            " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who
                            "      judge. For in that which you judge another, you condemn yourself. For
                            "      you who judge practice the same things.
                            " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim
                            
                            " ---------------------------------------------------------------------
                            "  Load Once: {{{1
    1              0.000011 if &cp || exists("g:loaded_vimballPlugin")
                             finish
                            endif
    1              0.000003 let g:loaded_vimballPlugin = "v35"
    1              0.000008 let s:keepcpo              = &cpo
    1              0.000008 set cpo&vim
                            
                            " ------------------------------------------------------------------------------
                            " Public Interface: {{{1
    1              0.000020 com! -ra   -complete=file -na=+ -bang MkVimball				call vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)
    1              0.000010 com! -na=? -complete=dir  UseVimball						call vimball#Vimball(1,<f-args>)
    1              0.000009 com! -na=0                VimballList						call vimball#Vimball(0)
    1              0.000018 com! -na=* -complete=dir  RmVimball							call vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()
    1              0.000019 au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz	setlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")
    1              0.000017 au SourceCmd *.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz			if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if expand("%")!=expand("<afile>")|close|endif
    1              0.000009 au SourceCmd *.vba											if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
    1              0.000019 au BufEnter  *.vmb,*.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz	setlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")
    1              0.000017 au SourceCmd *.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz			if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if expand("%")!=expand("<afile>")|close|endif
    1              0.000008 au SourceCmd *.vmb											if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
                            
                            " =====================================================================
                            " Restoration And Modelines: {{{1
                            " vim: fdm=marker
    1              0.000010 let &cpo= s:keepcpo
    1              0.000003 unlet s:keepcpo

SCRIPT  /usr/share/vim/vim73/plugin/zipPlugin.vim
Sourced 1 time
Total time:   0.000192
 Self time:   0.000192

count  total (s)   self (s)
                            " zipPlugin.vim: Handles browsing zipfiles
                            "            PLUGIN PORTION
                            " Date:			Aug 15, 2011
                            " Maintainer:	Charles E Campbell, Jr <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
                            " License:		Vim License  (see vim's :help license)
                            " Copyright:    Copyright (C) 2005-2011 Charles E. Campbell, Jr. {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               zipPlugin.vim is provided *as is* and comes with no warranty
                            "               of any kind, either expressed or implied. By using this
                            "               plugin, you agree that in no event will the copyright
                            "               holder be liable for any damages resulting from the use
                            "               of this software.
                            "
                            " (James 4:8 WEB) Draw near to God, and he will draw near to you.
                            " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
                            " ---------------------------------------------------------------------
                            " Load Once: {{{1
    1              0.000011 if &cp || exists("g:loaded_zipPlugin")
                             finish
                            endif
    1              0.000003 let g:loaded_zipPlugin = "v25"
    1              0.000008 let s:keepcpo          = &cpo
    1              0.000009 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
    1              0.000002 augroup zip
    1              0.000052  au!
    1              0.000009  au BufReadCmd   zipfile:*	call zip#Read(expand("<amatch>"), 1)
    1              0.000006  au FileReadCmd  zipfile:*	call zip#Read(expand("<amatch>"), 0)
    1              0.000005  au BufWriteCmd  zipfile:*	call zip#Write(expand("<amatch>"))
    1              0.000006  au FileWriteCmd zipfile:*	call zip#Write(expand("<amatch>"))
                            
    1              0.000003  if has("unix")
    1              0.000007   au BufReadCmd   zipfile:*/*	call zip#Read(expand("<amatch>"), 1)
    1              0.000007   au FileReadCmd  zipfile:*/*	call zip#Read(expand("<amatch>"), 0)
    1              0.000006   au BufWriteCmd  zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000007   au FileWriteCmd zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000001  endif
                            
    1              0.000016  au BufReadCmd   *.zip,*.jar,*.xpi,*.war,*.ear,*.celzip,*.oxt		call zip#Browse(expand("<amatch>"))
    1              0.000001 augroup END
                            
                            " ---------------------------------------------------------------------
                            "  Restoration And Modelines: {{{1
                            "  vim: fdm=marker
    1              0.000010 let &cpo= s:keepcpo
    1              0.000004 unlet s:keepcpo

FUNCTION  fuf#buffertag#requiresOnCommandPre()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   return 0

FUNCTION  fuf#coveragefile#requiresOnCommandPre()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000001   return 0

FUNCTION  fuf#jumplist#requiresOnCommandPre()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return 0

FUNCTION  pathogen#split()
Called 2 times
Total time:   0.000306
 Self time:   0.000306

count  total (s)   self (s)
    2              0.000014   if type(a:path) == type([]) | return a:path | endif
    2              0.000156   let split = split(a:path,'\\\@<!\%(\\\\\)*\zs,')
    2              0.000135   return map(split,'substitute(v:val,''\\\([\\,]\)'',''\1'',"g")')

FUNCTION  fuf#bookmarkdir#renewCache()
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)

FUNCTION  fuf#callbackfile#renewCache()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004   let s:cache = {}

FUNCTION  NERDTreeAddKeyMap()
Called 50 times
Total time:   0.013627
 Self time:   0.000280

count  total (s)   self (s)
   50   0.013608   0.000261     call g:NERDTreeKeyMap.Create(a:options)

FUNCTION  <SNR>16_checkDataFileCompatibility()
Called 1 time
Total time:   0.000227
 Self time:   0.000057

count  total (s)   self (s)
    1              0.000004   if empty(g:fuf_dataDir)
                                let s:dataFileAvailable = 0
                                return
                              endif
    1   0.000096   0.000010   let versionPath = l9#concatPaths([g:fuf_dataDir, 'VERSION'])
    1   0.000093   0.000009   let lines = l9#readFile(versionPath)
    1              0.000003   if empty(lines)
                                call l9#writeFile([s:DATA_FILE_VERSION], versionPath)
                                let s:dataFileAvailable = 1
                              elseif str2nr(lines[0]) == s:DATA_FILE_VERSION
    1              0.000003     let s:dataFileAvailable = 1
    1              0.000001   else
                                call fuf#echoWarning(printf( "=======================================================\n" . "  Existing data files for FuzzyFinder is no longer     \n" . "  compatible with this version of FuzzyFinder. Remove  \n" . "  %-53s\n" . "=======================================================\n" , string(g:fuf_dataDir)))
                                call l9#inputHl('Question', 'Press Enter')
                                let s:dataFileAvailable = 0
                              endif

FUNCTION  <SNR>38_SID()
Called 1 time
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000004     if !exists("s:sid")
    1              0.000020         let s:sid = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
    1              0.000002     endif
    1              0.000001     return s:sid

FUNCTION  fuf#givendir#onInit()
Called 1 time
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)

FUNCTION  <SNR>13_MRU_escape_filename()
Called 3 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    3              0.000028     return escape(a:fname, s:esc_filename_chars)

FUNCTION  fuf#coveragefile#renewCache()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004   let s:cache = {}

FUNCTION  pathogen#incubate()
Called 1 time
Total time:   0.001802
 Self time:   0.000417

count  total (s)   self (s)
    1   0.000014   0.000008   let sep = pathogen#separator()
    1              0.000003   let name = a:0 ? a:1 : 'bundle/{}'
    1              0.000008   if "\n".s:done_bundles =~# "\\M\n".name."\n"
                                return ""
                              endif
    1              0.000004   let s:done_bundles .= name . "\n"
    1              0.000002   let list = []
    8   0.000141   0.000023   for dir in pathogen#split(&rtp)
    7              0.000031     if dir =~# '\<after$'
    3              0.000009       if name =~# '{}$'
    3   0.000171   0.000060         let list +=  filter(pathogen#glob_directories(substitute(dir,'after$',name[0:-3],'').'*[^~]'.sep.'after'), '!pathogen#is_disabled(v:val[0:-7])') + [dir]
    3              0.000003       else
                                    let list += [dir, substitute(dir, 'after$', '', '') . name . sep . 'after']
                                  endif
    3              0.000002     else
    4              0.000013       if name =~# '{}$'
    4   0.000582   0.000089         let list +=  [dir] + filter(pathogen#glob_directories(dir.sep.name[0:-3].'*[^~]'), '!pathogen#is_disabled(v:val)')
    4              0.000004       else
                                    let list += [dir . sep . name, dir]
                                  endif
    4              0.000000     endif
    7              0.000004   endfor
    1   0.000679   0.000022   let &rtp = pathogen#join(pathogen#uniq(list))
    1              0.000001   return 1

FUNCTION  fuf#tag#requiresOnCommandPre()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   return 0

FUNCTION  fuf#givencmd#requiresOnCommandPre()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   return 0

FUNCTION  fuf#line#requiresOnCommandPre()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return 0

FUNCTION  <SNR>11_hibg()
Called 10 times
Total time:   0.000220
 Self time:   0.000168

count  total (s)   self (s)
   10   0.000117   0.000065     let ctermbg = s:choose(a:first,a:second)
   10              0.000099     exe "highlight ".a:group." guibg=".a:guibg." ctermbg=".ctermbg

FUNCTION  fuf#help#requiresOnCommandPre()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return 0

FUNCTION  pathogen#helptags()
Called 1 time
Total time:   0.005565
 Self time:   0.005372

count  total (s)   self (s)
    1   0.000012   0.000007   let sep = pathogen#separator()
   13   0.000217   0.000029   for glob in pathogen#split(&rtp)
   21              0.000304     for dir in split(glob(glob), "\n")
    9              0.000684       if (dir.sep)[0 : strlen($VIMRUNTIME)] !=# $VIMRUNTIME.sep && filewritable(dir.sep.'doc') == 2 && !empty(filter(split(glob(dir.sep.'doc'.sep.'*'),"\n>"),'!isdirectory(v:val)')) && (!filereadable(dir.sep.'doc'.sep.'tags') || filewritable(dir.sep.'doc'.sep.'tags'))
    5              0.004125         helptags `=dir.'/doc'`
    5              0.000011       endif
    9              0.000008     endfor
   12              0.000008   endfor

FUNCTION  fuf#dir#onInit()
Called 1 time
Total time:   0.000137
 Self time:   0.000024

count  total (s)   self (s)
    1   0.000043   0.000007   call fuf#defineLaunchCommand('FufDir'                    , s:MODE_NAME, '""', [])
    1   0.000046   0.000008   call fuf#defineLaunchCommand('FufDirWithFullCwd'         , s:MODE_NAME, 'fnamemodify(getcwd(), '':p'')', [])
    1   0.000047   0.000008   call fuf#defineLaunchCommand('FufDirWithCurrentBufferDir', s:MODE_NAME, 'expand(''%:~:.'')[:-1-len(expand(''%:~:.:t''))]', [])

FUNCTION  nerdtree#checkForBrowse()
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000006     if a:dir != '' && isdirectory(a:dir)
                                    call g:NERDTreeCreator.CreateSecondary(a:dir)
                                endif

FUNCTION  <SNR>13_MRU_Refresh_Menu()
Called 1 time
Total time:   0.000404
 Self time:   0.000151

count  total (s)   self (s)
    1              0.000005     if !has('menu') || !g:MRU_Add_Menu
                                    " No support for menus
                                    return
                                endif
                            
                                " Setup the cpoptions properly for the maps to work
    1              0.000004     let old_cpoptions = &cpoptions
    1              0.000004     set cpoptions&vim
                            
                                " Remove the MRU menu
                                " To retain the teared-off MRU menu, we need to add a dummy entry
    1              0.000019     silent! unmenu &File.&Recent\ Files
                                " The menu priority of the File menu is 10. If the MRU plugin runs
                                " first before menu.vim, the File menu order may not be correct.
                                " So specify the priority of the File menu here.
    1              0.000007     10noremenu &File.&Recent\ Files.Dummy <Nop>
    1              0.000007     silent! unmenu! &File.&Recent\ Files
                            
    1              0.000012     anoremenu <silent> &File.&Recent\ Files.Refresh\ list :call <SID>MRU_LoadList()<CR>
    1   0.000031   0.000020     exe 'tmenu File.&Recent\ Files.Refresh\ list Reload the MRU file list from ' . s:MRU_escape_filename(g:MRU_File)
    1              0.000006     anoremenu File.&Recent\ Files.-SEP1-           :
                            
                                " Add the filenames in the MRU list to the menu
    1              0.000004     let entry_cnt = len(s:MRU_files)
    1              0.000002     if entry_cnt > g:MRU_Max_Menu_Entries
                                    " Show only MRU_Max_Menu_Entries file names in the menu
                                    let mru_list = s:MRU_files[1 : g:MRU_Max_Menu_Entries]
                                    let entry_cnt = g:MRU_Max_Menu_Entries
                                else
    1              0.000002         let mru_list = s:MRU_files
    1              0.000001     endif
    1              0.000002     if entry_cnt > g:MRU_Max_Submenu_Entries
                            	" Split the MRU menu into sub-menus
                                    for start_idx in range(0, entry_cnt, g:MRU_Max_Submenu_Entries)
                                        let last_idx = start_idx + g:MRU_Max_Submenu_Entries - 1
                                        if last_idx >= entry_cnt
                                            let last_idx = entry_cnt - 1
                                        endif
                                        let prefix = 'Files\ (' . (start_idx + 1) . '\.\.\.' . (last_idx + 1) . ').'
                                        call s:MRU_add_files_to_menu(prefix, mru_list[start_idx : last_idx])
                                    endfor
                                else
    1   0.000251   0.000009         call s:MRU_add_files_to_menu('', mru_list)
    1              0.000001     endif
                            
                                " Remove the dummy menu entry
    1              0.000003     unmenu &File.&Recent\ Files.Dummy
                            
                                " Restore the previous cpoptions settings
    1              0.000004     let &cpoptions = old_cpoptions

FUNCTION  fuf#help#onInit()
Called 1 time
Total time:   0.000093
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000047   0.000010   call fuf#defineLaunchCommand('FufHelp'              , s:MODE_NAME, '""', [])
    1   0.000046   0.000008   call fuf#defineLaunchCommand('FufHelpWithCursorWord', s:MODE_NAME, 'expand(''<cword>'')', [])

FUNCTION  fuf#buffertag#onInit()
Called 1 time
Total time:   0.000995
 Self time:   0.000280

count  total (s)   self (s)
    1   0.000084   0.000013   call fuf#defineLaunchCommand('FufBufferTag', s:MODE_NAME, '""',                      [['g:fuf_buffertag_forAll', 0]])
    1   0.000070   0.000009   call fuf#defineLaunchCommand('FufBufferTagAll', s:MODE_NAME, '""',                      [['g:fuf_buffertag_forAll', 1]])
    1   0.000073   0.000010   call fuf#defineLaunchCommand('FufBufferTagWithCursorWord', s:MODE_NAME,                      'expand(''<cword>'')', [['g:fuf_buffertag_forAll', 0]])
    1   0.000071   0.000009   call fuf#defineLaunchCommand('FufBufferTagAllWithCursorWord', s:MODE_NAME,                      'expand(''<cword>'')', [['g:fuf_buffertag_forAll', 1]])
    1   0.000071   0.000010   call fuf#defineLaunchCommand('FufBufferTagWithSelectedText', s:MODE_NAME,                      'l9#getSelectedText()', [['g:fuf_buffertag_forAll', 0]])
    1   0.000073   0.000009   call fuf#defineLaunchCommand('FufBufferTagAllWithSelectedText', s:MODE_NAME,                      'l9#getSelectedText()', [['g:fuf_buffertag_forAll', 1]])
    1   0.000018   0.000007   call l9#defineVariableDefault('g:fuf_buffertag_forAll', 0) " private option
                              " the following settings originate from taglist.vim
    1   0.000015   0.000006   call l9#defineVariableDefault('g:fuf_buffertag__asm'       , '--language-force=asm --asm-types=dlmt')
    1   0.000015   0.000006   call l9#defineVariableDefault('g:fuf_buffertag__aspperl'   , '--language-force=asp --asp-types=fsv')
    1   0.000015   0.000006   call l9#defineVariableDefault('g:fuf_buffertag__aspvbs'    , '--language-force=asp --asp-types=fsv')
    1   0.000013   0.000004   call l9#defineVariableDefault('g:fuf_buffertag__awk'       , '--language-force=awk --awk-types=f')
    1   0.000014   0.000006   call l9#defineVariableDefault('g:fuf_buffertag__beta'      , '--language-force=beta --beta-types=fsv')
    1   0.000015   0.000006   call l9#defineVariableDefault('g:fuf_buffertag__c'         , '--language-force=c --c-types=dgsutvf')
    1   0.000014   0.000006   call l9#defineVariableDefault('g:fuf_buffertag__cpp'       , '--language-force=c++ --c++-types=nvdtcgsuf')
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_buffertag__cs'        , '--language-force=c# --c#-types=dtncEgsipm')
    1   0.000014   0.000006   call l9#defineVariableDefault('g:fuf_buffertag__cobol'     , '--language-force=cobol --cobol-types=dfgpPs')
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_buffertag__eiffel'    , '--language-force=eiffel --eiffel-types=cf')
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_buffertag__erlang'    , '--language-force=erlang --erlang-types=drmf')
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_buffertag__expect'    , '--language-force=tcl --tcl-types=cfp')
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_buffertag__fortran'   , '--language-force=fortran --fortran-types=pbceiklmntvfs')
    1   0.000013   0.000004   call l9#defineVariableDefault('g:fuf_buffertag__html'      , '--language-force=html --html-types=af')
    1   0.000014   0.000006   call l9#defineVariableDefault('g:fuf_buffertag__java'      , '--language-force=java --java-types=pcifm')
    1   0.000015   0.000006   call l9#defineVariableDefault('g:fuf_buffertag__javascript', '--language-force=javascript --javascript-types=f')
    1   0.000014   0.000006   call l9#defineVariableDefault('g:fuf_buffertag__lisp'      , '--language-force=lisp --lisp-types=f')
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_buffertag__lua'       , '--language-force=lua --lua-types=f')
    1   0.000013   0.000004   call l9#defineVariableDefault('g:fuf_buffertag__make'      , '--language-force=make --make-types=m')
    1   0.000014   0.000006   call l9#defineVariableDefault('g:fuf_buffertag__pascal'    , '--language-force=pascal --pascal-types=fp')
    1   0.000014   0.000006   call l9#defineVariableDefault('g:fuf_buffertag__perl'      , '--language-force=perl --perl-types=clps')
    1   0.000014   0.000006   call l9#defineVariableDefault('g:fuf_buffertag__php'       , '--language-force=php --php-types=cdvf')
    1   0.000015   0.000006   call l9#defineVariableDefault('g:fuf_buffertag__python'    , '--language-force=python --python-types=cmf')
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_buffertag__rexx'      , '--language-force=rexx --rexx-types=s')
    1   0.000014   0.000006   call l9#defineVariableDefault('g:fuf_buffertag__ruby'      , '--language-force=ruby --ruby-types=cfFm')
    1   0.000015   0.000006   call l9#defineVariableDefault('g:fuf_buffertag__scheme'    , '--language-force=scheme --scheme-types=sf')
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_buffertag__sh'        , '--language-force=sh --sh-types=f')
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_buffertag__csh'       , '--language-force=sh --sh-types=f')
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_buffertag__zsh'       , '--language-force=sh --sh-types=f')
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_buffertag__slang'     , '--language-force=slang --slang-types=nf')
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_buffertag__sml'       , '--language-force=sml --sml-types=ecsrtvf')
    1   0.000013   0.000004   call l9#defineVariableDefault('g:fuf_buffertag__sql'       , '--language-force=sql --sql-types=cFPrstTvfp')
    1   0.000013   0.000004   call l9#defineVariableDefault('g:fuf_buffertag__tcl'       , '--language-force=tcl --tcl-types=cfmp')
    1   0.000014   0.000006   call l9#defineVariableDefault('g:fuf_buffertag__vera'      , '--language-force=vera --vera-types=cdefgmpPtTvx')
    1   0.000015   0.000006   call l9#defineVariableDefault('g:fuf_buffertag__verilog'   , '--language-force=verilog --verilog-types=mcPertwpvf')
    1   0.000015   0.000006   call l9#defineVariableDefault('g:fuf_buffertag__vim'       , '--language-force=vim --vim-types=avf')
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_buffertag__yacc'      , '--language-force=yacc --yacc-types=l')

FUNCTION  fuf#bookmarkfile#onInit()
Called 1 time
Total time:   0.000067
 Self time:   0.000028

count  total (s)   self (s)
    1   0.000049   0.000010   call fuf#defineLaunchCommand('FufBookmarkFile', s:MODE_NAME, '""', [])
    1              0.000008   command! -bang -narg=?        FufBookmarkFileAdd               call s:bookmarkHere(<q-args>)
    1              0.000010   command! -bang -narg=0 -range FufBookmarkFileAddAsSelectedText call s:bookmarkHere(l9#getSelectedText())

FUNCTION  fuf#taggedfile#requiresOnCommandPre()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000001   return 0

FUNCTION  pathogen#glob()
Called 7 times
Total time:   0.000464
 Self time:   0.000433

count  total (s)   self (s)
    7              0.000302   let files = split(glob(a:pattern),"\n")
    7   0.000160   0.000129   return map(files,'substitute(v:val,"[".pathogen#separator()."/]$","","")')

FUNCTION  fuf#buffer#renewCache()
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)

FUNCTION  pathogen#is_disabled()
Called 5 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    5              0.000018   if a:path =~# '\~$'
                                return 1
                              elseif !exists("g:pathogen_disabled")
    5              0.000005     return 0
                              endif
                              let sep = pathogen#separator()
                              let blacklist = g:pathogen_disabled
                              return index(blacklist, strpart(a:path, strridx(a:path, sep)+1)) != -1 && index(blacklist, a:path) != 1

FUNCTION  fuf#help#renewCache()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000003   let s:cache = {}

FUNCTION  fuf#callbackfile#requiresOnCommandPre()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   return 0

FUNCTION  <SNR>11_hifg()
Called 17 times
Total time:   0.000450
 Self time:   0.000363

count  total (s)   self (s)
   17              0.000032     if a:0 && &t_Co == 256
                                    let ctermfg = a:1
                                else
   17   0.000187   0.000100         let ctermfg = s:choose(a:first,a:second)
   17              0.000014     endif
   17              0.000155     exe "highlight ".a:group." guifg=".a:guifg." ctermfg=".ctermfg

FUNCTION  fuf#givenfile#requiresOnCommandPre()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   return 0

FUNCTION  l9#getPathSeparator()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000014   return (!&shellslash && (has('win32') || has('win64')) ? '\' : '/')

FUNCTION  fuf#givencmd#renewCache()
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)

FUNCTION  fuf#givenfile#renewCache()
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)

FUNCTION  <SNR>55_LocalBrowse()
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
                              " unfortunate interaction -- debugging calls can't be used here;
                              " the BufEnter event causes triggering when attempts to write to
                              " the DBG buffer are made.
                            "  echomsg "dirname<".a:dirname.">"
    1              0.000011   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                               endif
                              elseif isdirectory(a:dirname)
                            "   echomsg "dirname<".dirname."> isdir"
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                              endif
                              " not a directory, ignore it

FUNCTION  pathogen#glob_directories()
Called 7 times
Total time:   0.000551
 Self time:   0.000087

count  total (s)   self (s)
    7   0.000545   0.000081   return filter(pathogen#glob(a:pattern),'isdirectory(v:val)')

FUNCTION  fuf#dir#renewCache()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004   let s:cache = {}

FUNCTION  fuf#changelist#onInit()
Called 1 time
Total time:   0.000048
 Self time:   0.000010

count  total (s)   self (s)
    1   0.000047   0.000009   call fuf#defineLaunchCommand('FufChangeList', s:MODE_NAME, '""', [])

FUNCTION  fuf#callbackitem#onInit()
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)

FUNCTION  fuf#buffer#onInit()
Called 1 time
Total time:   0.000096
 Self time:   0.000054

count  total (s)   self (s)
    1   0.000051   0.000009   call fuf#defineLaunchCommand('FufBuffer', s:MODE_NAME, '""', [])
    1              0.000003   augroup fuf#buffer
    1              0.000032     autocmd!
    1              0.000005     autocmd BufEnter     * call s:updateBufTimes()
    1              0.000004     autocmd BufWritePost * call s:updateBufTimes()
    1              0.000001   augroup END

FUNCTION  fuf#callbackfile#onInit()
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)

FUNCTION  fuf#file#onInit()
Called 1 time
Total time:   0.000137
 Self time:   0.000024

count  total (s)   self (s)
    1   0.000043   0.000007   call fuf#defineLaunchCommand('FufFile'                    , s:MODE_NAME, '""', [])
    1   0.000045   0.000007   call fuf#defineLaunchCommand('FufFileWithFullCwd'         , s:MODE_NAME, 'fnamemodify(getcwd(), '':p'')', [])
    1   0.000048   0.000009   call fuf#defineLaunchCommand('FufFileWithCurrentBufferDir', s:MODE_NAME, 'expand(''%:~:.'')[:-1-len(expand(''%:~:.:t''))]', [])

FUNCTION  pathogen#join()
Called 1 time
Total time:   0.000349
 Self time:   0.000349

count  total (s)   self (s)
    1              0.000004   if type(a:1) == type(1) && a:1
                                let i = 1
                                let space = ' '
                              else
    1              0.000002     let i = 0
    1              0.000002     let space = ''
    1              0.000001   endif
    1              0.000001   let path = ""
    2              0.000003   while i < a:0
    1              0.000005     if type(a:000[i]) == type([])
    1              0.000003       let list = a:000[i]
    1              0.000002       let j = 0
   13              0.000027       while j < len(list)
   12              0.000183         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
   12              0.000044         let path .= ',' . escaped
   12              0.000014         let j += 1
   12              0.000012       endwhile
    1              0.000001     else
                                  let path .= "," . a:000[i]
                                endif
    1              0.000002     let i += 1
    1              0.000001   endwhile
    1              0.000007   return substitute(path,'^,','','')

FUNCTION  l9#defineVariableDefault()
Called 115 times
Total time:   0.001022
 Self time:   0.001022

count  total (s)   self (s)
  115              0.000368   if !exists(a:name)
  115              0.000475     let {a:name} = a:default
  115              0.000090   endif

FUNCTION  fuf#buffer#requiresOnCommandPre()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return 0

FUNCTION  pathogen#infect()
Called 1 time
Total time:   0.019497
 Self time:   0.000089

count  total (s)   self (s)
    2              0.000008   for path in a:0 ? reverse(copy(a:000)) : ['bundle/{}']
    1              0.000008     if path =~# '^[^\\/]\+$'
                                  call s:warn('Change pathogen#infect('.string(path).') to pathogen#infect('.string(path.'/{}').')')
                                  call pathogen#incubate(path . '/{}')
                                elseif path =~# '^[^\\/]\+[\\/]\%({}\|\*\)$'
    1   0.001811   0.000009       call pathogen#incubate(path)
    1              0.000002     elseif path =~# '[\\/]\%({}\|\*\)$'
                                  call pathogen#surround(path)
                                else
                                  call s:warn('Change pathogen#infect('.string(path).') to pathogen#infect('.string(path.'/{}').')')
                                  call pathogen#surround(path . '/{}')
                                endif
    1              0.000000   endfor
    1   0.017615   0.000009   call pathogen#cycle_filetype()
    1              0.000002   return ''

FUNCTION  nerdtree#runningWindows()
Called 2 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    2              0.000025     return has("win16") || has("win32") || has("win64")

FUNCTION  fuf#bookmarkfile#requiresOnCommandPre()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return 0

FUNCTION  fuf#jumplist#onInit()
Called 1 time
Total time:   0.000048
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000048   0.000009   call fuf#defineLaunchCommand('FufJumpList', s:MODE_NAME, '""', [])

FUNCTION  fuf#jumplist#renewCache()
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)

FUNCTION  fuf#quickfix#renewCache()
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)

FUNCTION  fuf#defineLaunchCommand()
Called 25 times
Total time:   0.001104
 Self time:   0.001104

count  total (s)   self (s)
   25              0.000074   if empty(a:tempVars)
   19              0.000045     let preCmd = ''
   19              0.000017   else
    6              0.000066     let preCmd = printf('call l9#tempvariables#setList(%s, %s) | ',             string(s:TEMP_VARIABLES_GROUP), string(a:tempVars))
    6              0.000006   endif
   25              0.000752   execute printf('command! -range -bang -narg=? %s %s call fuf#launch(%s, %s . <q-args>, len(<q-bang>))',        a:CmdName, preCmd, string(a:modeName), a:prefixInitialPattern)

FUNCTION  l9#concatPaths()
Called 1 time
Total time:   0.000086
 Self time:   0.000071

count  total (s)   self (s)
    1              0.000003   let result = ''
    3              0.000006   for p in a:paths
    2              0.000005     if empty(p)
                                  continue
                                elseif empty(result)
    1              0.000002       let result = p
    1              0.000001     else
    1   0.000035   0.000020       let result = substitute(result, '[/\\]$', '', '') . l9#getPathSeparator()    . substitute(p, '^[/\\]', '', '')
    1              0.000001     endif
    2              0.000002   endfor
    1              0.000002   return result

FUNCTION  fuf#bookmarkdir#requiresOnCommandPre()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   return 0

FUNCTION  nerdtree#postSourceActions()
Called 1 time
Total time:   0.015263
 Self time:   0.000296

count  total (s)   self (s)
    1   0.000065   0.000009     call g:NERDTreeBookmark.CacheBookmarks(0)
    1   0.014188   0.000007     call nerdtree#createDefaultBindings()
                            
                                "load all nerdtree plugins
    1   0.001008   0.000278     runtime! nerdtree_plugin/**/*.vim

FUNCTION  <SNR>13_MRU_LoadList()
Called 1 time
Total time:   0.000498
 Self time:   0.000094

count  total (s)   self (s)
                                " If the MRU file is present, then load the list of filenames. Otherwise
                                " start with an empty list.
    1              0.000010     if filereadable(g:MRU_File)
    1              0.000035         let s:MRU_files = readfile(g:MRU_File)
    1              0.000012         if s:MRU_files[0] =~# '^\s*" Most recently edited files in Vim'
                                        " Generated by the previous version of the MRU plugin.
                                        " Discard the list.
                                        let s:MRU_files = []
                                    elseif s:MRU_files[0] =~# '^#'
                                        " Remove the comment line
    1              0.000011             call remove(s:MRU_files, 0)
    1              0.000002         else
                                        " Unsupported format
                                        let s:MRU_files = []
                                    endif
    1              0.000001     else
                                    let s:MRU_files = []
                                endif
                            
                                " Refresh the MRU menu with the latest list of filenames
    1   0.000411   0.000007     call s:MRU_Refresh_Menu()

FUNCTION  <SNR>11_choose()
Called 27 times
Total time:   0.000139
 Self time:   0.000139

count  total (s)   self (s)
   27              0.000065     if &t_Co != 88 && &t_Co != 256
   27              0.000050         return a:mediocre
                                else
                                    return s:X(a:good)
                                endif

FUNCTION  pathogen#cycle_filetype()
Called 1 time
Total time:   0.017606
 Self time:   0.000318

count  total (s)   self (s)
    1              0.000004   if exists('g:did_load_filetypes')
    1   0.000654   0.000080     filetype off
    1   0.016943   0.000229     filetype on
    1              0.000002   endif

FUNCTION  fuf#bookmarkdir#onInit()
Called 1 time
Total time:   0.000057
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000047   0.000010   call fuf#defineLaunchCommand('FufBookmarkDir', s:MODE_NAME, '""', [])
    1              0.000008   command! -bang -narg=?        FufBookmarkDirAdd call s:bookmark(<q-args>)

FUNCTION  fuf#bookmarkfile#renewCache()
Called 1 time
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)

FUNCTION  pathogen#uniq()
Called 1 time
Total time:   0.000308
 Self time:   0.000308

count  total (s)   self (s)
    1              0.000003   let i = 0
    1              0.000002   let seen = {}
   13              0.000030   while i < len(a:list)
   12              0.000068     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
                                  call remove(a:list,i)
                                elseif a:list[i] ==# ''
                                  let i += 1
                                  let empty = 1
                                else
   12              0.000064       let seen[a:list[i]] = 1
   12              0.000022       let i += 1
   12              0.000009     endif
   12              0.000008   endwhile
    1              0.000002   return a:list

FUNCTION  fuf#buffertag#renewCache()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000004   let s:tagItemsCache = {}
    1              0.000002   let s:tagDataCache = {}

FUNCTION  fuf#callbackitem#renewCache()
Called 1 time
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)

FUNCTION  fuf#givenfile#onInit()
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)

FUNCTION  fuf#taggedfile#onInit()
Called 1 time
Total time:   0.000049
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000048   0.000010   call fuf#defineLaunchCommand('FufTaggedFile', s:MODE_NAME, '""', [])

FUNCTION  fuf#dir#requiresOnCommandPre()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   return 0

FUNCTION  fuf#addMode()
Called 21 times
Total time:   0.008764
 Self time:   0.001730

count  total (s)   self (s)
   21              0.000089   if count(g:fuf_modesDisable, a:modeName) > 0
    2              0.000002     return
                              endif
   19              0.000122   call add(s:modeNames, a:modeName)
   19   0.006084   0.001089   call fuf#{a:modeName}#renewCache()
   19   0.002150   0.000158   call fuf#{a:modeName}#onInit()
   19   0.000201   0.000154   if fuf#{a:modeName}#requiresOnCommandPre()
                                " cnoremap has a problem, which doesn't expand cabbrev.
                                cmap <silent> <expr> <CR> <SID>onCommandPre()
                              endif

FUNCTION  fuf#line#onInit()
Called 1 time
Total time:   0.000044
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000043   0.000007   call fuf#defineLaunchCommand('FufLine', s:MODE_NAME, '""', [])

FUNCTION  fuf#file#requiresOnCommandPre()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return 0

FUNCTION  fuf#taggedfile#renewCache()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000003   let s:cache = {}

FUNCTION  fuf#file#renewCache()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004   let s:cache = {}

FUNCTION  fuf#tag#onInit()
Called 1 time
Total time:   0.000093
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000046   0.000009   call fuf#defineLaunchCommand('FufTag'              , s:MODE_NAME, '""', [])
    1   0.000046   0.000008   call fuf#defineLaunchCommand('FufTagWithCursorWord', s:MODE_NAME, 'expand(''<cword>'')', [])

FUNCTION  l9#readFile()
Called 1 time
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
    1              0.000004   let args = copy(a:000)
    1              0.000035   let args[0] = expand(args[0])
    1              0.000002   try
    1              0.000036     return call('readfile', args)
                              catch
                              endtry
                              return []

FUNCTION  fuf#givencmd#onInit()
Called 1 time
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)

FUNCTION  fuf#givendir#renewCache()
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)

FUNCTION  l9#guardScriptLoading()
Called 22 times
Total time:   0.001187
 Self time:   0.001187

count  total (s)   self (s)
   22              0.000300   let loadedVarName = 'g:loaded_' . substitute(a:path, '\W', '_', 'g')
   22              0.000107   if exists(loadedVarName)
                                return 0
                              elseif a:vimVersion > 0 && a:vimVersion > v:version
                                echoerr a:path . ' requires Vim version ' . string(a:vimVersion * s:VERSION_FACTOR)
                                return 0
                              elseif a:l9Version > 0 && (a:l9Version > s:L9_VERSION_CURRENT ||                    a:l9Version < s:L9_VERSION_PASSABLE)
                                echoerr a:path . ' requires L9 library version ' . string(a:l9Version * s:VERSION_FACTOR)
                                return 0
                              endif
   22              0.000050   for expr in a:exprs
                                if !eval(expr)
                                  echoerr a:path . ' requires: ' . expr
                                  return 0
                                endif
                              endfor
   22              0.000173   let {loadedVarName} = 1
   22              0.000028   return 1

FUNCTION  fuf#tag#renewCache()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004   let s:cache = {}

FUNCTION  <SNR>14_initialize()
Called 1 time
Total time:   0.011778
 Self time:   0.000586

count  total (s)   self (s)
                              "---------------------------------------------------------------------------
    1   0.000019   0.000008   call l9#defineVariableDefault('g:fuf_modesDisable'     , [ 'mrufile', 'mrucmd', ])
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_keyOpen'          , '<CR>')
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_keyOpenSplit'     , '<C-j>')
    1   0.000015   0.000005   call l9#defineVariableDefault('g:fuf_keyOpenVsplit'    , '<C-k>')
    1   0.000015   0.000004   call l9#defineVariableDefault('g:fuf_keyOpenTabpage'   , '<C-l>')
    1   0.000015   0.000004   call l9#defineVariableDefault('g:fuf_keyPreview'       , '<C-@>')
    1   0.000014   0.000004   call l9#defineVariableDefault('g:fuf_keyNextMode'      , '<C-t>')
    1   0.000015   0.000005   call l9#defineVariableDefault('g:fuf_keyPrevMode'      , '<C-y>')
    1   0.000015   0.000005   call l9#defineVariableDefault('g:fuf_keyPrevPattern'   , '<C-s>')
    1   0.000014   0.000004   call l9#defineVariableDefault('g:fuf_keyNextPattern'   , '<C-_>')
    1   0.000015   0.000005   call l9#defineVariableDefault('g:fuf_keySwitchMatching', '<C-\><C-\>')
    1   0.000015   0.000005   call l9#defineVariableDefault('g:fuf_dataDir'          , '~/.vim-fuf-data')
    1   0.000013   0.000004   call l9#defineVariableDefault('g:fuf_abbrevMap'        , {})
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_patternSeparator' , ';')
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_promptHighlight'  , 'Question')
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_ignoreCase'       , 1)
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_splitPathMatching', 1)
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_fuzzyRefining'    , 0)
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_smartBs'          , 1)
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_reuseWindow'      , 1)
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_timeFormat'       , '(%Y-%m-%d %H:%M:%S)')
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_learningLimit'    , 100)
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_enumeratingLimit' , 50)
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_maxMenuWidth'     , 78)
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_previewHeight'    , 0)
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_autoPreview'      , 0)
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_useMigemo'        , 0)
                              "---------------------------------------------------------------------------
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_buffer_prompt'     , '>Buffer[]>')
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_buffer_switchOrder', 10)
    1   0.000013   0.000004   call l9#defineVariableDefault('g:fuf_buffer_mruOrder'   , 1)
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_buffer_keyDelete'  , '<C-]>')
                              "---------------------------------------------------------------------------
    1   0.000013   0.000004   call l9#defineVariableDefault('g:fuf_file_prompt'     , '>File[]>')
    1   0.000013   0.000004   call l9#defineVariableDefault('g:fuf_file_switchOrder', 20)
    1   0.000015   0.000006   call l9#defineVariableDefault('g:fuf_file_exclude'    , '\v\~$|\.(o|exe|dll|bak|orig|sw[po])$|(^|[/\\])\.(hg|git|bzr)($|[/\\])')
                              "---------------------------------------------------------------------------
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_coveragefile_prompt'     , '>CoverageFile[]>')
    1   0.000014   0.000006   call l9#defineVariableDefault('g:fuf_coveragefile_switchOrder', 30)
    1   0.000015   0.000006   call l9#defineVariableDefault('g:fuf_coveragefile_exclude'    , '\v\~$|\.(o|exe|dll|bak|orig|sw[po])$|(^|[/\\])\.(hg|git|bzr)($|[/\\])')
    1   0.000015   0.000006   call l9#defineVariableDefault('g:fuf_coveragefile_globPatterns', ['**/.*', '**/*'])
                              "---------------------------------------------------------------------------
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_dir_prompt'     , '>Dir[]>')
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_dir_switchOrder', 40)
    1   0.000014   0.000006   call l9#defineVariableDefault('g:fuf_dir_exclude'    , '\v(^|[/\\])\.(hg|git|bzr)($|[/\\])')
                              "---------------------------------------------------------------------------
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_mrufile_prompt'     , '>MRU-File[]>')
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_mrufile_switchOrder', 50)
    1   0.000015   0.000006   call l9#defineVariableDefault('g:fuf_mrufile_exclude'    , '\v\~$|\.(o|exe|dll|bak|orig|sw[po])$|^(\/\/|\\\\|\/mnt\/|\/media\/)')
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_mrufile_maxItem'    , 200)
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_mrufile_maxItemDir' , 50)
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_mrufile_keyExpand'  , '<C-]>')
                              "---------------------------------------------------------------------------
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_mrucmd_prompt'     , '>MRU-Cmd[]>')
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_mrucmd_switchOrder', 60)
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_mrucmd_exclude'    , '^$')
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_mrucmd_maxItem'    , 200)
                              "---------------------------------------------------------------------------
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_bookmarkfile_prompt'     , '>Bookmark-File[]>')
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_bookmarkfile_switchOrder', 70)
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_bookmarkfile_searchRange', 400)
    1   0.000018   0.000008   call l9#defineVariableDefault('g:fuf_bookmarkfile_keyDelete'  , '<C-]>')
                              "---------------------------------------------------------------------------
    1   0.000014   0.000006   call l9#defineVariableDefault('g:fuf_bookmarkdir_prompt'     , '>Bookmark-Dir[]>')
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_bookmarkdir_switchOrder', 80)
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_bookmarkdir_keyDelete'  , '<C-]>')
                              "---------------------------------------------------------------------------
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_tag_prompt'     , '>Tag[]>')
    1   0.000013   0.000004   call l9#defineVariableDefault('g:fuf_tag_switchOrder', 90)
                              "---------------------------------------------------------------------------
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_buffertag_prompt'     , '>Buffer-Tag[]>')
    1   0.000013   0.000004   call l9#defineVariableDefault('g:fuf_buffertag_switchOrder', 100)
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_buffertag_ctagsPath'  , 'ctags')
                              "---------------------------------------------------------------------------
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_taggedfile_prompt'     , '>Tagged-File[]>')
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_taggedfile_switchOrder', 110)
                              "---------------------------------------------------------------------------
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_jumplist_prompt'     , '>Jump-List[]>')
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_jumplist_switchOrder', 120)
                              "---------------------------------------------------------------------------
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_changelist_prompt'     , '>Change-List[]>')
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_changelist_switchOrder', 130)
                              "---------------------------------------------------------------------------
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_quickfix_prompt'     , '>Quickfix[]>')
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_quickfix_switchOrder', 140)
                              "---------------------------------------------------------------------------
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_line_prompt'     , '>Line[]>')
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_line_switchOrder', 150)
                              "---------------------------------------------------------------------------
    1   0.000014   0.000005   call l9#defineVariableDefault('g:fuf_help_prompt'     , '>Help[]>')
    1   0.000013   0.000005   call l9#defineVariableDefault('g:fuf_help_switchOrder', 160)
                              "---------------------------------------------------------------------------
    1              0.000009   command! -bang -narg=0 FufEditDataFile call fuf#editDataFile()
    1              0.000007   command! -bang -narg=0 FufRenewCache   call s:renewCachesOfAllModes()
                              "---------------------------------------------------------------------------
    1   0.002306   0.000067   call fuf#addMode('buffer')
    1   0.000463   0.000005   call fuf#addMode('file')
    1   0.000459   0.000004   call fuf#addMode('coveragefile')
    1   0.000451   0.000004   call fuf#addMode('dir')
    1   0.000011   0.000005   call fuf#addMode('mrufile')
    1   0.000009   0.000004   call fuf#addMode('mrucmd')
    1   0.000472   0.000004   call fuf#addMode('bookmarkfile')
    1   0.000405   0.000005   call fuf#addMode('bookmarkdir')
    1   0.000450   0.000004   call fuf#addMode('tag')
    1   0.001570   0.000005   call fuf#addMode('buffertag')
    1   0.000419   0.000005   call fuf#addMode('taggedfile')
    1   0.000410   0.000005   call fuf#addMode('jumplist')
    1   0.000399   0.000005   call fuf#addMode('changelist')
    1   0.000415   0.000005   call fuf#addMode('quickfix')
    1   0.000360   0.000004   call fuf#addMode('line')
    1   0.000475   0.000005   call fuf#addMode('help')
    1   0.000308   0.000004   call fuf#addMode('givenfile')
    1   0.000312   0.000005   call fuf#addMode('givendir')
    1   0.000324   0.000005   call fuf#addMode('givencmd')
    1   0.000341   0.000005   call fuf#addMode('callbackfile')
    1   0.000330   0.000005   call fuf#addMode('callbackitem')
                              "---------------------------------------------------------------------------

FUNCTION  <SNR>13_MRU_add_files_to_menu()
Called 1 time
Total time:   0.000242
 Self time:   0.000224

count  total (s)   self (s)
    3              0.000005     for fname in a:file_list
                                    " Escape special characters in the filename
    2              0.000019         let esc_fname = escape(fnamemodify(fname, ':t'), ".\\" . s:esc_filename_chars)
    2              0.000012         let esc_fname = substitute(esc_fname, '&', '&&', 'g')
                            
                                    " Truncate the directory name if it is long
    2              0.000008         let dir_name = fnamemodify(fname, ':h')
    2              0.000007         let len = strlen(dir_name)
                                    " Shorten long file names by adding only few characters from
                                    " the beginning and end.
    2              0.000004         if len > 30
                                        let dir_name = strpart(dir_name, 0, 10) . '...' .  strpart(dir_name, len - 20)
                                    endif
    2              0.000014         let esc_dir_name = escape(dir_name, ".\\" . s:esc_filename_chars)
    2              0.000011         let esc_dir_name = substitute(esc_dir_name, '&', '&&', 'g')
                            
    2              0.000012 	let menu_path = '&File.&Recent\ Files.' . a:prefix . esc_fname . '\ (' . esc_dir_name . ')'
    2   0.000033   0.000015 	let esc_mfname = s:MRU_escape_filename(fname)
    2              0.000043         exe 'anoremenu <silent> ' . menu_path . " :call <SID>MRU_Edit_File('" . esc_mfname . "', 1)<CR>"
    2              0.000021 	exe 'tmenu ' . menu_path . ' Edit file ' . esc_mfname
    2              0.000003     endfor

FUNCTION  <SNR>17_updateBufTimes()
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000016   let s:bufTimes[bufnr('%')] = localtime()

FUNCTION  fuf#givendir#requiresOnCommandPre()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   return 0

FUNCTION  278()
Called 5 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    5              0.000017     if !exists("s:menuItems")
    1              0.000002         let s:menuItems = []
    1              0.000001     endif
    5              0.000008     return s:menuItems

FUNCTION  fuf#callbackitem#requiresOnCommandPre()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   return 0

FUNCTION  fuf#quickfix#requiresOnCommandPre()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   return 0

FUNCTION  280()
Called 5 times
Total time:   0.000309
 Self time:   0.000269

count  total (s)   self (s)
    5              0.000035     let newMenuItem = copy(self)
                            
    5              0.000019     let newMenuItem.text = a:options['text']
    5              0.000015     let newMenuItem.shortcut = a:options['shortcut']
    5              0.000011     let newMenuItem.children = []
                            
    5              0.000013     let newMenuItem.isActiveCallback = -1
    5              0.000016     if has_key(a:options, 'isActiveCallback')
    1              0.000003         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
    1              0.000001     endif
                            
    5              0.000011     let newMenuItem.callback = -1
    5              0.000013     if has_key(a:options, 'callback')
    5              0.000015         let newMenuItem.callback = a:options['callback']
    5              0.000004     endif
                            
    5              0.000012     if has_key(a:options, 'parent')
                                    call add(a:options['parent'].children, newMenuItem)
                                else
    5   0.000081   0.000041         call add(s:MenuItem.All(), newMenuItem)
    5              0.000005     endif
                            
    5              0.000007     return newMenuItem

FUNCTION  287()
Called 100 times
Total time:   0.000762
 Self time:   0.000762

count  total (s)   self (s)
  100              0.000322     if !exists("s:keyMaps")
    1              0.000003         let s:keyMaps = []
    1              0.000001     endif
  100              0.000123     return s:keyMaps

FUNCTION  NERDTreeAddMenuItem()
Called 5 times
Total time:   0.000339
 Self time:   0.000030

count  total (s)   self (s)
    5   0.000337   0.000028     call g:NERDTreeMenuItem.Create(a:options)

FUNCTION  291()
Called 50 times
Total time:   0.010412
 Self time:   0.010032

count  total (s)   self (s)
   50   0.000677   0.000297     let maps = s:KeyMap.All()
 1275              0.001404     for i in range(len(maps))
 1225              0.004046          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
                                        return remove(maps, i)
                                    endif
 1225              0.000802     endfor

FUNCTION  294()
Called 50 times
Total time:   0.013347
 Self time:   0.001782

count  total (s)   self (s)
   50              0.000326     let newKeyMap = copy(self)
   50              0.000505     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
   50              0.000168     let newKeyMap.key = opts['key']
   50              0.000160     let newKeyMap.quickhelpText = opts['quickhelpText']
   50              0.000151     let newKeyMap.callback = opts['callback']
   50              0.000142     let newKeyMap.scope = opts['scope']
                            
   50   0.011803   0.000238     call s:KeyMap.Add(newKeyMap)

FUNCTION  295()
Called 50 times
Total time:   0.011565
 Self time:   0.000771

count  total (s)   self (s)
   50   0.010713   0.000301     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
   50   0.000821   0.000439     call add(s:KeyMap.All(), a:keymap)

FUNCTION  fuf#line#renewCache()
Called 1 time
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)

FUNCTION  fuf#coveragefile#onInit()
Called 1 time
Total time:   0.000078
 Self time:   0.000030

count  total (s)   self (s)
    1   0.000044   0.000007   call fuf#defineLaunchCommand('FufCoverageFile', s:MODE_NAME, '""', [])
    1   0.000017   0.000006   call l9#defineVariableDefault('g:fuf_coveragefile_name', '') " private option
    1              0.000007   command! -bang -narg=0        FufCoverageFileRegister call s:registerCoverage()
    1              0.000009   command! -bang -narg=?        FufCoverageFileChange call s:changeCoverage(<q-args>)

FUNCTION  fuf#changelist#requiresOnCommandPre()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   return 0

FUNCTION  nerdtree#createDefaultBindings()
Called 1 time
Total time:   0.014181
 Self time:   0.000526

count  total (s)   self (s)
    1   0.000037   0.000009     let s = '<SNR>' . s:SID() . '_'
                            
    1   0.000122   0.000010     call NERDTreeAddKeyMap({ 'key': '<MiddleRelease>', 'scope': "all", 'callback': s."handleMiddleMouse" })
    1   0.000108   0.000010     call NERDTreeAddKeyMap({ 'key': '<LeftRelease>', 'scope': "all", 'callback': s."handleLeftClick" })
    1   0.000119   0.000009     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "DirNode", 'callback': s."activateDirNode" })
    1   0.000124   0.000009     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "FileNode", 'callback': s."activateFileNode" })
    1   0.000133   0.000009     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "Bookmark", 'callback': s."activateBookmark" })
    1   0.000137   0.000009     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "all", 'callback': s."activateAll" })
                            
                            
    1   0.000142   0.000009     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "DirNode", 'callback': s."activateDirNode" })
    1   0.000154   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "FileNode", 'callback': s."activateFileNode" })
    1   0.000162   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "Bookmark", 'callback': s."activateBookmark" })
    1   0.000172   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "all", 'callback': s."activateAll" })
                            
    1   0.000175   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': "Node", 'callback': s."openHSplit" })
    1   0.000191   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': "Node", 'callback': s."openVSplit" })
                            
    1   0.000188   0.000009     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': "Bookmark", 'callback': s."openHSplit" })
    1   0.000199   0.000009     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': "Bookmark", 'callback': s."openVSplit" })
                            
    1   0.000200   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': "Node", 'callback': s."previewNodeCurrent" })
    1   0.000218   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': "Node", 'callback': s."previewNodeVSplit" })
    1   0.000216   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': "Node", 'callback': s."previewNodeHSplit" })
                            
    1   0.000223   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': "Bookmark", 'callback': s."previewNodeCurrent" })
    1   0.000240   0.000009     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': "Bookmark", 'callback': s."previewNodeVSplit" })
    1   0.000248   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': "Bookmark", 'callback': s."previewNodeHSplit" })
                            
    1   0.000246   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenRecursively, 'scope': "DirNode", 'callback': s."openNodeRecursively" })
                            
    1   0.000256   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdir, 'scope': "all", 'callback': s."upDirCurrentRootClosed" })
    1   0.000267   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdirKeepOpen, 'scope': "all", 'callback': s."upDirCurrentRootOpen" })
    1   0.000266   0.000009     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChangeRoot, 'scope': "Node", 'callback': s."chRoot" })
                            
    1   0.000274   0.000009     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChdir, 'scope': "Node", 'callback': s."chCwd" })
                            
    1   0.000281   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapQuit, 'scope': "all", 'callback': s."closeTreeWindow" })
                            
    1   0.000287   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCWD, 'scope': "all", 'callback': "nerdtree#chRootCwd" })
                            
    1   0.000305   0.000011     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefreshRoot, 'scope': "all", 'callback': s."refreshRoot" })
    1   0.000311   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefresh, 'scope': "Node", 'callback': s."refreshCurrent" })
                            
    1   0.000313   0.000009     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapHelp, 'scope': "all", 'callback': s."displayHelp" })
    1   0.000322   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleZoom, 'scope': "all", 'callback': s."toggleZoom" })
    1   0.000323   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleHidden, 'scope': "all", 'callback': s."toggleShowHidden" })
    1   0.000332   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFilters, 'scope': "all", 'callback': s."toggleIgnoreFilter" })
    1   0.000344   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFiles, 'scope': "all", 'callback': s."toggleShowFiles" })
    1   0.000353   0.000011     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleBookmarks, 'scope': "all", 'callback': s."toggleShowBookmarks" })
                            
    1   0.000359   0.000009     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseDir, 'scope': "Node", 'callback': s."closeCurrentDir" })
    1   0.000359   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseChildren, 'scope': "DirNode", 'callback': s."closeChildren" })
                            
    1   0.000362   0.000009     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapMenu, 'scope': "Node", 'callback': s."showMenu" })
                            
    1   0.000377   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpParent, 'scope': "Node", 'callback': s."jumpToParent" })
    1   0.000393   0.000011     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpFirstChild, 'scope': "Node", 'callback': s."jumpToFirstChild" })
    1   0.000406   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpLastChild, 'scope': "Node", 'callback': s."jumpToLastChild" })
    1   0.000403   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpRoot, 'scope': "all", 'callback': s."jumpToRoot" })
    1   0.000402   0.000011     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpNextSibling, 'scope': "Node", 'callback': s."jumpToNextSibling" })
    1   0.000478   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpPrevSibling, 'scope': "Node", 'callback': s."jumpToPrevSibling" })
                            
    1   0.000424   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': "Node", 'callback': s."openInNewTab" })
    1   0.000424   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': "Node", 'callback': s."openInNewTabSilent" })
    1   0.000435   0.000009     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': "Bookmark", 'callback': s."openInNewTab" })
    1   0.000441   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': "Bookmark", 'callback': s."openInNewTabSilent" })
                            
    1   0.000446   0.000009     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenExpl, 'scope': "DirNode", 'callback': s."openExplorer" })
                            
    1   0.000456   0.000010     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapDeleteBookmark, 'scope': "Bookmark", 'callback': s."deleteBookmark" })

FUNCTION  fuf#quickfix#onInit()
Called 1 time
Total time:   0.000047
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000047   0.000007   call fuf#defineLaunchCommand('FufQuickfix', s:MODE_NAME, '""', [])

FUNCTION  <SNR>37_initVariable()
Called 57 times
Total time:   0.001044
 Self time:   0.001044

count  total (s)   self (s)
   57              0.000185     if !exists(a:var)
   57              0.000733         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
   57              0.000063         return 1
                                endif
                                return 0

FUNCTION  pathogen#separator()
Called 8 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    8              0.000037   return !exists("+shellslash") || &shellslash ? '/' : '\'

FUNCTION  fuf#changelist#renewCache()
Called 1 time
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    1   0.019497   0.000089  pathogen#infect()
    1   0.017606   0.000318  pathogen#cycle_filetype()
    1   0.015263   0.000296  nerdtree#postSourceActions()
    1   0.014181   0.000526  nerdtree#createDefaultBindings()
   50   0.013627   0.000280  NERDTreeAddKeyMap()
   50   0.013347   0.001782  294()
    1   0.011778   0.000586  <SNR>14_initialize()
   50   0.011565   0.000771  295()
   50   0.010412   0.010032  291()
   21   0.008764   0.001730  fuf#addMode()
    1   0.005565   0.005372  pathogen#helptags()
    1   0.001802   0.000417  pathogen#incubate()
   22   0.001187             l9#guardScriptLoading()
   25   0.001104             fuf#defineLaunchCommand()
   57   0.001044             <SNR>37_initVariable()
  115   0.001022             l9#defineVariableDefault()
    1   0.000995   0.000280  fuf#buffertag#onInit()
  100   0.000762             287()
    7   0.000551   0.000087  pathogen#glob_directories()
    1   0.000498   0.000094  <SNR>13_MRU_LoadList()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   50   0.010412   0.010032  291()
    1   0.005565   0.005372  pathogen#helptags()
   50   0.013347   0.001782  294()
   21   0.008764   0.001730  fuf#addMode()
   22              0.001187  l9#guardScriptLoading()
   25              0.001104  fuf#defineLaunchCommand()
   57              0.001044  <SNR>37_initVariable()
  115              0.001022  l9#defineVariableDefault()
   50   0.011565   0.000771  295()
  100              0.000762  287()
    1   0.011778   0.000586  <SNR>14_initialize()
    1   0.014181   0.000526  nerdtree#createDefaultBindings()
    7   0.000464   0.000433  pathogen#glob()
    1   0.001802   0.000417  pathogen#incubate()
   17   0.000450   0.000363  <SNR>11_hifg()
    1              0.000349  pathogen#join()
    1   0.017606   0.000318  pathogen#cycle_filetype()
    1              0.000308  pathogen#uniq()
    2              0.000306  pathogen#split()
    1   0.015263   0.000296  nerdtree#postSourceActions()

